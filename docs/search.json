[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse quantitative - M1 et M2 - Villes et environnements urbains",
    "section": "",
    "text": "Ce site est dédié au cours d’analyse quantitative du master Villes et Environnements urbains.\nLes supports de cours pour le programme de M1\n\nSéance 1 - Les indicateurs\nSéance 2 - La catégorisation\nSéance 3 - La représentation graphique des données\nSéance 4 - Enquêtes par questionnaire et représentativité statistique\n\nLes supports de cours pour le programme de M2\n\nSéance 1 - Introduction à la corrélation linéaire et aux modèles de régression linéaire simple\nSéance 2 - Retour sur article et travail en groupe\nSéance 3 - Les modèles de régression linéaire complexe\nSéance 4 - Les modèles de régression logistique\n\nRessources pour la programmation : - Introduction à R et au tidyverse de Julien Barnier."
  },
  {
    "objectID": "Seance_1.html",
    "href": "Seance_1.html",
    "title": "Séance 1",
    "section": "",
    "text": "R Studio fonctionne en complément du logiciel de programmation R. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts.\n\n\n\n\nL’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap.\n\n\n\n\nNous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”.\n\n\n\nLes deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML.\n\n\n\n\n\n\n\nPour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préférera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\n\n\n\n\n\n\nNous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur1.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\nLes arguments permettent donc de spécifier le fonctionnement des fonctions. Pour obtenir les quantiles autres que la médiane, on peut utiliser la fonction quantile et préciser la probabilité qui nous intéresse :\n\ntailles &lt;- c(156, 178, 190, 203, 155, 157, 160, 180, 175, 164, 186, 190, 172)\n# Deux façons équivalentes d'obtenir la médiane\nmedian(tailles)\n\n[1] 175\n\nquantile(x = tailles, probs = 0.5)\n\n50% \n175 \n\n# Le premier quartile\nquantile(x = tailles, probs = 0.25)\n\n25% \n160 \n\n# Le troisième quartile\nquantile(x = tailles, probs = 0.75)\n\n75% \n186 \n\n# Les premier et troisième quartiles en même temps\nquantile(x = tailles, probs = c(0.25, 0.75))\n\n25% 75% \n160 186 \n\n# Le premier et le neuvième déciles\nquantile(x = tailles, probs = c(0.1, 0.9))\n\n  10%   90% \n156.2 190.0 \n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help ou en appuyant sur la touche F1.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)\n\n\n\n\n\nR étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante.\n\n\n\nExercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance_1.html#les-4-panneaux-de-linterface",
    "href": "Seance_1.html#les-4-panneaux-de-linterface",
    "title": "Séance 1",
    "section": "",
    "text": "L’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap."
  },
  {
    "objectID": "Seance_1.html#les-scripts",
    "href": "Seance_1.html#les-scripts",
    "title": "Séance 1",
    "section": "",
    "text": "Nous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”."
  },
  {
    "objectID": "Seance_1.html#lenvironnement-et-lespace-multifonction",
    "href": "Seance_1.html#lenvironnement-et-lespace-multifonction",
    "title": "Séance 1",
    "section": "",
    "text": "Les deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML."
  },
  {
    "objectID": "Seance_1.html#objets",
    "href": "Seance_1.html#objets",
    "title": "Séance 1",
    "section": "",
    "text": "Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préférera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc."
  },
  {
    "objectID": "Seance_1.html#fonctions",
    "href": "Seance_1.html#fonctions",
    "title": "Séance 1",
    "section": "",
    "text": "Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur1.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\nLes arguments permettent donc de spécifier le fonctionnement des fonctions. Pour obtenir les quantiles autres que la médiane, on peut utiliser la fonction quantile et préciser la probabilité qui nous intéresse :\n\ntailles &lt;- c(156, 178, 190, 203, 155, 157, 160, 180, 175, 164, 186, 190, 172)\n# Deux façons équivalentes d'obtenir la médiane\nmedian(tailles)\n\n[1] 175\n\nquantile(x = tailles, probs = 0.5)\n\n50% \n175 \n\n# Le premier quartile\nquantile(x = tailles, probs = 0.25)\n\n25% \n160 \n\n# Le troisième quartile\nquantile(x = tailles, probs = 0.75)\n\n75% \n186 \n\n# Les premier et troisième quartiles en même temps\nquantile(x = tailles, probs = c(0.25, 0.75))\n\n25% 75% \n160 186 \n\n# Le premier et le neuvième déciles\nquantile(x = tailles, probs = c(0.1, 0.9))\n\n  10%   90% \n156.2 190.0 \n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help ou en appuyant sur la touche F1.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)"
  },
  {
    "objectID": "Seance_1.html#sec-packages",
    "href": "Seance_1.html#sec-packages",
    "title": "Séance 1",
    "section": "",
    "text": "R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante."
  },
  {
    "objectID": "Seance_1.html#exercices",
    "href": "Seance_1.html#exercices",
    "title": "Séance 1",
    "section": "",
    "text": "Exercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance_1.html#tableau-de-données-data-frame",
    "href": "Seance_1.html#tableau-de-données-data-frame",
    "title": "Séance 1",
    "section": "Tableau de données (data frame)",
    "text": "Tableau de données (data frame)\nUn data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel.\nSi on se contente d’exécuter le nom de notre tableau de données R va, comme à son habitude, nous l’afficher dans la console (ou sous le bloc de code si vous n’avez pas modifié la zone de sortie).\n\nhdv2003\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n2  2  23 Femme                                                 &lt;NA&gt; 9738.396\n3  3  59 Homme                    Derniere annee d'etudes primaires 3994.102\n4  4  34 Homme Enseignement superieur y compris technique superieur 5731.662\n5  5  71 Femme                    Derniere annee d'etudes primaires 4329.094\n                  occup     qualif freres.soeurs clso\n1 Exerce une profession    Employe             8  Oui\n2       Etudiant, eleve       &lt;NA&gt;             2  Oui\n3 Exerce une profession Technicien             2  Non\n4 Exerce une profession Technicien             1  Non\n5              Retraite    Employe             0  Oui\n                        relig                     trav.imp    trav.satisf\n1 Ni croyance ni appartenance                Peu important Insatisfaction\n2 Ni croyance ni appartenance                         &lt;NA&gt;           &lt;NA&gt;\n3 Ni croyance ni appartenance Aussi important que le reste      Equilibre\n4  Appartenance sans pratique Moins important que le reste   Satisfaction\n5         Pratiquant regulier                         &lt;NA&gt;           &lt;NA&gt;\n  hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1       Non        Non          Non     Oui    Non    Non   Non         0\n2       Non        Non          Non     Non    Non    Oui   Oui         1\n3       Non        Non          Non     Non    Non    Non   Oui         0\n4       Non        Non          Non     Oui    Oui    Oui   Oui         2\n5       Non        Non          Non     Non    Non    Non   Non         3\n [ reached 'max' / getOption(\"max.print\") -- omitted 1995 rows ]\n\n\nUne autre manière d’afficher le contenu du tableau est de cliquer sur le nom de l’objet dans l’onglet Environment, ou d’utiliser la fonction View :\n\nView(hdv2003)\n\nIl est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille2.\nUn data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire :\n\nd &lt;- hdv2003\n\nce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite.\n\nStructure du tableau\nUn tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau.\n\nnrow(d)\n\n[1] 2000\n\n\n\nncol(d)\n\n[1] 20\n\n\nLa fonction dim renvoie ses dimensions, donc les deux nombres précédents.\n\ndim(d)\n\n[1] 2000   20\n\n\nOn peut ainsi accéder à certaines lignes et colonnes du tableau en utilisant les index et l’opérateur [], précédemment utilisé pour les vecteurs. La seule différence est qu’on donne ici 2 index plutôt qu’1 dans le cas des vecteurs : la ligne, puis la colonne, séparées par une virgule.\n\n# La case correspondant à la première ligne et la première colonne\nd[1, 1]\n\n[1] 1\n\n# Toute la première ligne\nd[1,]\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n                  occup  qualif freres.soeurs clso                       relig\n1 Exerce une profession Employe             8  Oui Ni croyance ni appartenance\n       trav.imp    trav.satisf hard.rock lecture.bd peche.chasse cuisine bricol\n1 Peu important Insatisfaction       Non        Non          Non     Oui    Non\n  cinema sport heures.tv\n1    Non   Non         0\n\n# Toute la première colonne\nd[,1]\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n [ reached getOption(\"max.print\") -- omitted 1900 entries ]\n\n# Les lignes de 1 à 10 et les colonnes de 2 et 3\nd[1:10, c(2,3)]\n\n   age  sexe\n1   28 Femme\n2   23 Femme\n3   59 Homme\n4   34 Homme\n5   71 Femme\n6   35 Femme\n7   60 Femme\n8   47 Homme\n9   20 Femme\n10  28 Homme\n\n\nLa fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables.\n\nnames(d)\n\n [1] \"id\"            \"age\"           \"sexe\"          \"nivetud\"      \n [5] \"poids\"         \"occup\"         \"qualif\"        \"freres.soeurs\"\n [9] \"clso\"          \"relig\"         \"trav.imp\"      \"trav.satisf\"  \n[13] \"hard.rock\"     \"lecture.bd\"    \"peche.chasse\"  \"cuisine\"      \n[17] \"bricol\"        \"cinema\"        \"sport\"         \"heures.tv\"    \n\n\nEnfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type et affiche les premières valeurs.\n\nstr(d)\n\n'data.frame':   2000 obs. of  20 variables:\n $ id           : int  1 2 3 4 5 6 7 8 9 10 ...\n $ age          : int  28 23 59 34 71 35 60 47 20 28 ...\n $ sexe         : Factor w/ 2 levels \"Homme\",\"Femme\": 2 2 1 1 2 2 2 1 2 1 ...\n $ nivetud      : Factor w/ 8 levels \"N'a jamais fait d'etudes\",..: 8 NA 3 8 3 6 3 6 NA 7 ...\n $ poids        : num  2634 9738 3994 5732 4329 ...\n $ occup        : Factor w/ 7 levels \"Exerce une profession\",..: 1 3 1 1 4 1 6 1 3 1 ...\n $ qualif       : Factor w/ 7 levels \"Ouvrier specialise\",..: 6 NA 3 3 6 6 2 2 NA 7 ...\n $ freres.soeurs: int  8 2 2 1 0 5 1 5 4 2 ...\n $ clso         : Factor w/ 3 levels \"Oui\",\"Non\",\"Ne sait pas\": 1 1 2 2 1 2 1 2 1 2 ...\n $ relig        : Factor w/ 6 levels \"Pratiquant regulier\",..: 4 4 4 3 1 4 3 4 3 2 ...\n $ trav.imp     : Factor w/ 4 levels \"Le plus important\",..: 4 NA 2 3 NA 1 NA 4 NA 3 ...\n $ trav.satisf  : Factor w/ 3 levels \"Satisfaction\",..: 2 NA 3 1 NA 3 NA 2 NA 1 ...\n $ hard.rock    : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ lecture.bd   : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ peche.chasse : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 2 2 1 1 ...\n $ cuisine      : Factor w/ 2 levels \"Non\",\"Oui\": 2 1 1 2 1 1 2 2 1 1 ...\n $ bricol       : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 2 1 1 1 2 1 1 ...\n $ cinema       : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 1 2 1 2 1 1 2 2 ...\n $ sport        : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 2 2 1 2 1 1 1 2 ...\n $ heures.tv    : num  0 1 0 2 3 2 2.9 1 2 2 ...\n\n\n\n\nAccéder aux variables d’un tableau\nUne opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape :\n\nd$sexe\n\n  [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme Homme\n [13] Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme Femme Femme\n [25] Femme Homme Femme Homme Homme Homme Homme Homme Homme Homme Femme Femme\n [37] Homme Femme Femme Homme Femme Homme Homme Femme Femme Homme Femme Femme\n [49] Femme Femme Homme Femme Homme Femme Homme Femme Femme Femme Homme Femme\n [61] Femme Homme Homme Homme Homme Femme Homme Homme Femme Femme Homme Homme\n [73] Femme Femme Femme Femme Homme Femme Femme Femme Femme Femme Femme Homme\n [85] Homme Femme Homme Homme Homme Homme Homme Femme Homme Femme Femme Femme\n [97] Homme Homme Femme Femme\n [ reached getOption(\"max.print\") -- omitted 1900 entries ]\nLevels: Homme Femme\n\n\nR va afficher l’ensemble des valeurs de la variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment.\nLa fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères.\nSi on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail.\n\nhead(d$age)\n\n[1] 28 23 59 34 71 35\n\n\n\ntail(d$age)\n\n[1] 46 45 46 24 24 66\n\n\nLe deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher.\n\n\nCréer une nouvelle variable\nOn peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur.\nPar exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé.\n\nhead(d$heures.tv)\n\n[1] 0 1 0 2 3 2\n\n\nOn peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée convertie en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante :\n\nd$minutes.tv &lt;- d$heures.tv * 60\n\nOn peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau.\n\nhead(d$minutes.tv)\n\n[1]   0  60   0 120 180 120"
  },
  {
    "objectID": "Seance_1.html#lâge-au-décès",
    "href": "Seance_1.html#lâge-au-décès",
    "title": "Séance 1",
    "section": "L’âge au décès",
    "text": "L’âge au décès\nOn charge ici deux tableaux de données, deces_f pour les femmes et deces_h pour les hommes, tirés du fichier des personnes décédées en France en 2019.\n\n# Chargement du tableau de données\ndec_f &lt;- aws.s3::s3read_using(FUN = data.table::fread,\n                           object = \"/diffusion/deces_f.csv\",\n                           bucket = \"aubinpoissonnier\",\n                           opts = list(\"region\" = \"\"))\n\ndec_h &lt;- aws.s3::s3read_using(FUN = data.table::fread,\n                           object = \"/diffusion/deces_h.csv\",\n                           bucket = \"aubinpoissonnier\",\n                           opts = list(\"region\" = \"\"))\n\n\nExploration du tableau de données\nLa plupart du temps, l’analyse quantitative porte sur des données de seconde main dont on ne contrôle pas la forme. Il est important de savoir comment prendre connaissance de l’organisation des données car c’est cette organisation qui va déterminer les étapes à réaliser pour produire des statistiques ou des représentations graphiques.\n\n# Visualisez les deux tableaux de données\n#View(dec_f)\n#View(dec_h)\n\n# Affichez leurs dimensions\ndim(dec_f)\n\n[1] 313267      5\n\n# Affichez le nom de leurs colonnes\nnames(dec_f)\n\n[1] \"nomprenom\" \"sexe\"      \"datenaiss\" \"datedeces\" \"age\"      \n\n# Affichez leur structure\nstr(dec_f)\n\nClasses 'data.table' and 'data.frame':  313267 obs. of  5 variables:\n $ nomprenom: chr  \"LAIBE*SUZANNE/\" \"SCHWAB*JOSETTE ELIANE/\" \"BRAVO*LUCIENNE LOUISE/\" \"BORNALLET*JEANNINE PAULETTE/\" ...\n $ sexe     : int  2 2 2 2 2 2 2 2 2 2 ...\n $ datenaiss: IDate, format: \"1926-01-11\" \"1931-01-07\" ...\n $ datedeces: IDate, format: \"2019-01-29\" \"2018-12-05\" ...\n $ age      : num  93 87.9 91.2 88.4 87.2 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n# Accédez à la colonne date de décès\ndec_f$lieunaiss\n\nNULL\n\n# Accédez à la colonne âge au décès\ndec_f$age\n\n  [1]  93.04860  87.90965  91.20055  88.44353  87.19233  91.92334  88.76660\n  [8]  93.22382  99.18686  78.76249  87.97536  93.55510  85.86721  87.84942\n [15]  78.71321  70.27242  83.00890  73.52772  94.01780  92.64887  97.08145\n [22]  93.04586  87.53457  90.03149  86.90760  70.26420  73.74949  89.47570\n [29]  87.46886  97.91650  70.98426  85.44011  92.64887  66.85832  91.55099\n [36]  75.40315  95.63313 104.26557  81.64545  87.63313  97.92745  54.75428\n [43]  95.31006  86.15743  88.36140  85.23203  68.40794  38.94045  85.71116\n [50]  89.45106  91.53730  94.00958  90.84463  89.28131  73.25120  87.71526\n [57]  96.32854  79.41684  96.33949  90.54620  76.48734  89.38261  91.70979\n [64]  89.42916  47.45243  96.23819  47.01437  86.73785  64.91444  84.81862\n [71]  84.32307  60.76112  94.89391  88.58590  86.02053  83.82204  91.58111\n [78]  91.43874  69.57700  57.82341  95.72074  63.09103  79.73443  70.14100\n [85]  96.93634  87.12389  84.05202  93.59890  97.45380  85.36619  98.57358\n [92]  45.13895  91.32649  83.87953  98.89117  80.07940  85.97125  91.73443\n [99]  54.73238  85.60712\n [ reached getOption(\"max.print\") -- omitted 313167 entries ]\n\n\n\n\nCalcul des indicateurs\n\nTransformer des données administratives\nLe tableau suit une structure simple : une ligne par personne décédée. En réalité le tableau a déjà été modifié car il a fallu calculer l’âge au décès en faisant l’écart entre les dates de naissance et de décès renseignées. Deux problèmes se sont posés.\nUn premier problème émerge quand on utilise la fonction class qui permet de connaître la nature d’un objet, par exemple la nature de nos colonnes comme l’affichait déjà la fonction str :\n\n# La nature de chaque colonne du tableau\nstr(dec_f)\n\nClasses 'data.table' and 'data.frame':  313267 obs. of  5 variables:\n $ nomprenom: chr  \"LAIBE*SUZANNE/\" \"SCHWAB*JOSETTE ELIANE/\" \"BRAVO*LUCIENNE LOUISE/\" \"BORNALLET*JEANNINE PAULETTE/\" ...\n $ sexe     : int  2 2 2 2 2 2 2 2 2 2 ...\n $ datenaiss: IDate, format: \"1926-01-11\" \"1931-01-07\" ...\n $ datedeces: IDate, format: \"2019-01-29\" \"2018-12-05\" ...\n $ age      : num  93 87.9 91.2 88.4 87.2 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n# La nature des colonnes des dates\nclass(dec_f$datenaiss)\n\n[1] \"IDate\" \"Date\" \n\nclass(dec_f$datedeces)\n\n[1] \"IDate\" \"Date\" \n\n# La colonne en elle-même\ndec_f$datenaiss\n\n  [1] \"1926-01-11\" \"1931-01-07\" \"1927-10-01\" \"1930-07-05\" \"1931-10-20\"\n  [6] \"1927-01-26\" \"1930-04-01\" \"1925-10-15\" \"1919-11-02\" \"1940-04-13\"\n [11] \"1931-02-04\" \"1925-06-23\" \"1933-03-02\" \"1931-03-19\" \"1940-04-16\"\n [16] \"1948-10-01\" \"1936-01-01\" \"1945-06-04\" \"1924-12-23\" \"1926-04-27\"\n [21] \"1921-11-24\" \"1925-12-20\" \"1931-07-02\" \"1929-01-02\" \"1932-02-15\"\n [26] \"1948-10-12\" \"1945-04-19\" \"1929-07-29\" \"1931-07-31\" \"1921-02-18\"\n [31] \"1948-01-14\" \"1933-08-10\" \"1926-05-10\" \"1952-02-24\" \"1927-06-18\"\n [36] \"1943-08-09\" \"1923-05-22\" \"1914-10-01\" \"1937-05-19\" \"1931-05-26\"\n [41] \"1921-02-16\" \"1964-04-13\" \"1923-10-01\" \"1932-11-27\" \"1930-08-19\"\n [46] \"1933-10-07\" \"1950-08-24\" \"1980-02-06\" \"1933-05-09\" \"1929-05-16\"\n [51] \"1927-04-14\" \"1925-01-06\" \"1928-03-07\" \"1929-09-30\" \"1945-10-12\"\n [56] \"1931-04-25\" \"1922-09-19\" \"1939-08-21\" \"1922-09-17\" \"1928-06-12\"\n [61] \"1942-07-13\" \"1929-08-21\" \"1927-04-12\" \"1929-07-23\" \"1971-07-16\"\n [66] \"1922-10-03\" \"1971-12-29\" \"1932-04-09\" \"1954-02-05\" \"1934-03-13\"\n [71] \"1934-09-09\" \"1958-04-09\" \"1924-02-15\" \"1930-06-18\" \"1933-01-09\"\n [76] \"1935-03-12\" \"1927-03-12\" \"1927-08-17\" \"1949-06-22\" \"1961-02-22\"\n [81] \"1923-02-16\" \"1955-12-10\" \"1939-04-09\" \"1948-10-30\" \"1922-02-20\"\n [86] \"1931-12-10\" \"1934-12-26\" \"1925-06-12\" \"1921-08-01\" \"1933-08-15\"\n [91] \"1920-05-27\" \"1973-11-15\" \"1927-09-12\" \"1935-02-12\" \"1920-02-20\"\n [96] \"1938-12-14\" \"1933-01-24\" \"1927-04-22\" \"1964-04-23\" \"1933-06-08\"\n [ reached 'max' / getOption(\"max.print\") -- omitted 313167 entries ]\n\n\nOn voit que datenaiss et datedeces sont des colonnes qui contiennent du texte : la date sous format “AAAA-MM-JJ”. Calculer l’âge suppose de faire une différence temporelle à partir d’une information codée comme du texte, ce qui peut impliquer de :\n\nArrondir en ne gardant que les 4 premiers caractères, soit l’année, puis transformer cette nouvelle colonne en un vecteur numérique\nTransformer cette colonne en objet date, géré par R, pour qu’il réalise lui-même le calcul de la différence temporelle\n\nUn deuxième problème érmege quand on utilise la fonction is.na() qui permet de tester si une valeur est codée comme NA pour not available, soit comme valeur manquante.\n\n# On applique la fonction is.na aux dates\nis.na(dec_f$datedeces)\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 313167 entries ]\n\nis.na(dec_f$datenaiss)\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 313167 entries ]\n\n\nOn obtient un résultat d’un nouveau genre, de nature logique : soit FALSE pour faux, soit TRUE pour vrai. Ainsi, tous les éléments pour lesquels le résultat du test est vrai correspondent à des valeurs manquantes.\nComme la fonction applique le test pour chaque élément du vecteur (chaque ligne de la colonne du tableau étudiée ici), on obtient un vecteur de la même longueur que la colonne initiale.\n\n# Longueur de la colonne (= qui est un vecteur rangé dans un tableau de données)\nlength(dec_f$datenaiss)\n\n[1] 313267\n\n# Longueur du test is.na appliqué à la colonne\nlength(is.na(dec_f$datenaiss))\n\n[1] 313267\n\n\nUne façon de compter le nombre de valeurs manquantes consiste à compter le nombre de TRUE, qui sur un plan informatique valent 1, en faisant la somme du vecteur :\n\n# On fait la somme des éléments du vecteur, ce qui permet de compter le nombre de valeurs manquantes\nsum(is.na(dec_f$datenaiss))\n\n[1] 1681\n\nsum(is.na(dec_f$datedeces))\n\n[1] 7\n\nsum(is.na(dec_f$age))\n\n[1] 1688\n\n\nOn remarque que les 1688 valeurs manquantes pour l’âge du décès chez les femmes correspond à 1681 femmes dont on ne connaît pas la date de naissance plus 7 autres femmes dont on ne connaît pas la date de décès.\n\n# Comparaison du nombre de valeurs manquantes entre les variables initiales des dates et la variable recodée de l'âge au décès\nsum(is.na(dec_f$datenaiss)) + sum(is.na(dec_f$datedeces))\n\n[1] 1688\n\nsum(is.na(dec_f$age))\n\n[1] 1688\n\n\n\n\nRéalisation des calculs avec les fonctions de base\nCalculez la moyenne, la moyenne, les premier et troisième quartiles et finalement les premier et neuvième déciles de l’âge au décès chez les femmes et chez les hommes.\n\n# La moyenne d'âge au décès\nmean(dec_f$age)\n\n[1] NA\n\nmean(dec_f$age, na.rm = T)\n\n[1] 82.90085\n\nmean(dec_h$age, na.rm = T)\n\n[1] 75.52103\n\n# La médiane d'âge au décès\nmedian(dec_f$age, na.rm = T)\n\n[1] 87.19781\n\nmedian(dec_h$age, na.rm = T)\n\n[1] 79.01711\n\n# Les quartiles\nquantile(dec_f$age, probs = c(0.25, 0.75), na.rm = T)\n\n     25%      75% \n77.01300 92.69815 \n\nquantile(dec_h$age, probs = c(0.25, 0.75), na.rm = T)\n\n     25%      75% \n66.94045 87.56468 \n\n# Les déciles extrêmes\nquantile(dec_f$age, probs = c(0.1, 0.9), na.rm = T)\n\n     10%      90% \n63.32649 96.47091 \n\nquantile(dec_h$age, probs = c(0.1, 0.9), na.rm = T)\n\n     10%      90% \n55.23340 92.43806"
  },
  {
    "objectID": "Seance_1.html#lespérance-de-vie",
    "href": "Seance_1.html#lespérance-de-vie",
    "title": "Séance 1",
    "section": "L’espérance de vie",
    "text": "L’espérance de vie\nOn charge maintenant les tables de mortalité de 2019 fournies par l’INSEE. C’est elles qui nous permettront de calculer l’espérance de vie.\n\n# Chargement des données\nmort &lt;- aws.s3::s3read_using(FUN = data.table::fread,\n                           object = \"/diffusion/tab_mort19.csv\",\n                           bucket = \"aubinpoissonnier\",\n                           opts = list(\"region\" = \"\"))\n\n\nExploration du tableau\nExplorez le tableau de données et tentez de comprendre à quoi correspondent les colonnes en vous rappelant le protocole de calcul de l’espérance de vie.\n\n# Visualiser\n#View(mort)\n\n# La structure\nstr(mort)\n\nClasses 'data.table' and 'data.frame':  105 obs. of  3 variables:\n $ age    : int  0 1 2 3 4 5 6 7 8 9 ...\n $ dec_hom: int  431 31 20 14 11 10 9 8 7 7 ...\n $ dec_fem: int  357 25 13 13 9 7 8 5 6 6 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n\nRéfléchissez maintenant aux étapes qu’il faudrait suivre pour aboutir au calcul de l’espérance de vie à la naissance chez les hommes et chez les femmes.\n\n\nCalculs\n\n## Calcul de la moyenne d'âge au décès de la génération fictive\n# Première étape de la moyenne d'âge pondérée\n# Multiplier chaque âge par le nombre de personnes décédées à cet âge\nmort$age_p_fem &lt;- mort$age*mort$dec_fem\nmort$age_p_hom &lt;- mort$age*mort$dec_hom\n\n\n# Deuxième étape, faire la somme des âges pondérés et diviser par le total d'individu\n# Chez les femmes\nesp_fem &lt;- sum(mort$age_p_fem)/sum(mort$dec_fem)\n\n# Chez les hommes\nesp_hom &lt;- sum(mort$age_p_hom)/sum(mort$dec_hom)\n\n# Arrondis\n# En explicitant le deuxième argument\nesp_femr1 &lt;- round(esp_fem, digits = 2)\nesp_femr1\n\n[1] 84.92\n\n# En donnant le deuxième argument implicitement\nesp_femr2 &lt;- round(esp_fem, 2)\nesp_femr2\n\n[1] 84.92\n\n# En utilisant la valeur par défaut\nesp_femr3 &lt;- round(esp_fem)\nesp_femr3\n\n[1] 85\n\n\nComparez la valeur de l’indicateur de l’espérance de vie par rapport à la valeur de l’âge moyen au décès\n\n# Chez les femmes\nmean(dec_f$age, na.rm = T)\n\n[1] 82.90085\n\nesp_fem\n\n[1] 84.91695\n\n# Chez les hommes\nmean(dec_h$age, na.rm = T)\n\n[1] 75.52103\n\nesp_hom\n\n[1] 79.01931\n\n\nCalculez l’espérance de vie à 40 ans chez les hommes et chez les femmes.\n\n# On sélectionne les lignes à partir de 40 ans\ndim(mort)\n\n[1] 105   5\n\n# Soit de la 41eme ligne à la dernière, la 105ème\nmort40 &lt;- mort[41:105,]\n\n# Et on refait les mêmes calculs, en repartant d'un âge 0\nmort40$age &lt;- mort40$age - 40\n\n# Première étape de la moyenne d'âge pondérée\n# Multiplier chaque âge par le nombre de personnes décédées à cet âge\nmort40$age_p_fem &lt;- mort40$age*mort40$dec_fem\nmort40$age_p_hom &lt;- mort40$age*mort40$dec_hom\n\n\n# Deuxième étape, faire la somme des âges pondérés et diviser par le total d'individu\n# Chez les femmes\nesp_fem &lt;- sum(mort40$age_p_fem)/sum(mort40$dec_fem)\n\n# Chez les hommes\nesp_hom &lt;- sum(mort40$age_p_hom)/sum(mort40$dec_hom)\n\n# Arrondis\n# En explicitant le deuxième argument\nesp_femr1 &lt;- round(esp_fem, digits = 2)\nesp_femr1\n\n[1] 45.74\n\n# En donnant le deuxième argument implicitement\nesp_femr2 &lt;- round(esp_fem, 2)\nesp_femr2\n\n[1] 45.74\n\n# En utilisant la valeur par défaut\nesp_femr3 &lt;- round(esp_fem)\nesp_femr3\n\n[1] 46\n\n\nCalculez maintenant l’espérance de vie à la naissance sans distinguer selon le sexe.\n\n## Calcul de la moyenne d'âge au décès de la génération fictive\n# Regrouper les hommes et les femmes\nmort$dec &lt;- mort$dec_fem + mort$dec_hom\n\n# Première étape de la moyenne d'âge pondérée\n# Multiplier chaque âge par le nombre de personnes décédées à cet âge\nmort$age_p &lt;- mort$age*mort$dec\n\n# Deuxième étape, faire la somme des âges pondérés et diviser par le total d'individu\nesp &lt;- sum(mort$age_p)/sum(mort$dec)\n\n# Arrondis\n# En explicitant le deuxième argument\nesp_r1 &lt;- round(esp, digits = 2)\n# En donnant le deuxième argument implicitement\nesp_r2 &lt;- round(esp, 2)\nesp_r2\n\n[1] 81.97\n\n# En utilisant la valeur par défaut\nesp_r3 &lt;- round(esp)\nesp_r3\n\n[1] 82"
  },
  {
    "objectID": "Seance_1.html#footnotes",
    "href": "Seance_1.html#footnotes",
    "title": "Séance 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nc est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎\nLa seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎"
  },
  {
    "objectID": "Seance_2.html",
    "href": "Seance_2.html",
    "title": "Séance 2",
    "section": "",
    "text": "Vous travaillez ici avec les données du recensement anonymisées, publiées sous forme d’un fichier comportant une ligne par individu. La base rp correspond au recensement de 2017 pour la ville de Lyon. Le dictionnaire des codes est disponible à cette adresse.\n\n\n\n\nLa fonction table fait partie des fonctions intégrées au R de base. Elle permet de réaliser des tris à plat sur un vecteur et des tris croisés sur deux vecteurs.\nLe tableau rp contient une colonne sexe qui correspond à la variable qui vaut 1 si l’individu recensé est un homme et 2 si l’individu est une femme. On peut compter le nombre d’hommes et de femmes :\n\ntable(rp$sexe)\n\n\n     1      2 \n 90962 102985 \n\n\nOn peut aussi connaître le nombre de personnes en couple grâce à la colonne couple\n\ntable(rp$couple)\n\n\n     1      2 \n 76546 117401 \n\n\nQuand les données sont livrées avec des poids d’échantillonnage, on peut utiliser la fonction wtd.table pour calculer des effectifs pondérés.\n\nwtd.table(rp$sexe, weights = rp$ipondi)\n\n       1        2 \n242020.5 274039.1 \n\n\n\n\n\nSouvent, on cherche plutôt à obtenir des pourcentages que des effectifs absolus. La fonction proportions permet de calculer la part associée chaque modalité de la variable. Elle s’applique à l’objet créé par la fonction table.\nLa part d’hommes/de femmes dans la population du département du Rhône\n\ntab_sexe &lt;- wtd.table(rp$sexe, weights = rp$ipondi)\nproportions(tab_sexe)\n\n        1         2 \n0.4689777 0.5310223 \n\n\nLa part de personnes en couple\n\ntab_couple &lt;- wtd.table(rp$couple, weights = rp$ipondi)\nproportions(tab_couple)\n\n        1         2 \n0.4011596 0.5988404 \n\n\nOn peut encore modifier ce tableau pour faciliter la lecture, par exemple en convertissant cette proportion en pourcentages\n\n# En décomposant ligne par ligne\ntab_sexe &lt;- wtd.table(rp$sexe, weights = rp$ipondi)\ntab_sexe &lt;- proportions(tab_sexe)\ntab_sexe &lt;- tab_sexe*100\ntab_sexe &lt;- round(tab_sexe, 2)\ntab_sexe\n\n   1    2 \n46.9 53.1 \n\n# En cumulant les fonctions\ntab_sexe &lt;- proportions(wtd.table(rp$sexe, weights = rp$ipondi))\ntab_sexe &lt;- round(tab_sexe*100, 2)\ntab_sexe\n\n   1    2 \n46.9 53.1 \n\n\n\n\n\nPour croiser deux variables, il suffit d’ajouter la deuxième colonne comme deuxième argument. La part d’hommes et de femmes en couple :\n\ntab_sexe_couple &lt;- wtd.table(rp$sexe, rp$couple, weights = rp$ipondi)\ntab_sexe_couple\n\n         1        2\n1 104684.8 137335.7\n2 102337.5 171701.6\n\n\nPour les tableaux croisés, les fonctions lprop et cprop du package questionr permettent d’obtenir très facilement les pourcentages en ligne ou en colonne ainsi que les marges.\n\nrprop(tab_sexe_couple)\n\n    1     2     Total\n1    43.3  56.7 100.0\n2    37.3  62.7 100.0\nAll  40.1  59.9 100.0\n\ncprop(tab_sexe_couple)\n\n      1     2     All  \n1      50.6  44.4  46.9\n2      49.4  55.6  53.1\nTotal 100.0 100.0 100.0\n\n\n\n\n\n\nLa mise en forme des tableaux sur R et leur exportation demande de nombreuses étapes supplémentaires. Le plus simple pour vous reste de construire votre tableau en recopiant à la main les valeurs sans faire d’erreurs, ou bien utiliser la fonction View() et copier coller les valeurs dans un logiciel de traitement de texte (Word ou Libre Office Writer) ou un tableur (Excel ou Libre Office Calc). N’oubliez pas d’ajouter les parts dans l’ensemble de la population pour comparer. Nous verrons dans la prochaine séance des packages supplémentaires pour le faire directement dans R.\n\n\n\n\nDéterminez la part de la population qui est étudiante (= lyonnais·es qui sont inscrit·es dans un établissement d’enseignement supérieur)\n\n\n# On calcul les effectifs avec un tri à plat\ntab_etud &lt;- wtd.table(rp$etud, weights = rp$ipondi)\n# Puis la proportion\nproportions(tab_etud)\n\n        1         2 \n0.2914641 0.7085359 \n\n\n\nDéterminez pour les hommes et pour les femmes la part d’étudiant·es\n\n\n# On calcul les effectifs avec un tri croisé\ntab_etud &lt;- wtd.table(rp$sexe, rp$etud, weights = rp$ipondi)\n# Puis la proportion\nrprop(tab_etud)\n\n    1     2     Total\n1    28.8  71.2 100.0\n2    29.5  70.5 100.0\nAll  29.1  70.9 100.0\n\n\n\nDéterminez la part de femmes et d’hommes chez les étudiant·es et chez les non étudiant·es\n\n\n# On calcul les effectifs avec un tri croisé en inversant les variables\ntab_etud &lt;- wtd.table(rp$etud, rp$sexe, weights = rp$ipondi)\n# Puis la proportion\nrprop(tab_etud)\n\n    1     2     Total\n1    46.3  53.7 100.0\n2    47.1  52.9 100.0\nAll  46.9  53.1 100.0"
  },
  {
    "objectID": "Seance_2.html#tri-à-plat-et-tri-croisé",
    "href": "Seance_2.html#tri-à-plat-et-tri-croisé",
    "title": "Séance 2",
    "section": "",
    "text": "La fonction table fait partie des fonctions intégrées au R de base. Elle permet de réaliser des tris à plat sur un vecteur et des tris croisés sur deux vecteurs.\nLe tableau rp contient une colonne sexe qui correspond à la variable qui vaut 1 si l’individu recensé est un homme et 2 si l’individu est une femme. On peut compter le nombre d’hommes et de femmes :\n\ntable(rp$sexe)\n\n\n     1      2 \n 90962 102985 \n\n\nOn peut aussi connaître le nombre de personnes en couple grâce à la colonne couple\n\ntable(rp$couple)\n\n\n     1      2 \n 76546 117401 \n\n\nQuand les données sont livrées avec des poids d’échantillonnage, on peut utiliser la fonction wtd.table pour calculer des effectifs pondérés.\n\nwtd.table(rp$sexe, weights = rp$ipondi)\n\n       1        2 \n242020.5 274039.1 \n\n\n\n\n\nSouvent, on cherche plutôt à obtenir des pourcentages que des effectifs absolus. La fonction proportions permet de calculer la part associée chaque modalité de la variable. Elle s’applique à l’objet créé par la fonction table.\nLa part d’hommes/de femmes dans la population du département du Rhône\n\ntab_sexe &lt;- wtd.table(rp$sexe, weights = rp$ipondi)\nproportions(tab_sexe)\n\n        1         2 \n0.4689777 0.5310223 \n\n\nLa part de personnes en couple\n\ntab_couple &lt;- wtd.table(rp$couple, weights = rp$ipondi)\nproportions(tab_couple)\n\n        1         2 \n0.4011596 0.5988404 \n\n\nOn peut encore modifier ce tableau pour faciliter la lecture, par exemple en convertissant cette proportion en pourcentages\n\n# En décomposant ligne par ligne\ntab_sexe &lt;- wtd.table(rp$sexe, weights = rp$ipondi)\ntab_sexe &lt;- proportions(tab_sexe)\ntab_sexe &lt;- tab_sexe*100\ntab_sexe &lt;- round(tab_sexe, 2)\ntab_sexe\n\n   1    2 \n46.9 53.1 \n\n# En cumulant les fonctions\ntab_sexe &lt;- proportions(wtd.table(rp$sexe, weights = rp$ipondi))\ntab_sexe &lt;- round(tab_sexe*100, 2)\ntab_sexe\n\n   1    2 \n46.9 53.1 \n\n\n\n\n\nPour croiser deux variables, il suffit d’ajouter la deuxième colonne comme deuxième argument. La part d’hommes et de femmes en couple :\n\ntab_sexe_couple &lt;- wtd.table(rp$sexe, rp$couple, weights = rp$ipondi)\ntab_sexe_couple\n\n         1        2\n1 104684.8 137335.7\n2 102337.5 171701.6\n\n\nPour les tableaux croisés, les fonctions lprop et cprop du package questionr permettent d’obtenir très facilement les pourcentages en ligne ou en colonne ainsi que les marges.\n\nrprop(tab_sexe_couple)\n\n    1     2     Total\n1    43.3  56.7 100.0\n2    37.3  62.7 100.0\nAll  40.1  59.9 100.0\n\ncprop(tab_sexe_couple)\n\n      1     2     All  \n1      50.6  44.4  46.9\n2      49.4  55.6  53.1\nTotal 100.0 100.0 100.0"
  },
  {
    "objectID": "Seance_2.html#mettre-en-forme-un-tableau",
    "href": "Seance_2.html#mettre-en-forme-un-tableau",
    "title": "Séance 2",
    "section": "",
    "text": "La mise en forme des tableaux sur R et leur exportation demande de nombreuses étapes supplémentaires. Le plus simple pour vous reste de construire votre tableau en recopiant à la main les valeurs sans faire d’erreurs, ou bien utiliser la fonction View() et copier coller les valeurs dans un logiciel de traitement de texte (Word ou Libre Office Writer) ou un tableur (Excel ou Libre Office Calc). N’oubliez pas d’ajouter les parts dans l’ensemble de la population pour comparer. Nous verrons dans la prochaine séance des packages supplémentaires pour le faire directement dans R."
  },
  {
    "objectID": "Seance_2.html#exercices",
    "href": "Seance_2.html#exercices",
    "title": "Séance 2",
    "section": "",
    "text": "Déterminez la part de la population qui est étudiante (= lyonnais·es qui sont inscrit·es dans un établissement d’enseignement supérieur)\n\n\n# On calcul les effectifs avec un tri à plat\ntab_etud &lt;- wtd.table(rp$etud, weights = rp$ipondi)\n# Puis la proportion\nproportions(tab_etud)\n\n        1         2 \n0.2914641 0.7085359 \n\n\n\nDéterminez pour les hommes et pour les femmes la part d’étudiant·es\n\n\n# On calcul les effectifs avec un tri croisé\ntab_etud &lt;- wtd.table(rp$sexe, rp$etud, weights = rp$ipondi)\n# Puis la proportion\nrprop(tab_etud)\n\n    1     2     Total\n1    28.8  71.2 100.0\n2    29.5  70.5 100.0\nAll  29.1  70.9 100.0\n\n\n\nDéterminez la part de femmes et d’hommes chez les étudiant·es et chez les non étudiant·es\n\n\n# On calcul les effectifs avec un tri croisé en inversant les variables\ntab_etud &lt;- wtd.table(rp$etud, rp$sexe, weights = rp$ipondi)\n# Puis la proportion\nrprop(tab_etud)\n\n    1     2     Total\n1    46.3  53.7 100.0\n2    47.1  52.9 100.0\nAll  46.9  53.1 100.0"
  },
  {
    "objectID": "Seance_2.html#exercices-1",
    "href": "Seance_2.html#exercices-1",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\nAppliquez un test sur les habitant·es de Lyon qui vérifie si ils et elles sont :\n\nImmigré·es\nImmigré·es et majeur·es\nImmgré·es marié·es ou pacsé·es\nImmigré·es français·es marié·es ou pacsé\nImmigré·es français marié·es ou immigré·es étranger·es pacsé·es\nImmigré·es pas propriétaires\n\n\n# 1\nrp$immi == 1\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# 2\nrp$immi == 1 & \n  rp$agerev &gt; 17\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# 3 \nrp$immi == 1 &\n  rp$stat_conj %in% 1:2\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# 4\nrp$immi == 1 &\n  rp$stat_conj %in% 1:2 &\n  rp$inatc == 1\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# 5\n(rp$immi == 1 &\n  rp$stat_conj == 1 &\n    rp$inatc == 1) |\n  (rp$immi == 1 &\n  rp$stat_conj == 2 &\n  rp$inatc == 2)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# 6\nrp$immi == 1 &\n  rp$stocd != 10\n\n [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]"
  },
  {
    "objectID": "Seance_2.html#filtrer-des-lignes-et-sélectionner-des-colonnes",
    "href": "Seance_2.html#filtrer-des-lignes-et-sélectionner-des-colonnes",
    "title": "Séance 2",
    "section": "Filtrer des lignes et sélectionner des colonnes",
    "text": "Filtrer des lignes et sélectionner des colonnes\n\nfilter\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. On réutilise donc les opérateurs logiques vus dans le cas des tests. Puisque le premier argument est le tableau en lui-même, il n’est plus nécessaire d’utiliser l’opérateur $ et il suffit d’utiliser le nom dans colonnes pour filter.\n\n# Filtre pour sélectionner les femmes\nrp_f &lt;- filter(rp, sexe == 2)\n\n# Filtre pour sélectionner les femmes immigrées\nrp_f &lt;- filter(rp, sexe == 2 & immi == 1)\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les personnes qui sont plus âgées que l’âge médian.\n\nrp_senior &lt;- filter(rp, agerev &gt; median(agerev))\n\n\n\nselect\nselect permet de sélectionner des colonnes d’un tableau de données.\n\n# Sélectionner uniquement les colonnes du sexe et de l'âge\nselect(rp, sexe, agerev)\n\n         sexe agerev\n        &lt;int&gt;  &lt;int&gt;\n     1:     1     25\n     2:     2     28\n     3:     2      2\n     4:     2     30\n     5:     1     33\n    ---             \n193943:     1     18\n193944:     1     18\n193945:     1     18\n193946:     2     18\n193947:     1     18\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\n# Sélectionner toutes les colonnes sauf le sexe et l'âge\nselect(rp, -sexe, -agerev)\n\n        cantville  nummi  achlr  aemmr  aged ager20 agerevq  anai  anemr   apaf\n          arm  ascen   bain   bati catiris   catl catpc   chau   chfl   chos\n          clim   cmbl couple   cs1   cuis  dept  derou   dipl   dnai    eau\n         egoul   elec   empl  etud   garl   hlml iletud    ilt  immi  inai\n        inatc  infam  inper inperf    ipondi   iran      iris  lienf   lprf\n          lprm metrodom  moco  modv   na17    na5 naidt   nbpi ne17fr ne24fr\n         ne3fr  ne5fr  nenfr  nperr   numf oridt   rech region   sani sanidom\n           sfm statr stat_conj  stocd   surf  tact tactd16     tp  trans triris\n          typc  typfc   typl  typmc  typmr   voit     wc\n [ reached getOption(\"max.print\") -- omitted 12 rows ]"
  },
  {
    "objectID": "Seance_2.html#créer-une-colonne-et-recoder-sous-conditions",
    "href": "Seance_2.html#créer-une-colonne-et-recoder-sous-conditions",
    "title": "Séance 2",
    "section": "Créer une colonne et recoder sous conditions",
    "text": "Créer une colonne et recoder sous conditions\n\nmutate\nLa fonction mutate permet de créer une nouvelle colonne. C’est une alternative à la méthode de base avec l’opétaeur $. Le premier type de recodage consiste à changer la nature d’une colonne. On vérifie la nature d’une colonne avec la fonction class et on peut la modifier avec les fonctions de la forme as.nature_désirée : as.integer, as.character etc.\n\n# Vérifier la nature de la variable\nclass(rp$agerev)\n\n[1] \"integer\"\n\n# On transforme cette colonne en format texte\n# Ancienne solution avec l'opérateur $\nrp$agerev_txt &lt;- as.character(rp$agerev)\nclass(rp$agerev_txt)\n\n[1] \"character\"\n\n# Nouvelle solution avec la fonction mutate\n# Attention : on transforme le tableau de données, plus seulement une colonne\n# À nouveau, on fait directement référence au nom des colonnes\nrp &lt;-\n  mutate(\n    # Le premier argument est le tableau à modifié\n    rp,\n    # Le deuxième la variable à créer : son nom puis son contenu\n    agerev_txt = as.character(agerev)\n  )\n\n\n\nif_else\nLa fonction if_else permet de faire une action sous condition : si l’âge est supérieur à 18, donne la valeur “majeur.e”, sinon donne la valeur “mineur.e”. case_when étend ce fonctionnement à plus d’une possibilité : si l’âge est supérieur à 18 donne “majeur.e”, si l’âge est compris entre 18 et 64 donne “adulte”, si l’âge est supérieur à 64 donne “senior”.\nOn pourra dire à R : crée une nouvelle colonne (mutate) à partir d’un test sur la valeur initiale de la variable (if_else).\n\n# Voici deux versions du codage de l'âge des personnes recensées, soit la variable agerev. La première est lisible, la deuxième est commentée ligne par ligne.\n\n# Version plus lisible sans les commentaires\nrp &lt;- mutate(\n  rp,\n  age_rec = \n    if_else(\n      agerev &gt; 17,\n      \"Majeur.e\",\n      \"Mineur.e\"\n    )\n)\n\n# Version commentée\nrp &lt;-\n  # J'utilise la fonction mutate pour créer une colonne\n  mutate(\n    # Le premier argument de mutate, le tableau à transformer\n    rp,\n    # Le deuxième argument de mutate, le nom de la colonne à créer (à gauche du =) et la valeur que je lui donne (à droite du =)\n    age_rec = \n      # Elle sera créée à l'aide du test opérée par la fonction ifelse\n      if_else(\n        # Le premier argument de ifelse, la condition\n        agerev &gt; 17,\n        # Le deuxième argument de ifelse, la valeur à donner si la condition est vérifiée\n        \"Majeur.e\", \n        # Le troisième argument de ] ifelse, la valeur à donner si la condition n'est pas vérifié\n        \"Mineur.e\"\n        # Je ferme la parenthèse de la fonction if_else\n      )\n    # Je ferme la parenthèse de la fonction mutate\n  ) \n\n# On obtient bien une nouvelle variable/colonne nommée age_rec qui prend soit la valeur \"Mineur.e\", soit la valeur \"Majeur.e\"\n\n\n\ncase_when\nDès qu’on veut utiliser plus d’un test (par exemple, obtenir trois valeurs : mineur.e, adulte, senior), il faut utiliser la fonction case_when.\n\n# Version lisible\nrp &lt;- \n  mutate(\n  rp,\n  age_rec =\n    case_when(\n      agerev &lt; 18 ~ \"Mineur.e\",\n      agerev &gt; 17 & agerev &lt; 65 ~ \"Adulte\",\n      agerev &gt; 64 ~ \"Senior\"\n    )\n)\n\n\n# Version commentée\nrp &lt;-\n  # Je crée une variable grâce à la fonction mutat\n  mutate(\n    # Le premier argument, je transforme le tableau rp\n    rp,\n    # Le deuxième argument, la variable à créer\n    age_rec = \n      # Qui sera créee grâce à la fonction case_when\n      case_when(\n        # À gauche du \"~\", c'est la condition, à droite la valeur\n        # Si agerev est strictement inférieur à 18, alors la variable prendra la valeur \"Mineur.e\"\n        agerev &lt; 18 ~ \"Mineur.e\",\n        # Si agerev est strictement supérieur à 17 ET qu'agerev est strictement inférieur à 65, alors la variable prendra la valeur \"Adulte\"\n        agerev &gt; 17 & agerev &lt; 65 ~ \"Adulte\",\n         # Si agerev est strictement supérieur à 64, alors la variable prendra la valeur \"Senior\"\n        agerev &gt; 64 ~ \"Senior\"\n        # Je ferme la parenthèse de la fonction case_when\n      )\n     # Je ferme la parenthèse de la fonction mutate\n  )"
  },
  {
    "objectID": "Seance_2.html#exercices-2",
    "href": "Seance_2.html#exercices-2",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\n\nCréez une nouvelle variable (colonne) qui vaut 1 si l’individu est propriétaire et 0 sinon.\nCréez une nouvelle variable qui vaut 1 si l’individu est logé dans le secteur libre et 0 si l’individu est logé dans le secteur HLM.\nCréez un nouveau tableau de données rp_prop qui ne contient que les individus propriétaires. Faites de même avec rp_hlm qui ne contient que les individus du secteur HLM.\nCalculez la part de propriétaires à Lyon. Calculez la part de personnes logées dans le secteur HLM.\nCréez une nouvelle variable dont les trois modalités seront d’être propriétaire, d’être locataire et d’être locataire HLM.\nCalculez les effectifs et les parts de chacun de ces trois statuts d’occupation.\nCréez une variable catégorielle synthétique qui croise le genre et le statut d’occupation du logement.\n\n\n# 1\nrp &lt;-\n  mutate(\n    rp,\n    prop =\n      if_else(\n        stocd == 10,\n        1,\n        0\n      )\n  )\n\n# 2\nrp &lt;- \n  mutate(\n    rp,\n    libre = \n      if_else(\n        stocd != 22,\n        1,\n        0\n      )\n  )\n\n# 3\nrp_prop &lt;- filter(rp, prop == 1)\nrp_hlm &lt;- filter(rp, libre != 1)\n\n# 4\ntab_prop &lt;- wtd.table(rp$prop, weights = rp$ipondi)\nproportions(tab_prop)\n\n       0        1 \n0.642252 0.357748 \n\ntab_libre &lt;- wtd.table(rp$libre, weights = rp$ipondi)\nproportions(tab_libre)\n\n        0         1 \n0.1865278 0.8134722 \n\n# 5\nrp &lt;- \n  mutate(\n    rp,\n    stat_occ = \n      case_when(\n        stocd == 10 ~ \"Propriétaire\",\n        stocd %in% c(21, 23, 30) ~ \"Locataire\",\n        stocd == 22 ~ \"Locataire HLM\"\n      )\n  )\n\n\n# 6\ntab_stat_occ &lt;- wtd.table(rp$stat_occ, weights = rp$ipondi, useNA = \"always\")\nproportions(tab_stat_occ)\n\n    Locataire Locataire HLM  Propriétaire          &lt;NA&gt; \n   0.42592401    0.18652782    0.35774796    0.02980021 \n\n# 7\nrp &lt;-\n  mutate(\n    rp,\n    occ_genre = \n      case_when(\n        stat_occ == \"Locataire\" & sexe == 1 ~ \"Homme locataire\",\n        stat_occ == \"Propriétaire\" & sexe == 1 ~ \"Homme propriétaire\",\n        stat_occ == \"Locataire HLM\" & sexe == 1 ~ \"Homme locataire HLM\",\n        stat_occ == \"Locataire\" & sexe == 2 ~ \"Femme locataire\",\n        stat_occ == \"Propriétaire\" & sexe == 2 ~ \"Femme propriétaire\",\n         stat_occ == \"Locataire HLM\" & sexe == 2 ~ \"Femme locataire HLM\"\n      ),\n    occ_genre = fct(occ_genre,\n                    levels = c(\"Homme propriétaire\",\n                               \"Homme locataire\",\n                               \"Homme locataire HLM\",\n                               \"Femme propriétaire\",\n                               \"Femme locataire\",\n                               \"Femme locataire HLM\"))\n  )\n\n\nfct\nNous n’avons pas spécifié la nature de notre nouvelle colonne/vecteur. On cherche ici à créer un facteur puisqu’on a une variable catégorielle. La fonction fct permet de créer un vecteur et de spécifier l’ordre de ses modalités (quand on fera des tableaux ou des graphiques, on voudra que “Senior” apparaisse en dernier, et non entre “Mineur.e” et “Majeur.e”\n\n# Un vecteur de type texte qui renseigne la catégorie d'âge de 6 personnes\ncat_age &lt;- c(\"Mineur.e\", \n             \"Adulte\", \n             \"Adulte\", \n             \"Senior\", \n             \"Mineur.e\",\n             \"Senior\")\n# Le tri croisé ne donne pas quelque chose d'intuitif :\ntable(cat_age)\n\ncat_age\n  Adulte Mineur.e   Senior \n       2        2        2 \n\n# La catégorie adulte apparaît avant mineur.e\n# On le transforme en facteur\ncat_age &lt;-\n  fct(\n    # Le premier argument, le facteur à transformer\n    cat_age, \n      # Le deuxième argument, les modalités (levels) avec l'ordre d'apparition\n      levels =  c(\"Mineur.e\", \"Adulte\", \"Senior\")\n      )\n# Le problème est résolu\ntable(cat_age)\n\ncat_age\nMineur.e   Adulte   Senior \n       2        2        2 \n\n\nFinalement, la fonction irec permet de réaliser le recodage d’une variable catégorielle par le biais d’une interface. Elle vous permet de changer les modalités d’une variable, par exemple passer d’un codage numérique aux étiquettes en texte, en faisant appel à la fonction fct_recode. Elle n’est à lancer qu’une fois pour obtenir le code et peut être retirée par la suite.\n\n# Recodage interactif de la variable sexe\nirec(rp$sexe)\n\n\n## Recoding rp$sexe into rp$sexe_rec\nrp$sexe_rec &lt;- rp$sexe %&gt;%\n  as.character() %&gt;%\n  fct_recode(\n    \"Hommes\" = \"1\",\n    \"Femmes\" = \"2\"\n  )"
  },
  {
    "objectID": "Seance_2.html#exercices-3",
    "href": "Seance_2.html#exercices-3",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\n\nCréez une variable catégorielle appelée immigre à deux modalités : Immigré/Non immigré\nCréez une variable catégorielle stat_immi à trois modalités : Immigré étranger/immigré français/français non immigré\n\n\n# 1\nrp &lt;-\n  mutate(\n    rp,\n    immigre = \n      fct(\n        if_else(immi == 1, \"Immigré\", \"Non immigré\"),\n        levels = c(\"Immigré\", \"Non immigré\")\n  )\n  )\n\n# 2\nrp &lt;-\n  mutate(\n    rp,\n    stat_immi =\n      fct(\n        case_when(\n          immi == 1 & inatc == 2 ~ \"Immigré étranger\",\n          immi == 1 & inatc == 1 ~ \"Immigré français\",\n          immi == 2 ~ \"Français non immigré\"\n        ),\n        levels = c(\"Immigré étranger\",\n                   \"Immigré français\",\n                   \"Français non immigré\")\n      )\n  )"
  },
  {
    "objectID": "Seance_2.html#calculer-des-indicateurs-dans-des-sous-groupes",
    "href": "Seance_2.html#calculer-des-indicateurs-dans-des-sous-groupes",
    "title": "Séance 2",
    "section": "Calculer des indicateurs dans des sous-groupes",
    "text": "Calculer des indicateurs dans des sous-groupes\nLes opérations de comparaison d’indicateurs impliquent qu’il faille répéter le même calcul au sein de sous-groupes distincts. Deux fonctions permettront d’aboutir à un tel résultat.\n\nSummarize et .by\nLa fonction summarize permet d’obtenir un tableau synthétique qui recense le résultat d’opérations de calcul. Elle s’utilise avec l’argument .by qui définit dans quelles sous-populations le logiciel doit travailler : chez les hommes puis chez les femmes (distinguées par la variable sexe), par arrondissements (distingués par la variable arm) etc.\n\n# La moyenne d'âge des lyonnais·es\nmean(rp$agerev)\n\n[1] 35.97611\n\n# La fonction summarize sans groupes spécifiés par .by\nsummarize(rp, \n          age_m = mean(agerev))\n\n     age_m\n1 35.97611\n\n# On obtient 1 seule ligne : la moyenne d'âge des lyonnais·es\n\n# La fonction summarize avec groupes spécifiés par .by\nsummarize(rp, \n          age_m = mean(agerev),\n          .by = sexe)\n\n  sexe    age_m\n1    1 34.75168\n2    2 37.05759\n\n# On obtient 2 lignes : l'âge moyen des femmes et des hommes\n\nL’argument .by peut aussi être un argument de la fonction mutate. On peut par exemple vouloir créer une colonne qui ajoute une variable à chaque individu renseignant la valeur prise par le sous-groupes. Par exemple, l’âge moyen dans le groupe définit par le sexe, pour ensuite faire l’écart entre l’âge de l’individu et l’âge moyen des personnes de même sexe.\n\n# Créer une colonne qui renseigne l'âge moyen dans le sous-groupe de sexe\nrp &lt;- \n  mutate(\n    rp,\n    age_m = mean(agerev),\n    .by = sexe)\n\n# Vérifier le résultat\nrp$age_m\n\n [1] 34.75168 37.05759 37.05759 37.05759 34.75168 37.05759 37.05759 37.05759\n [9] 34.75168 37.05759 37.05759 37.05759 37.05759 34.75168 37.05759 34.75168\n[17] 37.05759 34.75168 37.05759 34.75168 34.75168 37.05759 37.05759 34.75168\n[25] 34.75168 37.05759 34.75168 37.05759 34.75168 34.75168 34.75168 34.75168\n[33] 37.05759 34.75168 37.05759 34.75168 37.05759 37.05759 34.75168 37.05759\n[41] 37.05759 34.75168 37.05759 34.75168 37.05759 34.75168 34.75168 34.75168\n[49] 34.75168 37.05759\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]\n\n# Calculer la différence entre l'âge individuel et l'âge moyen dans le sous-groupe de sexe\nrp &lt;- \n  mutate(\n    rp,\n    dif_age_m = agerev - age_m)\n\n# Vérifier le résultat\nrp$dif_age_m\n\n [1]  -9.7516765  -9.0575909 -35.0575909  -7.0575909  -1.7516765  37.9424091\n [7] -34.0575909 -19.0575909   6.2483235  -9.0575909 -25.0575909 -24.0575909\n[13]  25.9424091  30.2483235  15.9424091  22.2483235 -36.0575909  -0.7516765\n[19]  -4.0575909   2.2483235 -17.7516765  10.9424091 -10.0575909 -12.7516765\n[25]  -3.7516765 -11.0575909  54.2483235  -8.0575909  -8.7516765   5.2483235\n[31] -24.7516765 -20.7516765   3.9424091  30.2483235  24.9424091  23.2483235\n[37]  18.9424091  -2.0575909   3.2483235 -23.0575909   7.9424091  19.2483235\n[43] -18.0575909  43.2483235 -19.0575909  -4.7516765  30.2483235  32.2483235\n[49]  20.2483235  63.9424091\n [ reached getOption(\"max.print\") -- omitted 193897 entries ]"
  },
  {
    "objectID": "Seance_2.html#exercices-4",
    "href": "Seance_2.html#exercices-4",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\n\nCalculez l’âge moyen des immigré·es et des non-immigré·es\nCalculez l’âge moyen des immigré·es et des non-immigré·es selon le sexe\nCréez une colonne age_immisexe de l’âge moyen selon le statut d’immigration\nCréez une colonne qui fais la différence entre l’âge individuel et l’âge moyen age_immisexe\n\n\n# 1\nsummarize(\n  rp,\n  age_m = mean(agerev),\n  .by = immi\n)\n\n  immi    age_m\n1    2 35.14182\n2    1 41.23992\n\n# 2\nsummarize(\n  rp,\n  age_m = mean(agerev),\n  .by = c(immi, sexe)\n)\n\n  immi sexe    age_m\n1    2    1 33.64813\n2    2    2 36.46826\n3    1    2 40.70833\n4    1    1 41.86260\n\n# 3\nrp &lt;-\n  mutate(\n    rp,\n    age_m = mean(agerev),\n    .by = c(immi, sexe)\n  )\n\n\n# 4\nrp &lt;-\n  mutate(\n    rp,\n    diff_age_m = agerev - age_m,\n  )"
  },
  {
    "objectID": "Seance_2.html#footnotes",
    "href": "Seance_2.html#footnotes",
    "title": "Séance 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nPour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎"
  }
]