[
  {
    "objectID": "pptS2.html#pourquoi-travailler-sur-le-fait-migratoire",
    "href": "pptS2.html#pourquoi-travailler-sur-le-fait-migratoire",
    "title": "Powerpoint - Séance 2",
    "section": "Pourquoi travailler sur le fait migratoire",
    "text": "Pourquoi travailler sur le fait migratoire\n\nLe droit des étranger.es est surtout droit contre les étranger.es : les moyens dont les États se dotent pour contrôler l’entrée et la vie des étranger.es sur son territoire\nLe conflit entre la souveraineté Étatique et le droit des personnes pose un problème juridique parfois tranché grâce à la statistique. Proportionnalité du droit : les moyens de contrôle dérogatoires restent-ils légaux ?\nFabrication du droit de l’État lié à la conjoncture politique et la perception des flux migratoires\n\n\n\nConstruction d’un droit contre les étrangers plutôt que droit des étrangers, droit des États à contrôler les étrangers. Lien entre les décisions judiciaires et la perception du fait migratoire : puisque la souveraineté des États entre en conflit avec le droit des personnes, il y a une incertitude juridique sur le degré de contrôle légal et réalisable dans les faits, c’est-à-dire les moyens de coercion.\nÀ partir de quel seuil les flux migratoires deviennent « massifs », et assez importants pour adopter des procédés dérogatoires sans enfreindre le principe de proportionnalité ?\nFabrication du droit de l’État lié à la conjoncture politique et la perception des flux migratoires\nFabrication du droit de l’État lié aux usages sociaux des statistiques par ceux qui pratiquent et produisent le droit (jurisprudence, interprétation des constitutions internationales, traités, droits nationaux, respect des procédures, situation d’urgence ..)"
  },
  {
    "objectID": "pptS2.html#le-fait-migratoire-daprès-les-graphiques-de-françois-héran",
    "href": "pptS2.html#le-fait-migratoire-daprès-les-graphiques-de-françois-héran",
    "title": "Powerpoint - Séance 2",
    "section": "Le fait migratoire d’après les graphiques de François Héran",
    "text": "Le fait migratoire d’après les graphiques de François Héran\n\n\nLe graphique\n\nAnnées 1850/1871 : doublement, craintes très fortes des population allogènes alors qu’en proportion, ce n’est rien.\nFin XIXe, stagnation, grande crise, incidence directe des conditions économiques sur les flux migratoires.\nPremière Guerre Mondiale, données manquante (recensement tous les 5 ans). Appel massif aux étranger·es, plus seulement les voisin·es puisqu’on va chercher les Polonais·es (avant plutôt Belges, Allemand·es, Italien·nes, Suisses). Les charbonnages de France.\nCrise des années 30, reflux très important, renvoi de + de 100 000 polonais·es « manu militari »\nDébut années 50, les années de reconstruction et de rattrapage économique. 1974, stop à l’immigration de travail. Obsession de VGE avec les maghrébin·es, et d’autres haut·es fonctionnaires.\nDepuis 2000, la migration progresse de façon rapide et constante. Recensement tournant, estimation annuelle.\n\nInsister sur\n\nles deux dimensions et les deux échelles (avec une légende chacune) ainsi que les effets d’optiques : rappeler les valeurs chiffrées, ordre de grandeur\nsémiologie graphique : deux figurés, deux couleurs opposées avec cohérence des couleurs\nla forme même du graphique : ce sont des points reliés par des droites, soit une « linéarisation » des niveaux mesurés à intervalles fixes\nl’illusion de continuité : pour le coup, relative stabilité de la définition d’immigré·e, donc possible de remonter à longtemps\nles ruptures : données manquantes, changement de mode de collecte\nles légendes\nRevenir après sur concrètement, à quoi ressemble le tableau du recensement et quelles opérations on doit faire pour arriver à un tableau qui contient toutes les informations nécessaires?"
  },
  {
    "objectID": "pptS2.html#la-progression-mondiale",
    "href": "pptS2.html#la-progression-mondiale",
    "title": "Powerpoint - Séance 2",
    "section": "La progression mondiale",
    "text": "La progression mondiale"
  },
  {
    "objectID": "pptS2.html#les-titres-de-séjour",
    "href": "pptS2.html#les-titres-de-séjour",
    "title": "Powerpoint - Séance 2",
    "section": "Les titres de séjour",
    "text": "Les titres de séjour"
  },
  {
    "objectID": "pptS2.html#les-titres-de-séjours-familiaux",
    "href": "pptS2.html#les-titres-de-séjours-familiaux",
    "title": "Powerpoint - Séance 2",
    "section": "Les titres de séjours familiaux",
    "text": "Les titres de séjours familiaux"
  },
  {
    "objectID": "pptS2.html#les-données-du-recensement-de-la-population",
    "href": "pptS2.html#les-données-du-recensement-de-la-population",
    "title": "Powerpoint - Séance 2",
    "section": "Les données du recensement de la population",
    "text": "Les données du recensement de la population\n\n\n\n\nLa version anonymisée du recensement est en accès libre sur le site de l’INSEE. Plusieurs fichiers existent (niveau logement, niveau individu localisé à la région, au canton-ville) et censurent différents types d’information.\nLes données harmonisées entre 1968 et 2019 permettent de créer des séries longues beaucoup plus simplement qu’en compilant les différents recensements.\n\n\n\n\n\ndim(rp)\n\n[1] 51531264        4\n\nhead(rp, 20)\n\n    AN_RECENS POND REG_NAIS NATIO\n 1:      1968 1568       84   000\n 2:      1968   12       84   1ES\n 3:      1968   40       84   1IT\n 4:      1968    4       84   3DZ\n 5:      1968 1696       84   000\n 6:      1968    8       84   1ES\n 7:      1968   24       84   1IT\n 8:      1968   12       84   3DZ\n 9:      1968 1432       84   000\n10:      1968    4       84   1ES\n11:      1968   28       84   1IT\n12:      1968    4       84   1PT\n13:      1968   16       84   3DZ\n14:      1968 1604       84   000\n15:      1968   16       84   1ES\n16:      1968   32       84   1IT\n17:      1968    4       84   1PT\n18:      1968    4       84   3DZ\n19:      1968    4       84   3TN\n20:      1968 1616       84   000"
  },
  {
    "objectID": "pptS2.html#opérations-nécessaires-pour-construire-les-graphiques-dévolution-du-nombre-et-de-la-proportion-dimmigré.es",
    "href": "pptS2.html#opérations-nécessaires-pour-construire-les-graphiques-dévolution-du-nombre-et-de-la-proportion-dimmigré.es",
    "title": "Powerpoint - Séance 2",
    "section": "Opérations nécessaires pour construire les graphiques d’évolution du nombre et de la proportion d’immigré.es",
    "text": "Opérations nécessaires pour construire les graphiques d’évolution du nombre et de la proportion d’immigré.es\n\nCréer une variable qui renseigne le statut d’immigration\nCompter pour chaque année le nombre d’immigré.es (effectifs)\nDiviser le nombre d’immigré.es par le nombre de français.es à une année donnée\nConstruire un graphique avec un abscisse pour les années et une ordonnée pour le nombre ou la proportion\nPlacer les points et les relier avec des traits\nAjouter des légendes"
  },
  {
    "objectID": "pptS2.html#créer-une-variable-dimmigration",
    "href": "pptS2.html#créer-une-variable-dimmigration",
    "title": "Powerpoint - Séance 2",
    "section": "Créer une variable d’immigration",
    "text": "Créer une variable d’immigration"
  },
  {
    "objectID": "pptS2.html#calculer-les-effectifs",
    "href": "pptS2.html#calculer-les-effectifs",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les effectifs",
    "text": "Calculer les effectifs\n\n\n\n## Obtenir les effectifs absolus\ntab_eff &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) # Compte des effectifs pondérés\n\n\n\ntab_eff\n\n    AN_RECENS IMMI        n\n 1:      1968    0 46416268\n 2:      1968    1  3238284\n 3:      1975    0 48711970\n 4:      1975    1  3887460\n 5:      1982    0 50258576\n 6:      1982    1  4037036\n 7:      1990    0 53855423\n 8:      1990    1  4222237\n 9:      1999    0 55769985\n10:      1999    1  4374266\n11:      2008    0 58588985\n12:      2008    1  5347567\n13:      2013    0 59729778\n14:      2013    1  5835094\n15:      2019    0 60469081\n16:      2019    1  6515809"
  },
  {
    "objectID": "pptS2.html#calculer-les-pourcentages---1",
    "href": "pptS2.html#calculer-les-pourcentages---1",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les pourcentages - 1",
    "text": "Calculer les pourcentages - 1\n\n\n\n## Obtenir les pourcentages\ntab_p &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) %&gt;% # Compte des effectifs pondérés\n  group_by(AN_RECENS) %&gt;% # Opération par année\n  mutate(p = n/sum(n)) %&gt;% # Part dans la population\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde qu'une ligne sur deux\n  select(-IMMI) # On enlève la colonne immigration\n\n\n\ntab_p\n\n    AN_RECENS IMMI        n          p\n 1:      1968    0 46416268 0.93478374\n 2:      1968    1  3238284 0.06521626\n 3:      1975    0 48711970 0.92609312\n 4:      1975    1  3887460 0.07390688\n 5:      1982    0 50258576 0.92564710\n 6:      1982    1  4037036 0.07435290\n 7:      1990    0 53855423 0.92730015\n 8:      1990    1  4222237 0.07269985\n 9:      1999    0 55769985 0.92727042\n10:      1999    1  4374266 0.07272958\n11:      2008    0 58588985 0.91636135\n12:      2008    1  5347567 0.08363865\n13:      2013    0 59729778 0.91100274\n14:      2013    1  5835094 0.08899726\n15:      2019    0 60469081 0.90272718\n16:      2019    1  6515809 0.09727282"
  },
  {
    "objectID": "pptS2.html#calculer-les-pourcentages---2",
    "href": "pptS2.html#calculer-les-pourcentages---2",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les pourcentages - 2",
    "text": "Calculer les pourcentages - 2\n\n\n\ntab_p &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) %&gt;% # Compte des effectifs pondérés\n  group_by(AN_RECENS) %&gt;% # Opération par année\n  mutate(p = n/sum(n)) %&gt;% # Part dans la population\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde qu'une ligne sur deux\n  select(-IMMI) # On enlève la colonne immigration\n\n\n\ntab_p\n\n   AN_RECENS       n          p\n1:      1968 3238284 0.06521626\n2:      1975 3887460 0.07390688\n3:      1982 4037036 0.07435290\n4:      1990 4222237 0.07269985\n5:      1999 4374266 0.07272958\n6:      2008 5347567 0.08363865\n7:      2013 5835094 0.08899726\n8:      2019 6515809 0.09727282"
  },
  {
    "objectID": "pptS2.html#construction-graphique",
    "href": "pptS2.html#construction-graphique",
    "title": "Powerpoint - Séance 2",
    "section": "Construction graphique",
    "text": "Construction graphique"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse quantitative - M2 Villes et environnements urbains",
    "section": "",
    "text": "Ce site est dédié au cours d’analyse quantitative du premier semestre du M2 Villes et environnements urbains. Les pages intitulées “Séance” reprennent dans un autre ordre l’introduction à R et au tidyverse de Julien Barnier. Elles doivent vous servir de documentation. Tout leur contenu n’aura pas été vu en cours et ne vous sera pas forcément utile, il faut néanmoins vous y référez pour faciliter l’écriture de votre code."
  },
  {
    "objectID": "Seance2.html",
    "href": "Seance2.html",
    "title": "Séance 2",
    "section": "",
    "text": "R a la particularité d’être un logiciel open-source et développé par la communauté. Ce n’est pas le cas d’autres options comme SAS, un logiciel payant qui a été pendant longtemps l’outil de travail des institutions de la statistique publique française. Il existe donc souvent plusieurs façons de faire une même opération, à partir du R de base si les fonctions adaptées existent ou grâce aux fonctions offertes par les différentes extensions. Ce TD présentera uniquement l’univers tidyverse pour son exhaustivité et l’existence d’une documentation en ligne très importante.\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\nlubridate (manipulation de dates)\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles.\n\n\ndplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type.\n\n\n\ndplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement.\n\n\n\nLa manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\nParfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions ifelse pour les cas les plus simples, ou case_when pour les cas plus complexes.\n\n\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n\n[1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nlibrary(questionr)\ndata(hdv2003)\nhdv2003$statut &lt;- ifelse(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60,\n    \"Homme de plus de 60 ans\",\n    \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Homme de plus de 60 ans \n                   1778                     222 \n\n\n\n\n\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Homme\" ~ \"Homme de plus de 60 ans\",\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Femme\" ~ \"Femme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Femme de plus de 60 ans Homme de plus de 60 ans \n                   1512                     266                     222 \n\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nWarning\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.\n\n\nPour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\nAutre Homme \n 1101   899 \n\n\nComme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" & age &gt; 60, cette deuxième condition n’est jamais testée, et on n’obtiendra donc jamais la valeur correspondante.\nPour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général.\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    TRUE ~ \"Autre\"\n)\n\n\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir la fin de la première séance.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante.\n\n\n\n\nQuand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\nUn élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows\n\n\n\n\n\n\nOn commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue."
  },
  {
    "objectID": "Seance2.html#manipuler-les-données-avec-dplyr",
    "href": "Seance2.html#manipuler-les-données-avec-dplyr",
    "title": "Séance 2",
    "section": "",
    "text": "dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type."
  },
  {
    "objectID": "Seance2.html#préparation",
    "href": "Seance2.html#préparation",
    "title": "Séance 2",
    "section": "",
    "text": "dplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement."
  },
  {
    "objectID": "Seance2.html#les-verbes-de-dplyr",
    "href": "Seance2.html#les-verbes-de-dplyr",
    "title": "Séance 2",
    "section": "",
    "text": "La manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\nParfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions ifelse pour les cas les plus simples, ou case_when pour les cas plus complexes.\n\n\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n\n[1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nlibrary(questionr)\ndata(hdv2003)\nhdv2003$statut &lt;- ifelse(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60,\n    \"Homme de plus de 60 ans\",\n    \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Homme de plus de 60 ans \n                   1778                     222 \n\n\n\n\n\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Homme\" ~ \"Homme de plus de 60 ans\",\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Femme\" ~ \"Femme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Femme de plus de 60 ans Homme de plus de 60 ans \n                   1512                     266                     222 \n\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nWarning\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.\n\n\nPour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\nAutre Homme \n 1101   899 \n\n\nComme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" & age &gt; 60, cette deuxième condition n’est jamais testée, et on n’obtiendra donc jamais la valeur correspondante.\nPour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général.\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    TRUE ~ \"Autre\"\n)\n\n\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir la fin de la première séance.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante."
  },
  {
    "objectID": "Seance2.html#sec-pipe",
    "href": "Seance2.html#sec-pipe",
    "title": "Séance 2",
    "section": "",
    "text": "Quand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))"
  },
  {
    "objectID": "Seance2.html#opérations-groupées",
    "href": "Seance2.html#opérations-groupées",
    "title": "Séance 2",
    "section": "",
    "text": "Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows"
  },
  {
    "objectID": "Seance2.html#exercices",
    "href": "Seance2.html#exercices",
    "title": "Séance 2",
    "section": "",
    "text": "On commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue."
  },
  {
    "objectID": "Seance2.html#initialisation",
    "href": "Seance2.html#initialisation",
    "title": "Séance 2",
    "section": "Initialisation",
    "text": "Initialisation\nUn graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction :\n\nggplot(data = rp)\n\n\n\n## Ou, équivalent\nggplot(rp)\n\n\n\n\nOn a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. Ces éléments sont appelés des geom, et on les ajoute à l’objet graphique de base avec l’opérateur +.\nUn des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante :\n\nggplot(rp) +\n    geom_histogram()\n\nReste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter sur l’axe des x (l’axe horizontal). Ainsi, si on souhaite représenter la distribution des communes du jeu de données selon le pourcentage de cadres dans leur population active (variable cadres), on pourra faire :\n\nggplot(rp) +\n    geom_histogram(aes(x = cadres))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nSi on veut représenter une autre variable, il suffit de changer la valeur de x :\n\nggplot(rp) +\n    geom_histogram(aes(x = ouvr))\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand on spécifie une variable, inutile d’indiquer le nom du tableau de données sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué avec le paramètre data. On peut donc se contenter de ouvr.\n\n\nCertains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points, on peut le faire en ajoutant un geom_point. On doit alors indiquer à la fois la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points, il faut donc passer ces deux arguments à aes() :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nOn peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"darkgreen\", size = 3, alpha = 0.3\n    )\n\n\n\n\nOn notera que dans ce cas les arguments sont dans la fonction geom mais à l’extérieur du aes(). Plus d’explications sur ce point dans quelques instants."
  },
  {
    "objectID": "Seance2.html#exemples-de-geom",
    "href": "Seance2.html#exemples-de-geom",
    "title": "Séance 2",
    "section": "Exemples de geom",
    "text": "Exemples de geom\nIl existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre les geom_histogram et geom_point que l’on vient de voir, on pourra noter les geom suivants.\n\ngeom_boxplot\ngeom_boxplot permet de représenter des boîtes à moustaches. On lui passe en y la variable numérique dont on veut étudier la répartition, et en x la variable qualitative contenant les classes qu’on souhaite comparer. Ainsi, si on veut comparer la répartition du pourcentage de maisons en fonction du département de la commune, on pourra faire :\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison))\n\n\n\n\n\n\ngeom_violin\ngeom_violin est très semblable à geom_boxplot, mais utilise des graphes en violon à la place des boîtes à moustache.\n\nggplot(rp) +\n    geom_violin(aes(x = departement, y = maison))\n\n\n\n\nLes graphes en violon peuvent donner une lecture plus fine des différences de distribution selon les classes. Comme pour les graphiques de densité, on peut faire varier le niveau de “détail” de la représentation en utilisant l’argument bw (bande passante).\n\nggplot(rp) +\n    geom_violin(\n        aes(x = departement, y = maison),\n        bw = 2\n    )\n\n\n\n\n\n\ngeom_bar et geom_col\ngeom_bar permet de produire un graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité.\nPar exemple, si on veut afficher le nombre de communes de notre jeu de données pour chaque département :\n\nggplot(rp) +\n    geom_bar(aes(x = departement))\n\n\n\n\nSi on préfère avoir un graphique en barres horizontales, il suffit de passer la variable comme attribut y plutôt que x.\n\nggplot(rp) +\n    geom_bar(aes(y = departement))\n\n\n\n\nUne autre possibilité est d’utiliser coord_flip(), qui permet d’intervertir l’axe horizontal et l’axe vertical.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    coord_flip()\n\n\n\n\nÀ noter que coord_flip() peut s’appliquer à n’importe quel graphique ggplot2.\nParfois, on a déjà calculé le tri à plat de la variable à représenter. Dans ce cas on souhaite représenter les effectifs directement, sans les calculer.\nC’est le cas par exemple si on a les données sous la forme suivante dans un tableau de données nommé tab :\n\ntab\n\n       departement   n\n1 Bouches-du-Rhône 115\n2   Hauts-de-Seine  35\n3           Lozère   8\n4             Oise  76\n5            Rhône 132\n\n\nDans ce cas on peut utiliser geom_col. Il faut alors spécifier, en plus de l’argument x, un argument y indiquant la variable contenant la hauteur des barres. Dans notre exemple, il s’agit de la variable n.\n\nggplot(tab) +\n    geom_col(aes(x = departement, y = n))\n\n\n\n\nQue ce soit pour geom_bar ou geom_col, on peut modifier l’apparence du graphique en passant des arguments supplémentaires comme fill ou width.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement),\n        fill = \"darkblue\", width = .5\n    )\n\n\n\n\n\n\ngeom_text\ngeom_text permet d’afficher des étiquettes de texte. On doit lui fournir trois paramètres dans aes : x et y pour la position des étiquettes, et label pour leur texte.\nPar exemple, si on souhaite représenter le nuage croisant la part des diplômés du supérieur et la part de cadres, mais en affichant le nom de la commune (variable commune) plutôt qu’un simple point, on peut faire :\n\nggplot(rp) +\n    geom_text(\n        aes(x = dipl_sup, y = cadres, label = commune)\n    )\n\n\n\n\nOn peut personnaliser l’apparence et la position du texte avec des arguments comme size, color, etc.\n\nggplot(rp) +\n    geom_text(\n        aes(x = dipl_sup, y = cadres, label = commune),\n        color = \"darkred\", size = 2\n    )\n\n\n\n\n\n\ngeom_label\ngeom_label est identique à geom_text, mais avec une présentation un peu différente.\n\nggplot(rp) +\n    geom_label(aes(x = dipl_sup, y = cadres, label = commune))\n\n\n\n\n\n\ngeom_density\ngeom_density permet d’afficher l’estimation de densité d’une variable numérique. Son usage est similaire à celui de geom_histogram.\nAinsi, si on veut afficher la densité de la répartition de la part des cadres dans les communes de notre jeu de données :\n\nggplot(rp) +\n    geom_density(aes(x = cadres))\n\n\n\n\nOn peut utiliser différents arguments pour ajuster le calcul de l’estimation de densité, parmi lesquels kernel et bw (voir la page d’aide de la fonction density pour plus de détails). bw (abbréviation de bandwidth, bande passante) permet de régler la “finesse” de l’estimation de densité, un peu comme le choix du nombre de classes dans un histogramme :\n\nggplot(rp) +\n    geom_density(aes(x = cadres), bw = 1)\n\n\n\n\n\n\ngeom_line\ngeom_line trace des lignes connectant les différentes observations entre elles. Il est notamment utilisé pour la représentation de séries temporelles. On passe à geom_line deux paramètres : x et y. Les observations sont alors connectées selon l’ordre des valeurs passées en x.\nComme il n’y a pas de données adaptées pour ce type de représentation dans notre jeu de données d’exemple, on va utiliser ici le jeu de données economics inclus dans ggplot2 et représenter l’évolution du taux de chômage aux États-Unis (variable unemploy) dans le temps (variable date) :\n\ndata(\"economics\")\neconomics\n\n# A tibble: 574 × 6\n   date         pce    pop psavert uempmed unemploy\n   &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n 1 1967-07-01  507. 198712    12.6     4.5     2944\n 2 1967-08-01  510. 198911    12.6     4.7     2945\n 3 1967-09-01  516. 199113    11.9     4.6     2958\n 4 1967-10-01  512. 199311    12.9     4.9     3143\n 5 1967-11-01  517. 199498    12.8     4.7     3066\n 6 1967-12-01  525. 199657    11.8     4.8     3018\n 7 1968-01-01  531. 199808    11.7     5.1     2878\n 8 1968-02-01  534. 199920    12.3     4.5     3001\n 9 1968-03-01  544. 200056    11.7     4.1     2877\n10 1968-04-01  544  200208    12.3     4.6     2709\n# ℹ 564 more rows\n\n\n\nggplot(economics) +\n    geom_line(aes(x = date, y = unemploy))"
  },
  {
    "objectID": "Seance2.html#mappages",
    "href": "Seance2.html#mappages",
    "title": "Séance 2",
    "section": "Mappages",
    "text": "Mappages\nUn mappage, dans ggplot2, est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données.\nCes mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic).\n\nExemples de mappages\nOn a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) dépend de la valeur des variables passées comme arguments x et y dans aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres)\n    )\n\n\n\n\nMais on peut ajouter d’autres mappages. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable. Ainsi, on peut vouloir colorer les points selon le département de la commune correspondante.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\nOn peut aussi faire varier la taille des points avec size. Ici, la taille dépend de la population totale de la commune :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)\n    )\n\n\n\n\nOn peut même associer la transparence des points à une variable avec alpha :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)\n    )\n\n\n\n\nChaque geom possède sa propre liste de mappages.\n\n\naes() or not aes() ?\nComme on l’a déjà vu, parfois on souhaite changer un attribut sans le relier à une variable : c’est le cas par exemple si on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"red\"\n    )\n\n\n\n\nPar contre, si on veut faire varier la couleur en fonction des valeurs prises par une variable, on réalise un mappage, et on doit donc placer l’attribut color à l’intérieur de aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\nOn peut mélanger attributs liés à une variable (mappage, donc dans aes()) et attributs constants (donc à l’extérieur). Dans l’exemple suivant, la taille varie en fonction de la variable pop_tot, mais la couleur est constante pour tous les points.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, size = pop_tot),\n        color = \"royalblue\"\n    )\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLa règle est donc simple mais très importante :\nSi on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit en-dehors de la fonction aes().\n\n\n\n\ngeom_bar et position\nUn des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une deuxième variable :\n\nggplot(rp) +\n    geom_bar(aes(x = departement, fill = pop_cl))\n\n\n\n\nL’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut l’argument vaut position = \"stack\" et elles sont donc “empilées”. Mais on peut préciser position = \"dodge\" pour les mettre côte à côte.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"dodge\"\n    )\n\n\n\n\nOu encore position = \"fill\" pour représenter non plus des effectifs, mais des proportions.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    )\n\n\n\n\nLà encore, on peut utiliser coord_flip() si on souhaite une visualisation avec des barres horizontales.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    ) +\n    coord_flip()"
  },
  {
    "objectID": "Seance2.html#représentation-de-plusieurs-geom",
    "href": "Seance2.html#représentation-de-plusieurs-geom",
    "title": "Séance 2",
    "section": "Représentation de plusieurs geom",
    "text": "Représentation de plusieurs geom\nOn peut représenter plusieurs geom simultanément sur un même graphique, il suffit de les ajouter à tour de rôle avec l’opérateur +.\nPar exemple, on peut superposer la position des points au-dessus d’un boxplot. On va pour cela ajouter un geom_point après avoir ajouté notre geom_boxplot.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_point(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand une commande ggplot2 devient longue, il peut être plus lisible de la répartir sur plusieurs lignes. Dans ce cas, il faut penser à placer l’opérateur + en fin de ligne, afin que R comprenne que la commande n’est pas complète et qu’il prenne en compte la suite.\n\n\nPour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_jitter(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\nPour simplifier un peu le code, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages).\n\nggplot(rp, aes(x = departement, y = maison)) +\n    geom_boxplot() +\n    geom_jitter(color = \"red\", alpha = 0.2)\n\n\n\n\nAutre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nEt on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_density2d(color = \"red\") +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nPlusieurs sources de données\nOn peut associer à différents geom des sources de données différentes. Supposons qu’on souhaite afficher sur un nuage de points les noms des communes de plus de 50000 habitants. On commencer par créer un tableau de données contenant uniquement ces communes à l’aide de la fonction filter.\n\ncom50 &lt;- filter(rp, pop_tot &gt;= 50000)\n\nOn fait ensuite le nuage de points comme précédemment :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2)\n\n\n\n\nPour superposer les noms de communes de plus de 50 000 habitants, on peut ajouter un geom_text, mais en spécifiant que les données proviennent du nouveau tableau com50 et non de notre tableau initial rp. On le fait en passant un argument data spécifique à geom_text :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_text(\n        data = com50, aes(label = commune),\n        color = \"red\", size = 3\n    )\n\n\n\n\nAinsi, on obtient un graphique avec deux geom superposés, mais dont les données proviennent de deux tableaux différents."
  },
  {
    "objectID": "Seance2.html#faceting",
    "href": "Seance2.html#faceting",
    "title": "Séance 2",
    "section": "Faceting",
    "text": "Faceting\nLe faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives.\nPar exemple, on a vu qu’on peut représenter l’histogramme du pourcentage de cadres dans nos communes avec le code suivant :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres))\n\n\n\n\nOn souhaite comparer cette distribution de la part des cadres selon le département, et donc faire un histogramme pour chacun de ces départements. C’est ce que permettent les fonctions facet_wrap et facet_grid.\nfacet_wrap prend un paramètre de la forme vars(variable), où variable est le nom de la variable en fonction de laquelle on souhaite faire les différents graphiques. Ceux-ci sont alors affichés les uns à côté des autres et répartis automatiquement dans la page.\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_wrap(vars(departement))\n\n\n\n\nPour facet_grid, les graphiques sont disposés selon une grille. La fonction prend alors deux arguments, rows et cols, auxquels on passe les variables à afficher en ligne ou en colonne via la fonction vars().\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(rows = vars(departement))\n\n\n\n\nUn des intérêts du faceting dans ggplot2 est que tous les graphiques générés ont les mêmes échelles, ce qui permet une comparaison directe.\nEnfin, notons qu’on peut même faire du faceting sur plusieurs variables à la fois. On peut par exemple faire des histogrammes de la répartition de la part des cadres pour chaque croisement des variables departement et pop_cl :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(\n        rows = vars(departement), cols = vars(pop_cl)\n    )\n\n\n\n\nL’histogramme en haut à gauche représente la répartition du pourcentage de cadres parmi les communes de 2000 à 3000 habitants dans les Bouches-du-Rhône, etc."
  },
  {
    "objectID": "Seance2.html#scales",
    "href": "Seance2.html#scales",
    "title": "Séance 2",
    "section": "Scales",
    "text": "Scales\nOn a vu qu’avec ggplot2 on définit des mappages entre des attributs graphiques (position, taille, couleur, etc.) et des variables d’un tableau de données. Ces mappages sont définis, pour chaque geom, via la fonction aes().\nLes scales dans ggplot2 permettent de modifier la manière dont un attribut graphique va être relié aux valeurs d’une variable, et dont la légende correspondante va être affichée. Par exemple, pour l’attribut color, on pourra définir la palette de couleur utilisée. Pour size, les tailles minimales et maximales, etc.\nPour modifier une scale existante, on ajoute un nouvel élément à notre objet ggplot2 avec l’opérateur +. Cet élément prend la forme scale_&lt;attribut&gt;_&lt;type&gt;.\nVoyons tout de suite quelques exemples.\n\nscale_size\nSi on souhaite modifier les tailles minimales et maximales des objets quand on a effectué un mappage de type size, on peut utiliser la fonction scale_size et son argument range.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(range = c(0, 20))\n\n\n\n\nÀ comparer par exemple à :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(range = c(2, 8))\n\n\n\n\nOn peut ajouter d’autres paramètres à scale_size. Le premier argument est toujours le titre donné à la légende.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(\n        \"Population\",\n        range = c(0, 15)\n    )\n\n\n\n\nOn peut aussi définir manuellement les éléments de légende représentés.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(\n        \"Population\",\n        range = c(0, 15),\n        breaks = c(1000, 5000, 10000, 50000)\n    )\n\n\n\n\n\n\nscale_x, scale_y\nLes scales scale_x_&lt;type&gt; et scale_y_&lt;type&gt; modifient les axes x et y du graphique.\nscale_x_continuous et scale_y_continuous s’appliquent lorsque la variable x ou y est numérique (quantitative).\nC’est le cas de notre nuage de points croisant part de cadres et part de diplômés du supérieur.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nComme on représente des pourcentages, on peut vouloir forcer les axes x et y à s’étendre des valeurs 0 à 100. On peut le faire en ajoutant un élément scale_x_continuous et un élément scale_y_continuous, et en utilisant leur argument limits.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_continuous(limits = c(0, 100)) +\n    scale_y_continuous(limits = c(0, 100))\n\n\n\n\nLà aussi, on peut modifier les étiquettes des axes en indiquant une chaîne de caractères en premier argument.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_continuous(\"Part des diplômés du supérieur (%)\", limits = c(0, 100)) +\n    scale_y_continuous(\"Part des cadres (%)\", limits = c(0, 100))\n\n\n\n\nOn peut utiliser scale_x_log10 et scale_y_log10 pour passer un axe à une échelle logarithmique.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_log10(\"Diplômés du supérieur\")\n\n\n\n\nscale_x_discrete et scale_y_discrete s’appliquent lorsque l’axe correspond à une variable discrète (qualitative). C’est le cas par exemple de l’axe des x dans un diagramme en barres.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    scale_x_discrete(\"Département\")\n\n\n\n\nL’argument limits de scale_x_discrete permet d’indiquer quelles valeurs sont affichées et dans quel ordre.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    scale_x_discrete(\"Département\", limits = c(\"Oise\", \"Lozère\", \"Rhône\"))\n\nWarning: Removed 150 rows containing non-finite values (`stat_count()`).\n\n\n\n\n\n\n\nscale_color, scale_fill\nCes scales permettent, entre autre, de modifier les palettes de couleur utilisées pour le dessin (color) ou le remplissage (fill) des éléments graphiques. Dans ce qui suit, pour chaque fonction scale_color présentée il existe une fonction scale_fill équivalente et avec en général les mêmes arguments.\n\nVariables quantitatives\nLe graphique suivant colore les points selon la valeur d’une variable numérique quantitative (ici la part de chômeurs) :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom))\n\n\n\n\nOn peut modifier les couleurs utilisées avec les arguments low et high de la fonction scale_color_gradient. Ici on souhaite que la valeur la plus faible soit blanche, et la plus élevée rouge :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_gradient(\"Taux de chômage\", low = \"white\", high = \"red\")\n\n\n\n\nOn peut aussi utiliser des palettes prédéfinies. L’une des plus populaires est la palette viridis, accessible en utilisant scale_color_viridis_c :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_viridis_c(\"Taux de chômage\")\n\n\n\n\nviridis propose également trois autres palettes, magma, inferno et plasma, accessibles via l’argument option :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_viridis_c(\"Taux de chômage\", option = \"plasma\")\n\n\n\n\nOn peut aussi utiliser scale_color_distiller, qui transforme une des palettes pour variable qualitative de scale_color_brewer en palette continue pour variable numérique :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_distiller(\"Taux de chômage\", palette = \"Spectral\")\n\n\n\n\nLa liste des palettes de scale_color_brewer est indiquée en fin de section suivante.\n\n\nVariables qualitatives\nSi on a fait un mappage avec une variable discrète (qualitative), comme ici avec le département :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement))\n\n\n\n\nUne première possibilité est de modifier la palette manuellement avec scale_color_manual et son argument values :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n    scale_color_manual(\n        \"Département\",\n        values = c(\"red\", \"#FFDD45\", rgb(0.1, 0.2, 0.6), \"darkgreen\", \"grey80\")\n    )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nL’exemple précédent montre plusieurs manières de définir manuellement des couleurs dans R :\n\nPar code hexadécimal : \"#FFDD45\"\nEn utilisant la fonction rgb et en spécifiant les composantes rouge, vert, bleu par des nombres entre 0 et 1 (et optionnellement une quatrième composante d’opacité, toujours entre 0 et 1) : rgb(0.1,0.2,0.6)\nEn donnant un nom de couleur : \"red\", \"darkgreen\"\n\nLa liste complète des noms de couleurs connus par R peut être obtenu avec la fonction colors(). Vous pouvez aussi retrouver en ligne la liste des couleurs et leur nom (PDF).\n\n\nIl est cependant souvent plus pertinent d’utiliser des palettes prédéfinies. Celles du site Colorbrewer, initialement prévues pour la cartographie, permettent une bonne lisibilité, et peuvent être adaptées pour certains types de daltonisme.\nCes palettes s’utilisent via la fonction scale_color_brewer, en passant le nom de la palette via l’argument palette. Par exemple, si on veut utiliser la palette Set1 :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n    scale_color_brewer(\"Département\", palette = \"Set1\")\n\n\n\n\nLe graphique suivant, accessible via la fonction display.brewer.all(), montre la liste de toutes les palettes disponibles via scale_color_brewer. Elles sont réparties en trois familles : les palettes séquentielles (pour une variable quantitative), les palettes qualitatives, et les palettes divergentes (typiquement pour une variable quantitative avec une valeur de référence, souvent 0, et deux palettes continues distinctes pour les valeurs inférieures et pour les valeurs supérieures).\n\nRColorBrewer::display.brewer.all()\n\n\n\n\n\n\n\n\n\nIl existe d’autres méthodes pour définir les couleurs : pour plus d’informations on pourra se reporter à l’article de la documentation officielle sur ce sujet."
  },
  {
    "objectID": "Seance2.html#thèmes",
    "href": "Seance2.html#thèmes",
    "title": "Séance 2",
    "section": "Thèmes",
    "text": "Thèmes\nLes thèmes permettent de contrôler l’affichage de tous les éléments du graphique qui ne sont pas reliés aux données : titres, grilles, fonds, etc.\nIl existe un certain nombre de thèmes préexistants, par exemple le thème theme_bw :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme_bw()\n\n\n\n\nOu le thème theme_minimal :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme_minimal()\n\n\n\n\nOn peut cependant modifier manuellement les différents éléments. Par exemple, les fonctions ggtitle, xlab et ylab permettent d’ajouter ou de modifier le titre du graphique, ainsi que les étiquettes des axes x et y :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    ggtitle(\"Un bien bel histogramme\") +\n    xlab(\"Pourcentage de cadres\") +\n    ylab(\"Effectif\")\n\n\n\n\nLes éléments personnalisables étant nombreux, un bon moyen de se familiariser avec tous les arguments est sans doute l’addin RStudio ggThemeAssist. Pour l’utiliser il suffit d’installer le package du même nom, de sélectionner dans son script RStudio le code correspondant à un graphique ggplot2, puis d’aller dans le menu Addins et choisir ggplot Theme Assistant. Une interface graphique s’affiche alors permettant de modifier les différents éléments. Si on clique sur Done, le code sélectionné dans le script est alors automatiquement mis à jour pour correspondre aux modifications effectuées.\nCe qui permet d’obtenir très facilement des résultats extrêmement moches :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme(\n        panel.grid.major = element_line(\n            colour = \"dodgerblue\",\n            size = 0.5, linetype = \"dotdash\"\n        ), axis.title = element_text(\n            family = \"serif\",\n            size = 18, face = \"italic\", colour = \"white\"\n        ),\n        axis.text = element_text(\n            family = \"serif\",\n            size = 15, face = \"bold\"\n        ), axis.text.x = element_text(family = \"mono\"),\n        plot.title = element_text(family = \"serif\"),\n        legend.text = element_text(family = \"serif\"),\n        legend.title = element_text(family = \"serif\"),\n        panel.background = element_rect(fill = \"coral\"),\n        plot.background = element_rect(fill = \"blueviolet\")\n    )"
  },
  {
    "objectID": "Seance2.html#ladd-in-esquisse",
    "href": "Seance2.html#ladd-in-esquisse",
    "title": "Séance 2",
    "section": "L’add-in esquisse",
    "text": "L’add-in esquisse\nesquisse est un package développé notamment par Victor Perrier de dreamRs et qui fournit une interface graphique pour la construction de graphiques avec ggplot2.\nPour l’utiliser, il faut évidemment préalablement installer l’extension :\n\ninstall.packages(\"esquisse\")\n\nPour lancer l’interface, ouvrez le menu Addins dans la barre d’outils de RStudio, et cliquez sur ‘ggplot2’ builder3.\n\nUne fenêtre s’ouvre : la première étape consiste à choisir un data frame de votre environnement, et éventuellement à ne sélectionner que certaines de ses variables.\n Une fois le choix effectué, cliquez sur Validate imported data.\nL’interface principale s’affiche alors. La liste des variables du data frame apparaît en haut, et vous pouvez les faire glisser dans les zones X, Y, Fill, Color, Size et Facet pour créer des mappages. Le graphique se met automatiquement à jour.\n\nPar défaut, esquisse sélectionne le type de graphique le plus approprié selon la nature de vos variables. Mais vous pouvez choisir un autre type de graphique à l’aide de l’icône en haut à gauche, parmi onze disponibles (dont Auto):\n.\nEnfin, une série de menus en bas de l’interface vous permet de personnaliser les titres, les annotations (labels), la présentation ou de filtrer des valeurs de vos variables.\nQuand vous avez généré un graphique que vous souhaitez conserver, ouvrez le menu Export & code :\n\nVous y trouverez le code R correspondant au graphique actuellement affiché. Vous pouvez dès lors le copier pour le coller dans votre script, ou cliquer sur Insert code in script pour l’insérer directement dans votre script à l’endroit où se trouve votre curseur.\nesquisse ne propose pas (encore) tous les geom ou toutes les possibilités de ggplot2, mais ça peut être un outil très utile et pratique pour une exploration rapide de données ou lorsqu’on est un peu perdu dans la syntaxe et les fonctions de l’extension.\nPour plus d’informations, vous pouvez vous référer à la page du projet sur GitHub (en anglais)."
  },
  {
    "objectID": "Seance2.html#ressources",
    "href": "Seance2.html#ressources",
    "title": "Séance 2",
    "section": "Ressources",
    "text": "Ressources\nLa documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne.\nUne “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Cheatsheets &gt; Data visualization with ggplot2) ou en ligne.\nLes parties Data visualisation et Graphics for communication de l’ouvrage en ligne R for data science, de Hadley Wickham, sont une très bonne introduction à ggplot2.\nPlusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, toujours de Hadley Wickham, et le R Graphics Cookbook de Winston Chang.\nLe site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes.\nEnfin, si ggplot2 présente déjà un très grand nombre de fonctionnalités, il existe aussi un système d’extensions permettant d’ajouter des geom, des thèmes, etc. Le site ggplot2 extensions est une très bonne ressource pour les parcourir et les découvrir, notamment grâce à sa galerie."
  },
  {
    "objectID": "Seance2.html#exercices-1",
    "href": "Seance2.html#exercices-1",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\nPour les exercices qui suivent, on commence par charger les extensions nécessaires et les données du jeu de données rp2018. On crée alors un objet rp69 comprenant uniquement les communes du Rhône et de la Loire.\n\nlibrary(tidyverse)\nlibrary(questionr)\ndata(rp2018)\n\nrp69 &lt;- filter(rp2018, departement %in% c(\"Rhône\", \"Loire\"))\n\nExercice 1\nFaire un nuage de points croisant le pourcentage de sans diplôme (dipl_aucun) et le pourcentage d’ouvriers (ouvr).\nExercice 2\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers, avec les points en rouge et de transparence 0.2.\nExercice 3\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches.\nExercice 4\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes sous la forme d’un diagramme en bâtons.\nExercice 5\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Faire varier la couleur selon le département (departement).\nSur le même graphique, faire varier la taille des points selon la population totale de la commune (pop_tot).\nEnfin, toujours sur le même graphique, rendre les points transparents en plaçant leur opacité à 0.5.\nExercice 6\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches. Faire varier la couleur de remplissage (attribut fill) selon le département.\nExercice 7\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes (variable pop_cl) sous forme de diagramme en bâtons empilés, avec une couleur différente selon le département.\nFaire varier la valeur du paramètre position pour afficher les barres les unes à côté des autres.\nChanger à nouveau la valeur du paramètre position pour représenter les proportions de communes de chaque département pour chaque catégorie de taille.\nExercice 8\nFaire un nuage de points représentant en abscisse le pourcentage de cadres (cadres) et en ordonnée le pourcentage de diplômés du supérieur (dipl_sup). Représenter ce nuage par deux graphiques différents selon le département en utilisant facet_grid.\nSur le même graphique, faire varier la taille des points selon la population totale de la communes (variable pop_tot) et rendre les points transparents.\nExercice 9\nFaire le nuage de points croisant pourcentage de chômeurs (chom) et pourcentage de sans diplôme. Y ajouter les noms des communes correspondant (variable commune), en rouge et en taille 2.5 :\nExercice 10\nDans le graphique précédent, n’afficher que le nom des communes ayant plus de 15% de chômage."
  },
  {
    "objectID": "Seance2.html#footnotes",
    "href": "Seance2.html#footnotes",
    "title": "Séance 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nVous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎\nIl est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎\nVous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎"
  },
  {
    "objectID": "rappel_S1S2.html",
    "href": "rappel_S1S2.html",
    "title": "Rappel avant la troisième séance",
    "section": "",
    "text": "La deuxième séance a été consacrée au recodage et à la visualisation de données. Nous sommes revenu.es sur les graphiques présentés par François Héran pour reconstituer le passage des données brutes, le recensement, aux représentations graphiques. Voici un résumé des éléments avec lesquels il faut être familier.e pour la troisième séance."
  },
  {
    "objectID": "rappel_S1S2.html#les-bases-de-la-première-séance",
    "href": "rappel_S1S2.html#les-bases-de-la-première-séance",
    "title": "Rappel avant la troisième séance",
    "section": "Les bases de la première séance",
    "text": "Les bases de la première séance\nL’essentiel de l’analyse des données repose sur la transformation de tableaux de données. Les lignes représentent des individus statistiques (qui peuvent être des personnes, des ménages, ou d’autres unités enquêtées). Les colonnes sont des variables numériques ou catégorielles.\nOn prend ici l’exemple du recensement de la population restreint à la ville de Lyon en 2009 et 2019. Lancer le bloc de code suivant sans se soucier du code ni du message retourné par R.\n\n# Ne pas tenir compte de ces lignes, c'est le chargement des données\nrp &lt;- aws.s3::s3read_using(FUN = data.table::fread,\n                           object = \"/diffusion/RP_LYON_2009_2019.csv\",\n                           bucket = \"aubinpoissonnier\",\n                           opts = list(\"region\" = \"\"))\n\nOn appelle les colonnes des tableaux de données des vecteurs car ce sont des suites de valeurs (la valeur de la variable pour l’individu 1, pour l’individu 2 etc). Une fonction s’écrit sous la forme nom_fonction(). On peut utiliser l’onglet “Help” pour connaître les différents arguments ou paramètres d’une fonction. On sépare les arguments des fonctions par des virgules s’il y en a plusieurs. Il faut toujours veiller à fermer les parenthèses. La fonction str pour structure résume toutes les colonnes du tableau. Elle a un seul argument, l’objet qu’on veut décrire (ici le tableau). La fonction head renvoie les premières lignes du tableau, elle peut prendre un deuxième argument pour choisir le nombre de lignes.\n\n# Ici, rp correspond au tableau de données du rencesement\nstr(rp)\n\nClasses 'data.table' and 'data.frame':  377833 obs. of  7 variables:\n $ annee : int  2019 2019 2019 2019 2019 2019 2019 2019 2019 2019 ...\n $ ARM   : int  69388 69388 69388 69384 69383 69388 69384 69383 69383 69383 ...\n $ IPONDI: num  1.178 1.178 1.178 2.965 0.956 ...\n $ IMMI  : int  2 2 2 1 2 2 2 2 2 2 ...\n $ SEXE  : int  1 2 1 2 1 1 2 1 2 1 ...\n $ CS1   : int  8 3 8 8 8 4 5 8 4 6 ...\n $ AGEREV: int  14 43 11 85 23 28 50 23 23 21 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n# Deux arguments indiqués de manière implicite\nhead(rp, 10)\n\n    annee   ARM    IPONDI IMMI SEXE CS1 AGEREV\n 1:  2019 69388 1.1778303    2    1   8     14\n 2:  2019 69388 1.1778303    2    2   3     43\n 3:  2019 69388 1.1778303    2    1   8     11\n 4:  2019 69384 2.9651895    1    2   8     85\n 5:  2019 69383 0.9564125    2    1   8     23\n 6:  2019 69388 1.0714436    2    1   4     28\n 7:  2019 69384 2.6176763    2    2   5     50\n 8:  2019 69383 3.0192726    2    1   8     23\n 9:  2019 69383 3.0192726    2    2   4     23\n10:  2019 69383 2.9490264    2    1   6     21\n\n# Ce qui est équivalent à la manière explicite\n# x = correspond à l'argument \"objet sur lequel j'applique la fonction\"\n# n = correspond à l'argument \"nombre de lignes à afficher\"\nhead(x = rp, n = 10)\n\n    annee   ARM    IPONDI IMMI SEXE CS1 AGEREV\n 1:  2019 69388 1.1778303    2    1   8     14\n 2:  2019 69388 1.1778303    2    2   3     43\n 3:  2019 69388 1.1778303    2    1   8     11\n 4:  2019 69384 2.9651895    1    2   8     85\n 5:  2019 69383 0.9564125    2    1   8     23\n 6:  2019 69388 1.0714436    2    1   4     28\n 7:  2019 69384 2.6176763    2    2   5     50\n 8:  2019 69383 3.0192726    2    1   8     23\n 9:  2019 69383 3.0192726    2    2   4     23\n10:  2019 69383 2.9490264    2    1   6     21\n\n\nIci toutes les vecteurs/colonnes sont de type numérique. Il sera possible de modifier les colonnes qui devraient être des facteurs car ce sont des variables catégorielles : la variable IMMI devrait par exemple être une variable catégorielle qui prend deux modalités, “Immigré.e” et “Pas immigré.e”.\nLa fonction table permet de faire un tri croisé sur une variable. On remarque que les données de 2009 et 2019 sont regroupées dans un même tableau. C’est ce qui permettra une comparaison temporelle mais on verra comment en tenir compte par la suite pour ne pas mélanger les données des deux enquêtes.\n\n# L'opérateur $ permet d'accéder à une colonne précise grâce au nom.\n# En faisant un tri croisé sur $annee, je compte le nombre d'individus recensé.es\n# en 2009 et en 2019. \ntable(rp$annee)\n\n\n  2009   2019 \n182070 195763 \n\n# Il y 182070 lignes qui ont la valeur 2009, 182070 ont donc été personnes recensées\n# pour le recensement de 2009\n\nL’essentiel du recodage s’opère avec des instructions logiques simples (égal, différent, inférieur ou supérieur à) que l’on peut combiner sur une variable (être cadre ou profession intermédiaire) ou plusieurs variables (être cadre et avoir plus de 60 ans).\n\n## Opérateur égal\n# Pour du numérique\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n# Pour du factoriel ou du texte\n\"Jaune\" == \"Jaune\"\n\n[1] TRUE\n\n\"Jaune\" == \"Vert\"\n\n[1] FALSE\n\n# Opérateur différent\n1 != 1\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n# Inférieur ou supérieur\n1 &gt; 2\n\n[1] FALSE\n\n1 &lt; 2\n\n[1] TRUE\n\n# Compris dans un ensemble de valeurs\n1 %in% c(1, 2, 3) # c(1, 2, 3) est un vecteur créé par la fonction c(). Il contient les valeur de 1, 2, 3\n\n[1] TRUE\n\n1 %in% c(2, 3, 4)\n\n[1] FALSE\n\n\"Jaune\" %in% c(\"Jaune\", \"Vert\")\n\n[1] TRUE\n\n\"Jaune\" %in% c(\"Rouge\", \"Bleu\")\n\n[1] FALSE\n\n# Cumul des conditions\n# Opérateur et (&) : 1 est-il inférieur à 2 et à 3 ?\n1 &lt; 2 & # On revient à la ligne pour que ça soit plus lisible\n  1 &lt; 3\n\n[1] TRUE\n\n# 1 est-il inférieur à 2 et supérieur à 2 ?\n1 &lt; 2 &\n  1 &gt; 2\n\n[1] FALSE"
  },
  {
    "objectID": "rappel_S1S2.html#lintroduction-au-recodage-et-à-la-visualisation-de-données",
    "href": "rappel_S1S2.html#lintroduction-au-recodage-et-à-la-visualisation-de-données",
    "title": "Rappel avant la troisième séance",
    "section": "L’introduction au recodage et à la visualisation de données",
    "text": "L’introduction au recodage et à la visualisation de données\n\nLe recodage\nIl existe plusieurs façons de recoder sur R. On utilisera uniquement le recodage qui utilise les opérateurs logiques pour se concentrer sur deux fonctions polyvalentes, ifelse et case_when.\nLa fonction ifelse permet de faire une action sous condition : si l’âge est supérieur à 18, donne la valeur “majeur.e”, sinon donne la valeur “mineur.e”. case_when étend ce fonctionnement à plus d’une possibilité : si l’âge est supérieur à 18 donne “majeur.e”, si l’âge est compris entre 18 et 64 donne “adulte”, si l’âge est supérieur à 64 donne “senior”.\nIl faut associer ces fonctions à d’autres fonctions qui disent à R quoi faire avec le tableau. La fonction mutate permet de créer une nouvelle colonne. On pourra dire à R : crée une nouvelle colonne (mutate) à partir d’un test sur la valeur initiale de la variable (ifelse).\nVoici le code pour créer une variable binaire mineur.e/majeur.e.\n\n# Le package à charger pour faire les recodages\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Voici deux versions du ecodage de l'âge des personnes recensées, soit la variable AGEREV. La première est lisible, la deuxième est commentée ligne par ligne.\n\n# Version plus lisible sans les commentaires\nmutate(\n  rp,\n  age_rec = \n    ifelse(\n      AGEREV &gt; 17,\n      \"Majeur.e\",\n      \"Mineur.e\"\n    )\n)\n\n        annee   ARM    IPONDI IMMI SEXE CS1 AGEREV  age_rec\n     1:  2019 69388 1.1778303    2    1   8     14 Mineur.e\n     2:  2019 69388 1.1778303    2    2   3     43 Majeur.e\n     3:  2019 69388 1.1778303    2    1   8     11 Mineur.e\n     4:  2019 69384 2.9651895    1    2   8     85 Majeur.e\n     5:  2019 69383 0.9564125    2    1   8     23 Majeur.e\n    ---                                                    \n377829:  2009 69381 0.9999903    1    1   5     31 Majeur.e\n377830:  2009 69381 0.9999903    2    1   6     43 Majeur.e\n377831:  2009 69381 0.9999903    1    1   8     29 Majeur.e\n377832:  2009 69381 0.9999903    2    1   6     25 Majeur.e\n377833:  2009 69381 0.9999903    2    1   6     32 Majeur.e\n\n# Version commentée\nmutate( # J'utilise la fonction mutate pour créer une colonne\n  rp, # Le premier argument de mutate, le tableau à transformer\n  age_rec = # Le deuxième argument de mutate, le nom de la colonne à créer (à gauche du =) et la valeur que je lui donne (à droite du =)\n    ifelse( # Elle sera créée à l'aide du test opérée par la fonction ifelse\n      AGEREV &gt; 17, # Le premier argument de ifelse, la condition\n      \"Majeur.e\", # Le deuxième argument de ifelse, la valeur à donner si la condition est vérifiée,\n      \"Mineur.e\" # Le troisième argument de ] ifelse, la valeur à donner si la condition n'est pas vérifié\n    ) # Je ferme la parenthèse de la fonction ifelse\n) # Je ferme la parenthèse de la fonction mutate\n\n        annee   ARM    IPONDI IMMI SEXE CS1 AGEREV  age_rec\n     1:  2019 69388 1.1778303    2    1   8     14 Mineur.e\n     2:  2019 69388 1.1778303    2    2   3     43 Majeur.e\n     3:  2019 69388 1.1778303    2    1   8     11 Mineur.e\n     4:  2019 69384 2.9651895    1    2   8     85 Majeur.e\n     5:  2019 69383 0.9564125    2    1   8     23 Majeur.e\n    ---                                                    \n377829:  2009 69381 0.9999903    1    1   5     31 Majeur.e\n377830:  2009 69381 0.9999903    2    1   6     43 Majeur.e\n377831:  2009 69381 0.9999903    1    1   8     29 Majeur.e\n377832:  2009 69381 0.9999903    2    1   6     25 Majeur.e\n377833:  2009 69381 0.9999903    2    1   6     32 Majeur.e\n\n# On obtient bien une nouvelle variable/colonne nommée age_rec qui prend soit la valeur \"Mineur.e\", soit la valeur \"Majeur.e\"\n\nDès qu’on veut utiliser plus d’un test (par exemple, obtenir trois valeurs : mineur.e, adulte, senior), il faut utiliser la fonction case_when.\n\n# Version lisible\nmutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\n        annee   ARM    IPONDI IMMI SEXE CS1 AGEREV  age_rec\n     1:  2019 69388 1.1778303    2    1   8     14 Mineur.e\n     2:  2019 69388 1.1778303    2    2   3     43   Adulte\n     3:  2019 69388 1.1778303    2    1   8     11 Mineur.e\n     4:  2019 69384 2.9651895    1    2   8     85   Senior\n     5:  2019 69383 0.9564125    2    1   8     23   Adulte\n    ---                                                    \n377829:  2009 69381 0.9999903    1    1   5     31   Adulte\n377830:  2009 69381 0.9999903    2    1   6     43   Adulte\n377831:  2009 69381 0.9999903    1    1   8     29   Adulte\n377832:  2009 69381 0.9999903    2    1   6     25   Adulte\n377833:  2009 69381 0.9999903    2    1   6     32   Adulte\n\n# Version commentée\nmutate( # Je crée une variable grâce à la fonction mutate\n  rp, # Le premier argument, je transforme le tableau rp\n  age_rec = # Le deuxième argument, la variable à créer\n    case_when( # Qui sera créee grâce à la fonction case_when\n      # À gauche du \"~\", c'est la condition, à droite la valeur\n      AGEREV &lt; 18 ~ \"Mineur.e\", # Si AGEREV est strictement inférieur à 18, alors la variable prendra la valeur \"Mineur.e\"\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\", # Si AGEREV est strictement supérieur à 17 ET qu'AGEREV est strictement inférieur à 65, alors la variable prendra la valeur \"Adulte\"\n      AGEREV &gt; 64 ~ \"Senior\" # Si AGEREV est strictement supérieur à 64, alors la variable prendra la valeur \"Senior\"\n    ) # Je ferme la parenthèse de la fonction case_when\n) # Je ferme la parenthèse de la fonction mutate\n\n        annee   ARM    IPONDI IMMI SEXE CS1 AGEREV  age_rec\n     1:  2019 69388 1.1778303    2    1   8     14 Mineur.e\n     2:  2019 69388 1.1778303    2    2   3     43   Adulte\n     3:  2019 69388 1.1778303    2    1   8     11 Mineur.e\n     4:  2019 69384 2.9651895    1    2   8     85   Senior\n     5:  2019 69383 0.9564125    2    1   8     23   Adulte\n    ---                                                    \n377829:  2009 69381 0.9999903    1    1   5     31   Adulte\n377830:  2009 69381 0.9999903    2    1   6     43   Adulte\n377831:  2009 69381 0.9999903    1    1   8     29   Adulte\n377832:  2009 69381 0.9999903    2    1   6     25   Adulte\n377833:  2009 69381 0.9999903    2    1   6     32   Adulte\n\n\nIl manque deux choses aux recodages ci-dessus. Nous n’avons pas enregistré notre travail car nous n’avons pas créé de nouvel objet avec l’opérateur d’assignation &lt;-. On peut soit réécrire sur le tableau de données original ou en créer un nouveau qui sera notre nouveau support de travail.\n\n# Je transforme directement le tableau initial\nrp &lt;- # Crée un nouvel objet rp (qui existait déjà, donc on réécrit desus) à partir du tableau initial (rp) transformé  avec mutate\n  mutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\n# Je créer un autre tableau sur lequel je travail\nrp2 &lt;- # Crée un nouvel objet rp2 (qui n'existait pas) à partir du tableau initial (rp) transformé avec mutate\n  mutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\nDeuxième élément manquant, nous n’avons pas spécifier la nature de notre nouvelle colonne/vecteur. On cherche ici à créer un facteur puisqu’on a une variable catégorielle. La fonction fct permet de créer un vecteur et de spécifier l’ordre de ses modalités (quand on fera des tableaux ou des graphiques, on voudra que “Senior” apparaisse en dernier, et non entre “Mineur.e” et “Majeur.e” !)\n\n# Un vecteur de type texte qui renseigne la catégorie d'âge de 6 personnes\ncat_age &lt;- c(\"Mineur.e\", \n             \"Adulte\", \n             \"Adulte\", \n             \"Senior\", \n             \"Mineur.e\",\n             \"Senior\")\n# Le tri croisé ne donne pas quelque chose d'intuitif :\ntable(cat_age)\n\ncat_age\n  Adulte Mineur.e   Senior \n       2        2        2 \n\n# La catégorie adulte apparaît avant mineur.e\n# On le transforme en facteur\ncat_age &lt;-\n  fct(cat_age, # Le premier argument, le facteur à transformer\n      levels = # Le deuxième argument, les modalités (levels) avec l'ordre d'apparition \n        c(\"Mineur.e\", \"Adulte\", \"Senior\")\n      )\n# Le problème est résolu\ntable(cat_age)\n\ncat_age\nMineur.e   Adulte   Senior \n       2        2        2 \n\n\n\n\nSavoir utiliser tidyverse et enchaîner les opérations\nLes graphiques utilisés par François Héran nous ont servi d’exemple pour comprendre toutes les opérations nécessaires pour passer de données tabulaires brutes – un recensement où chaque individu est représenté par une ligne – à des graphiques qui représentent l’évolution du nombre d’immigré.es et de la proportion d’immigré.es sur plusieurs années. Vous pouvez retrouver le powerpoint à cette adresse, je vous conseille d’aller regarder comment chaque opération est traduite par une ligne de code.\nIl faut à partir d’ici bien comprendre la logique d’enchaînement des opérations propre au tidyverse. Nous avons jusqu’à présent vu qu’on pouvait emboîter les fonctions, par exemple créer un vecteur avec c() puis en faire un facteur avec fct() :\n\nfct(\n  c(\"Jaune\", \"Vert\")\n)\n\n[1] Jaune Vert \nLevels: Jaune Vert\n\n\nIci l’objet brut qu’on va vouloir transformer se situe à la fin du code. L’opérateur pipe %&gt;% permet d’enchaîner les opérations. Il prend un objet et il applique une par une les fonctions qu’on lui donne. C’est l’image d’un objet passant par un tuyau et qu’on modifie progressivement jusqu’au produit final.\n\nc(\"Jaune\", \"Vert\") %&gt;% # Prends ce vecteur\n  fct() # Applique lui la fonction fct()\n\n[1] Jaune Vert \nLevels: Jaune Vert\n\n\nVoici un exemple à partir du recensement lyonnais. Il faudra vous familiariser au fur et à mesure avec la fonction adaptée à chaque opération. Les codes sont commentés dans le premier bloc de code. Je vous conseille d’aller voir les blocs de codes suivants pour vous rendre compte de la transformation progressive du tableau.\n\n# Compter le nombre d'immigré.es et de non-immigré.es à Lyon en 2019\nrp %&gt;% # Prends le tableau de données du recensement\n  filter(annee == 2019) %&gt;% # Garde uniquement les données de 2019\n  mutate( # Crée une nouvelle variable \n    # Le dictionnaire des codes nous dit que la variable IMMI brute vaut 1 si la personne est immigrée, 2 si elle ne l'est pas. On le recode en facteur.\n    IMMI = \n      fct(\n        ifelse(IMMI == 1,\n             \"Immigré.e\",\n             \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;% \n  count(IMMI, # Compte les effectifs pour la variable IMMI\n        wt = IPONDI) # en tenant compte de la pondération (IPONDI est la variable de poids, on la donne à l'argument wt pour weights)\n\n            IMMI         n\n1: Pas immigré.e 452997.59\n2:     Immigré.e  69898.94\n\n# Comparer la proportion d'immigré.es en 2009 et 2019\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee, # On compte d'abord en fonction de l'année\n        IMMI,  # Puis de la varible d'immigration\n        wt = IPONDI) %&gt;%\n  # On crée une nouvelle colonne pour les pourcentages. Il faut pour cela faire une opération groupée : calculer la population totale en 2009 et 2019 = nombre d'immigré.es + nombre de non-immigré.es\n  group_by(annee) %&gt;% # On dit au tidyverse de faire les prochaines opérations au sein du groupe défini par la variable \"annee\"\n  mutate( \n    # La proportion, c'est l'effectif divisé par la population totale. L'effectif ici c'est n, la population totale c'est la somme des n (calculée pour chaque année de façon indépendante !)\n    p =\n      n/sum(n)\n  ) %&gt;%\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde que le pourcentage d'immigré.e car les lignes sont redondantes\n  select(-IMMI) # On enlève la variable IMMI vu qu'on n'a plus que les lignes \"Immigré.e\"\n\n# A tibble: 2 × 3\n# Groups:   annee [2]\n  annee      n     p\n  &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1  2009 57138. 0.119\n2  2019 69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  )\n\n        annee   ARM    IPONDI          IMMI SEXE CS1 AGEREV  age_rec\n     1:  2019 69388 1.1778303 Pas immigré.e    1   8     14 Mineur.e\n     2:  2019 69388 1.1778303 Pas immigré.e    2   3     43   Adulte\n     3:  2019 69388 1.1778303 Pas immigré.e    1   8     11 Mineur.e\n     4:  2019 69384 2.9651895     Immigré.e    2   8     85   Senior\n     5:  2019 69383 0.9564125 Pas immigré.e    1   8     23   Adulte\n    ---                                                             \n377829:  2009 69381 0.9999903     Immigré.e    1   5     31   Adulte\n377830:  2009 69381 0.9999903 Pas immigré.e    1   6     43   Adulte\n377831:  2009 69381 0.9999903     Immigré.e    1   8     29   Adulte\n377832:  2009 69381 0.9999903 Pas immigré.e    1   6     25   Adulte\n377833:  2009 69381 0.9999903 Pas immigré.e    1   6     32   Adulte\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  )\n\n   annee          IMMI         n\n1:  2009 Pas immigré.e 422649.12\n2:  2009     Immigré.e  57137.59\n3:  2019 Pas immigré.e 452997.59\n4:  2019     Immigré.e  69898.94\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   annee [2]\n  annee IMMI                n     p\n  &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1  2009 Pas immigré.e 422649. 0.881\n2  2009 Immigré.e      57138. 0.119\n3  2019 Pas immigré.e 452998. 0.866\n4  2019 Immigré.e      69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n)) %&gt;%\n  filter(IMMI == \"Immigré.e\")\n\n# A tibble: 2 × 4\n# Groups:   annee [2]\n  annee IMMI           n     p\n  &lt;int&gt; &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1  2009 Immigré.e 57138. 0.119\n2  2019 Immigré.e 69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n)) %&gt;%\n  filter(IMMI == \"Immigré.e\") %&gt;%\n  select(-IMMI)\n\n# A tibble: 2 × 3\n# Groups:   annee [2]\n  annee      n     p\n  &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1  2009 57138. 0.119\n2  2019 69899. 0.134"
  },
  {
    "objectID": "Seance1.html",
    "href": "Seance1.html",
    "title": "Prise en main",
    "section": "",
    "text": "R Studio fonctionne en complément du logiciel de programmation R. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts.\n\n\n\n\nL’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap.\n\n\n\n\nNous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”.\n\n\n\nLes deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML.\n\n\n\n\n\n\n\nPour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre1 :\n [1] 4\n\n\n\n\n\n\nNous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur2.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)\n\n\n\n\n\nR étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante.\n\n\n\nExercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance1.html#les-4-panneaux-de-linterface",
    "href": "Seance1.html#les-4-panneaux-de-linterface",
    "title": "Prise en main",
    "section": "",
    "text": "L’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap."
  },
  {
    "objectID": "Seance1.html#les-scripts",
    "href": "Seance1.html#les-scripts",
    "title": "Prise en main",
    "section": "",
    "text": "Nous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”."
  },
  {
    "objectID": "Seance1.html#lenvironnement-et-lespace-multifonction",
    "href": "Seance1.html#lenvironnement-et-lespace-multifonction",
    "title": "Prise en main",
    "section": "",
    "text": "Les deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML."
  },
  {
    "objectID": "Seance1.html#objets",
    "href": "Seance1.html#objets",
    "title": "Prise en main",
    "section": "",
    "text": "Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre1 :\n [1] 4"
  },
  {
    "objectID": "Seance1.html#fonctions",
    "href": "Seance1.html#fonctions",
    "title": "Prise en main",
    "section": "",
    "text": "Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur2.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)"
  },
  {
    "objectID": "Seance1.html#sec-packages",
    "href": "Seance1.html#sec-packages",
    "title": "Prise en main",
    "section": "",
    "text": "R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante."
  },
  {
    "objectID": "Seance1.html#exercices",
    "href": "Seance1.html#exercices",
    "title": "Prise en main",
    "section": "",
    "text": "Exercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance1.html#jeu-de-données-dexemple",
    "href": "Seance1.html#jeu-de-données-dexemple",
    "title": "Prise en main",
    "section": "Jeu de données d’exemple",
    "text": "Jeu de données d’exemple\nDans cette partie nous allons utiliser un jeu de données présent dans l’extension questionr. L’extension est déjà installée sur le service R Studio du SSP Cloud, il faudrait autrement l’installer en lançant la commande install.packages(\"questionr\") . Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) :\n\nlibrary(questionr)\n\nL’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension.\nLe jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. La commande data permet d’accéder aux données contenues dans le package. En temps normal et en dehors de cet exemple pédagogique, vous aurez à importer des fichiers stocker sur votre propre ordinateur avec une commande du type read_csv2(\"chemin du fichier/fichier.csv\"). l\n\n# Pour éviter d'encombrer l'environnement de travail, on le vide avant de charger les données\n# On vide l'environnement à l'aide de la balayette située en haut de l'environnement\n# Ou à l'aide de la fonction rm()\nrm(list = ls())\n\n# Chargement des données\ndata(hdv2003)\n\nUn tableau de données apparaît maintenant dans votre environnement. C’est un objet comme l’étaient les vecteurs étudiés plus haut et cet objet est appelé hdv2003 ."
  },
  {
    "objectID": "Seance1.html#tableau-de-données-data-frame",
    "href": "Seance1.html#tableau-de-données-data-frame",
    "title": "Prise en main",
    "section": "Tableau de données (data frame)",
    "text": "Tableau de données (data frame)\nUn data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel.\nSi on se contente d’exécuter le nom de notre tableau de données R va, comme à son habitude, nous l’afficher dans la console (ou sous le bloc de code si vous n’avez pas modifié la zone de sortie).\n\nhdv2003\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n2  2  23 Femme                                                 &lt;NA&gt; 9738.396\n3  3  59 Homme                    Derniere annee d'etudes primaires 3994.102\n4  4  34 Homme Enseignement superieur y compris technique superieur 5731.662\n5  5  71 Femme                    Derniere annee d'etudes primaires 4329.094\n                  occup     qualif freres.soeurs clso\n1 Exerce une profession    Employe             8  Oui\n2       Etudiant, eleve       &lt;NA&gt;             2  Oui\n3 Exerce une profession Technicien             2  Non\n4 Exerce une profession Technicien             1  Non\n5              Retraite    Employe             0  Oui\n                        relig                     trav.imp    trav.satisf\n1 Ni croyance ni appartenance                Peu important Insatisfaction\n2 Ni croyance ni appartenance                         &lt;NA&gt;           &lt;NA&gt;\n3 Ni croyance ni appartenance Aussi important que le reste      Equilibre\n4  Appartenance sans pratique Moins important que le reste   Satisfaction\n5         Pratiquant regulier                         &lt;NA&gt;           &lt;NA&gt;\n  hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1       Non        Non          Non     Oui    Non    Non   Non         0\n2       Non        Non          Non     Non    Non    Oui   Oui         1\n3       Non        Non          Non     Non    Non    Non   Oui         0\n4       Non        Non          Non     Oui    Oui    Oui   Oui         2\n5       Non        Non          Non     Non    Non    Non   Non         3\n [ reached 'max' / getOption(\"max.print\") -- omitted 1995 rows ]\n\n\nUne autre manière d’afficher le contenu du tableau est de cliquer sur le nom de l’objet dans l’onglet Environment, ou d’utiliser la fonction View :\n\nView(hdv2003)\n\nIl est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille3.\nUn data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire :\n\nd &lt;- hdv2003\n\nce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite.\n\nStructure du tableau\nUn tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau.\n\nnrow(d)\n\n[1] 2000\n\n\n\nncol(d)\n\n[1] 20\n\n\nLa fonction dim renvoie ses dimensions, donc les deux nombres précédents.\n\ndim(d)\n\n[1] 2000   20\n\n\nLa fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables.\n\nnames(d)\n\n [1] \"id\"            \"age\"           \"sexe\"          \"nivetud\"      \n [5] \"poids\"         \"occup\"         \"qualif\"        \"freres.soeurs\"\n [9] \"clso\"          \"relig\"         \"trav.imp\"      \"trav.satisf\"  \n[13] \"hard.rock\"     \"lecture.bd\"    \"peche.chasse\"  \"cuisine\"      \n[17] \"bricol\"        \"cinema\"        \"sport\"         \"heures.tv\"    \n\n\nEnfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type et affiche les premières valeurs.\n\nstr(d)\n\n'data.frame':   2000 obs. of  20 variables:\n $ id           : int  1 2 3 4 5 6 7 8 9 10 ...\n $ age          : int  28 23 59 34 71 35 60 47 20 28 ...\n $ sexe         : Factor w/ 2 levels \"Homme\",\"Femme\": 2 2 1 1 2 2 2 1 2 1 ...\n $ nivetud      : Factor w/ 8 levels \"N'a jamais fait d'etudes\",..: 8 NA 3 8 3 6 3 6 NA 7 ...\n $ poids        : num  2634 9738 3994 5732 4329 ...\n $ occup        : Factor w/ 7 levels \"Exerce une profession\",..: 1 3 1 1 4 1 6 1 3 1 ...\n $ qualif       : Factor w/ 7 levels \"Ouvrier specialise\",..: 6 NA 3 3 6 6 2 2 NA 7 ...\n $ freres.soeurs: int  8 2 2 1 0 5 1 5 4 2 ...\n $ clso         : Factor w/ 3 levels \"Oui\",\"Non\",\"Ne sait pas\": 1 1 2 2 1 2 1 2 1 2 ...\n $ relig        : Factor w/ 6 levels \"Pratiquant regulier\",..: 4 4 4 3 1 4 3 4 3 2 ...\n $ trav.imp     : Factor w/ 4 levels \"Le plus important\",..: 4 NA 2 3 NA 1 NA 4 NA 3 ...\n $ trav.satisf  : Factor w/ 3 levels \"Satisfaction\",..: 2 NA 3 1 NA 3 NA 2 NA 1 ...\n $ hard.rock    : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ lecture.bd   : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ peche.chasse : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 2 2 1 1 ...\n $ cuisine      : Factor w/ 2 levels \"Non\",\"Oui\": 2 1 1 2 1 1 2 2 1 1 ...\n $ bricol       : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 2 1 1 1 2 1 1 ...\n $ cinema       : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 1 2 1 2 1 1 2 2 ...\n $ sport        : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 2 2 1 2 1 1 1 2 ...\n $ heures.tv    : num  0 1 0 2 3 2 2.9 1 2 2 ...\n\n\n\n\nAccéder aux variables d’un tableau\nUne opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape :\n\nd$sexe\n\n  [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme Homme\n [13] Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme Femme Femme\n [25] Femme Homme Femme Homme Homme Homme Homme Homme Homme Homme Femme Femme\n [37] Homme Femme Femme Homme Femme Homme Homme Femme Femme Homme Femme Femme\n [49] Femme Femme Homme Femme Homme Femme Homme Femme Femme Femme Homme Femme\n [61] Femme Homme Homme Homme Homme Femme Homme Homme Femme Femme Homme Homme\n [73] Femme Femme Femme Femme Homme Femme Femme Femme Femme Femme Femme Homme\n [85] Homme Femme Homme Homme Homme Homme Homme Femme Homme Femme Femme Femme\n [97] Homme Homme Femme Femme\n [ reached getOption(\"max.print\") -- omitted 1900 entries ]\nLevels: Homme Femme\n\n\nR va afficher l’ensemble des valeurs de la variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment.\nLa fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères.\nSi on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail.\n\nhead(d$age)\n\n[1] 28 23 59 34 71 35\n\n\n\ntail(d$age)\n\n[1] 46 45 46 24 24 66\n\n\nLe deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher.\n\n\nCréer une nouvelle variable\nOn peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur.\nPar exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé.\n\nhead(d$heures.tv)\n\n[1] 0 1 0 2 3 2\n\n\nOn peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée convertie en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante :\n\nd$minutes.tv &lt;- d$heures.tv * 60\n\nOn peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau.\n\nhead(d$minutes.tv)\n\n[1]   0  60   0 120 180 120"
  },
  {
    "objectID": "Seance1.html#analyse-univariée",
    "href": "Seance1.html#analyse-univariée",
    "title": "Prise en main",
    "section": "Analyse univariée",
    "text": "Analyse univariée\nOn a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $.\nSi on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.).\n\nAnalyser une variable quantitative\nUne variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv).\n\nIndicateurs de centralité\nCaractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent.\nPour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range.\n\nmin(d$age)\n\n[1] 18\n\nmax(d$age)\n\n[1] 97\n\nrange(d$age)\n\n[1] 18 97\n\n\nOn peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean.\n\nmean(d$age)\n\n[1] 48.157\n\n\nIl existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median.\n\nmedian(d$age)\n\n[1] 48\n\n\nUne différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2019, le salaire net moyen des salariés à temps plein dans le secteur privé en France était de 2424 euros, tandis que le salaire net médian n’était que de 1940 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut.\n\n\nIndicateurs de dispersion\nLes indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées.\nL’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations :\n\nmax(d$age) - min(d$age)\n\n[1] 79\n\n\nLes indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation).\n\nvar(d$age)\n\n[1] 287.0249\n\n\n\nsd(d$age)\n\n[1] 16.94181\n\n\nPlus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées.\nUne autre manière de mesurer la dispersion est de calculer les quartiles :\n\nle premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus\nle deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane)\nle troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus\n\nOn peut les calculer avec la fonction quantile :\n\n## Premier quartile\nquantile(d$age, prob = 0.25)\n\n25% \n 35 \n\n\n\n## Troisième quartile\nquantile(d$age, prob = 0.75)\n\n75% \n 60 \n\n\nquantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc.\nNotons enfin que la fonction summary permet d’obtenir d’un seul coup plusieurs indicateurs classiques :\n\nsummary(d$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  18.00   35.00   48.00   48.16   60.00   97.00 \n\n\n\n\n\nAnalyser une variable qualitative\nUne variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)…\nÀ noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs.\n\nTri à plat\nL’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table.\n\ntable(d$sexe)\n\n\nHomme Femme \n  899  1101 \n\n\nCe tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes.\n\ntable(d$qualif)\n\n\n      Ouvrier specialise         Ouvrier qualifie               Technicien \n                     203                      292                       86 \nProfession intermediaire                    Cadre                  Employe \n                     160                      260                      594 \n                   Autre \n                      58 \n\n\nUn tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif.\n\ntab &lt;- table(d$qualif)\nsort(tab)\n\n\n                   Autre               Technicien Profession intermediaire \n                      58                       86                      160 \n      Ouvrier specialise                    Cadre         Ouvrier qualifie \n                     203                      260                      292 \n                 Employe \n                     594 \n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$qualif, useNA = \"always\").\n\n\nÀ noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles.\n\nsummary(d$qualif)\n\n      Ouvrier specialise         Ouvrier qualifie               Technicien \n                     203                      292                       86 \nProfession intermediaire                    Cadre                  Employe \n                     160                      260                      594 \n                   Autre                     NA's \n                      58                      347"
  },
  {
    "objectID": "Seance1.html#les-classes-de-vecteur",
    "href": "Seance1.html#les-classes-de-vecteur",
    "title": "Prise en main",
    "section": "Les classes de vecteur",
    "text": "Les classes de vecteur\nLes vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent.\nOn a ainsi des vecteurs de type integer ou double, qui contiennent respectivement des nombres entiers ou décimaux :\n\nlibrary(questionr)\ndata(hdv2003)\ntypeof(hdv2003$age)\n\n[1] \"integer\"\n\n\n\ntypeof(hdv2003$heures.tv)\n\n[1] \"double\"\n\n\nDes vecteurs de type character, qui contiennent des chaînes de caractères :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\ntypeof(vec)\n\n[1] \"character\"\n\n\nEt des vecteurs de type logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE).\n\nvec &lt;- c(TRUE, FALSE, FALSE, TRUE)\ntypeof(vec)\n\n[1] \"logical\"\n\n\nOn peut convertir un vecteur d’un type en un autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA.\n\nx &lt;- c(\"1\", \"2.35\", \"8.2e+03\", \"foo\")\nas.numeric(x)\n\nWarning: NAs introduced by coercion\n\n\n[1]    1.00    2.35 8200.00      NA\n\ny &lt;- 2:6\nas.character(y)\n\n[1] \"2\" \"3\" \"4\" \"5\" \"6\"\n\n\nOn peut sélectionner certains éléments d’un vecteur à l’aide de l’opérateur []. La manière la plus simple est d’indiquer la position des éléments qu’on veut sélectionner :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[c(1, 3)]\n\n[1] \"Jaune\" \"Rouge\"\n\n\nLa sélection peut aussi être utilisée pour modifier certains éléments d’un vecteur, par exemple :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[2] &lt;- \"Violet\"\nvec\n\n[1] \"Jaune\"  \"Violet\" \"Rouge\"  \"Vert\""
  },
  {
    "objectID": "Seance1.html#sec-tests",
    "href": "Seance1.html#sec-tests",
    "title": "Prise en main",
    "section": "Tests et comparaison",
    "text": "Tests et comparaison\nUn test est une opération logique de comparaison qui renvoie vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur.\nParmi les opérateurs de comparaison disponibles, on trouve notamment :\n\n== qui teste l’égalité\n!= qui teste la différence\n&gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité\n%in% qui teste l’appartenance à un ensemble de valeurs\n\nExemple le plus simple :\n\n2 == 3\n\n[1] FALSE\n\n\n\n2 != 3\n\n[1] TRUE\n\n\nExemple appliqué à un vecteur :\n\nx &lt;- 1:10\nx &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nOn peut combiner plusieurs tests avec les opérateurs logiques et (&) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6 inclus, on peut faire :\n\nx &gt;= 3 & x &lt;= 6\n\n [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nSi on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec == \"Jaune\" | vec == \"Vert\"\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nÀ noter que dans ce cas, on peut utiliser l’opérateur %in%4, qui teste si une valeur fait partie des éléments d’un vecteur :\n\nvec %in% c(\"Jaune\", \"Vert\")\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, si on souhaite tester si une valeur x est inconnue (ou ‘manquante’), c’est-à-dire si elle est codée NA (Not Available), faire le test x == NA ne donnera pas le résultat escompté. En effet, fidèle à sa réputation de rigueur informaticienne, pour R NA == NA ne vaut pas TRUE mais… NA (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).\nPour tester si une valeur est inconnue (NA), il faut utiliser la fonction dédiée is.na et faire is.na(x). Cependant, par convention, NA %in% NA vaut TRUE.\n\n\nEnfin, on peut inverser un test avec l’opérateur non (!) :\n\n!(vec %in% c(\"Jaune\", \"Vert\"))\n\n[1] FALSE FALSE  TRUE FALSE"
  },
  {
    "objectID": "Seance1.html#footnotes",
    "href": "Seance1.html#footnotes",
    "title": "Prise en main",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEt permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎\nc est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎\nLa seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎\nPour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎"
  }
]