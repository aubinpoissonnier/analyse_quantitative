[
  {
    "objectID": "Seance2.html",
    "href": "Seance2.html",
    "title": "Séance 2",
    "section": "",
    "text": "R a la particularité d’être un logiciel open-source et développé par la communauté. Ce n’est pas le cas d’autres options comme SAS, un logiciel payant qui a été pendant longtemps l’outil de travail des institutions de la statistique publique française. Il existe donc souvent plusieurs façons de faire une même opération, à partir du R de base si les fonctions adaptées existent ou grâce aux fonctions offertes par les différentes extensions. Ce TD présentera uniquement l’univers tidyverse pour son exhaustivité et l’existence d’une documentation en ligne très importante.\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\nlubridate (manipulation de dates)\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles.\n\n\ndplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type.\n\n\n\ndplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement.\n\n\n\nLa manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\nParfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions ifelse pour les cas les plus simples, ou case_when pour les cas plus complexes.\n\n\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n\n[1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nlibrary(questionr)\ndata(hdv2003)\nhdv2003$statut &lt;- ifelse(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60,\n    \"Homme de plus de 60 ans\",\n    \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Homme de plus de 60 ans \n                   1778                     222 \n\n\n\n\n\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Homme\" ~ \"Homme de plus de 60 ans\",\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Femme\" ~ \"Femme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Femme de plus de 60 ans Homme de plus de 60 ans \n                   1512                     266                     222 \n\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nWarning\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.\n\n\nPour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\nAutre Homme \n 1101   899 \n\n\nComme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" & age &gt; 60, cette deuxième condition n’est jamais testée, et on n’obtiendra donc jamais la valeur correspondante.\nPour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général.\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    TRUE ~ \"Autre\"\n)\n\n\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir la fin de la première séance.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante.\n\n\n\n\nQuand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\nUn élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows\n\n\n\n\n\n\nOn commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue."
  },
  {
    "objectID": "Seance2.html#manipuler-les-données-avec-dplyr",
    "href": "Seance2.html#manipuler-les-données-avec-dplyr",
    "title": "Séance 2",
    "section": "",
    "text": "dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type."
  },
  {
    "objectID": "Seance2.html#préparation",
    "href": "Seance2.html#préparation",
    "title": "Séance 2",
    "section": "",
    "text": "dplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement."
  },
  {
    "objectID": "Seance2.html#les-verbes-de-dplyr",
    "href": "Seance2.html#les-verbes-de-dplyr",
    "title": "Séance 2",
    "section": "",
    "text": "La manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\nParfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions ifelse pour les cas les plus simples, ou case_when pour les cas plus complexes.\n\n\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n\n[1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nlibrary(questionr)\ndata(hdv2003)\nhdv2003$statut &lt;- ifelse(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60,\n    \"Homme de plus de 60 ans\",\n    \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Homme de plus de 60 ans \n                   1778                     222 \n\n\n\n\n\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Homme\" ~ \"Homme de plus de 60 ans\",\n    hdv2003$age &gt; 60 & hdv2003$sexe == \"Femme\" ~ \"Femme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\n                  Autre Femme de plus de 60 ans Homme de plus de 60 ans \n                   1512                     266                     222 \n\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nWarning\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.\n\n\nPour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    TRUE ~ \"Autre\"\n)\n\ntable(hdv2003$statut)\n\n\nAutre Homme \n 1101   899 \n\n\nComme la condition sexe == \"Homme\" est plus générale que sexe == \"Homme\" & age &gt; 60, cette deuxième condition n’est jamais testée, et on n’obtiendra donc jamais la valeur correspondante.\nPour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général.\n\nhdv2003$statut &lt;- case_when(\n    hdv2003$sexe == \"Homme\" & hdv2003$age &gt; 60 ~ \"Homme de plus de 60 ans\",\n    hdv2003$sexe == \"Homme\" ~ \"Homme\",\n    TRUE ~ \"Autre\"\n)\n\n\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir la fin de la première séance.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante."
  },
  {
    "objectID": "Seance2.html#sec-pipe",
    "href": "Seance2.html#sec-pipe",
    "title": "Séance 2",
    "section": "",
    "text": "Quand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\n# A tibble: 16,174 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      558            600        -2      924            917\n 2  2013     1     1      628            630        -2     1016            947\n 3  2013     1     1      658            700        -2     1027           1025\n 4  2013     1     1      702            700         2     1058           1014\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      828            823         5     1150           1143\n 7  2013     1     1      829            830        -1     1152           1200\n 8  2013     1     1      856            900        -4     1226           1220\n 9  2013     1     1      859            900        -1     1223           1225\n10  2013     1     1      921            900        21     1237           1227\n# ℹ 16,164 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1        -2         7\n 2        -2        29\n 3        -2         2\n 4         2        44\n 5        13         7\n 6         5         7\n 7        -1        -8\n 8        -4         6\n 9        -1        -2\n10        21        10\n# ℹ 16,164 more rows\n\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n# A tibble: 16,174 × 2\n   dep_delay arr_delay\n       &lt;dbl&gt;     &lt;dbl&gt;\n 1       -16       -31\n 2       -15         4\n 3       -15        -4\n 4       -15       -22\n 5       -15       -29\n 6       -15       -20\n 7       -15       -25\n 8       -15       -35\n 9       -15       -17\n10       -15        -7\n# ℹ 16,164 more rows\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))"
  },
  {
    "objectID": "Seance2.html#opérations-groupées",
    "href": "Seance2.html#opérations-groupées",
    "title": "Séance 2",
    "section": "",
    "text": "Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows"
  },
  {
    "objectID": "Seance2.html#exercices",
    "href": "Seance2.html#exercices",
    "title": "Séance 2",
    "section": "",
    "text": "On commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue."
  },
  {
    "objectID": "Seance2.html#initialisation",
    "href": "Seance2.html#initialisation",
    "title": "Séance 2",
    "section": "Initialisation",
    "text": "Initialisation\nUn graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction :\n\nggplot(data = rp)\n\n\n\n## Ou, équivalent\nggplot(rp)\n\n\n\n\nOn a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. Ces éléments sont appelés des geom, et on les ajoute à l’objet graphique de base avec l’opérateur +.\nUn des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante :\n\nggplot(rp) +\n    geom_histogram()\n\nReste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter sur l’axe des x (l’axe horizontal). Ainsi, si on souhaite représenter la distribution des communes du jeu de données selon le pourcentage de cadres dans leur population active (variable cadres), on pourra faire :\n\nggplot(rp) +\n    geom_histogram(aes(x = cadres))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nSi on veut représenter une autre variable, il suffit de changer la valeur de x :\n\nggplot(rp) +\n    geom_histogram(aes(x = ouvr))\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand on spécifie une variable, inutile d’indiquer le nom du tableau de données sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué avec le paramètre data. On peut donc se contenter de ouvr.\n\n\nCertains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points, on peut le faire en ajoutant un geom_point. On doit alors indiquer à la fois la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points, il faut donc passer ces deux arguments à aes() :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nOn peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"darkgreen\", size = 3, alpha = 0.3\n    )\n\n\n\n\nOn notera que dans ce cas les arguments sont dans la fonction geom mais à l’extérieur du aes(). Plus d’explications sur ce point dans quelques instants."
  },
  {
    "objectID": "Seance2.html#exemples-de-geom",
    "href": "Seance2.html#exemples-de-geom",
    "title": "Séance 2",
    "section": "Exemples de geom",
    "text": "Exemples de geom\nIl existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre les geom_histogram et geom_point que l’on vient de voir, on pourra noter les geom suivants.\n\ngeom_boxplot\ngeom_boxplot permet de représenter des boîtes à moustaches. On lui passe en y la variable numérique dont on veut étudier la répartition, et en x la variable qualitative contenant les classes qu’on souhaite comparer. Ainsi, si on veut comparer la répartition du pourcentage de maisons en fonction du département de la commune, on pourra faire :\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison))\n\n\n\n\n\n\ngeom_violin\ngeom_violin est très semblable à geom_boxplot, mais utilise des graphes en violon à la place des boîtes à moustache.\n\nggplot(rp) +\n    geom_violin(aes(x = departement, y = maison))\n\n\n\n\nLes graphes en violon peuvent donner une lecture plus fine des différences de distribution selon les classes. Comme pour les graphiques de densité, on peut faire varier le niveau de “détail” de la représentation en utilisant l’argument bw (bande passante).\n\nggplot(rp) +\n    geom_violin(\n        aes(x = departement, y = maison),\n        bw = 2\n    )\n\n\n\n\n\n\ngeom_bar et geom_col\ngeom_bar permet de produire un graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité.\nPar exemple, si on veut afficher le nombre de communes de notre jeu de données pour chaque département :\n\nggplot(rp) +\n    geom_bar(aes(x = departement))\n\n\n\n\nSi on préfère avoir un graphique en barres horizontales, il suffit de passer la variable comme attribut y plutôt que x.\n\nggplot(rp) +\n    geom_bar(aes(y = departement))\n\n\n\n\nUne autre possibilité est d’utiliser coord_flip(), qui permet d’intervertir l’axe horizontal et l’axe vertical.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    coord_flip()\n\n\n\n\nÀ noter que coord_flip() peut s’appliquer à n’importe quel graphique ggplot2.\nParfois, on a déjà calculé le tri à plat de la variable à représenter. Dans ce cas on souhaite représenter les effectifs directement, sans les calculer.\nC’est le cas par exemple si on a les données sous la forme suivante dans un tableau de données nommé tab :\n\ntab\n\n       departement   n\n1 Bouches-du-Rhône 115\n2   Hauts-de-Seine  35\n3           Lozère   8\n4             Oise  76\n5            Rhône 132\n\n\nDans ce cas on peut utiliser geom_col. Il faut alors spécifier, en plus de l’argument x, un argument y indiquant la variable contenant la hauteur des barres. Dans notre exemple, il s’agit de la variable n.\n\nggplot(tab) +\n    geom_col(aes(x = departement, y = n))\n\n\n\n\nQue ce soit pour geom_bar ou geom_col, on peut modifier l’apparence du graphique en passant des arguments supplémentaires comme fill ou width.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement),\n        fill = \"darkblue\", width = .5\n    )\n\n\n\n\n\n\ngeom_text\ngeom_text permet d’afficher des étiquettes de texte. On doit lui fournir trois paramètres dans aes : x et y pour la position des étiquettes, et label pour leur texte.\nPar exemple, si on souhaite représenter le nuage croisant la part des diplômés du supérieur et la part de cadres, mais en affichant le nom de la commune (variable commune) plutôt qu’un simple point, on peut faire :\n\nggplot(rp) +\n    geom_text(\n        aes(x = dipl_sup, y = cadres, label = commune)\n    )\n\n\n\n\nOn peut personnaliser l’apparence et la position du texte avec des arguments comme size, color, etc.\n\nggplot(rp) +\n    geom_text(\n        aes(x = dipl_sup, y = cadres, label = commune),\n        color = \"darkred\", size = 2\n    )\n\n\n\n\n\n\ngeom_label\ngeom_label est identique à geom_text, mais avec une présentation un peu différente.\n\nggplot(rp) +\n    geom_label(aes(x = dipl_sup, y = cadres, label = commune))\n\n\n\n\n\n\ngeom_density\ngeom_density permet d’afficher l’estimation de densité d’une variable numérique. Son usage est similaire à celui de geom_histogram.\nAinsi, si on veut afficher la densité de la répartition de la part des cadres dans les communes de notre jeu de données :\n\nggplot(rp) +\n    geom_density(aes(x = cadres))\n\n\n\n\nOn peut utiliser différents arguments pour ajuster le calcul de l’estimation de densité, parmi lesquels kernel et bw (voir la page d’aide de la fonction density pour plus de détails). bw (abbréviation de bandwidth, bande passante) permet de régler la “finesse” de l’estimation de densité, un peu comme le choix du nombre de classes dans un histogramme :\n\nggplot(rp) +\n    geom_density(aes(x = cadres), bw = 1)\n\n\n\n\n\n\ngeom_line\ngeom_line trace des lignes connectant les différentes observations entre elles. Il est notamment utilisé pour la représentation de séries temporelles. On passe à geom_line deux paramètres : x et y. Les observations sont alors connectées selon l’ordre des valeurs passées en x.\nComme il n’y a pas de données adaptées pour ce type de représentation dans notre jeu de données d’exemple, on va utiliser ici le jeu de données economics inclus dans ggplot2 et représenter l’évolution du taux de chômage aux États-Unis (variable unemploy) dans le temps (variable date) :\n\ndata(\"economics\")\neconomics\n\n# A tibble: 574 × 6\n   date         pce    pop psavert uempmed unemploy\n   &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n 1 1967-07-01  507. 198712    12.6     4.5     2944\n 2 1967-08-01  510. 198911    12.6     4.7     2945\n 3 1967-09-01  516. 199113    11.9     4.6     2958\n 4 1967-10-01  512. 199311    12.9     4.9     3143\n 5 1967-11-01  517. 199498    12.8     4.7     3066\n 6 1967-12-01  525. 199657    11.8     4.8     3018\n 7 1968-01-01  531. 199808    11.7     5.1     2878\n 8 1968-02-01  534. 199920    12.3     4.5     3001\n 9 1968-03-01  544. 200056    11.7     4.1     2877\n10 1968-04-01  544  200208    12.3     4.6     2709\n# ℹ 564 more rows\n\n\n\nggplot(economics) +\n    geom_line(aes(x = date, y = unemploy))"
  },
  {
    "objectID": "Seance2.html#mappages",
    "href": "Seance2.html#mappages",
    "title": "Séance 2",
    "section": "Mappages",
    "text": "Mappages\nUn mappage, dans ggplot2, est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données.\nCes mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic).\n\nExemples de mappages\nOn a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) dépend de la valeur des variables passées comme arguments x et y dans aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres)\n    )\n\n\n\n\nMais on peut ajouter d’autres mappages. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable. Ainsi, on peut vouloir colorer les points selon le département de la commune correspondante.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\nOn peut aussi faire varier la taille des points avec size. Ici, la taille dépend de la population totale de la commune :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)\n    )\n\n\n\n\nOn peut même associer la transparence des points à une variable avec alpha :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)\n    )\n\n\n\n\nChaque geom possède sa propre liste de mappages.\n\n\naes() or not aes() ?\nComme on l’a déjà vu, parfois on souhaite changer un attribut sans le relier à une variable : c’est le cas par exemple si on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"red\"\n    )\n\n\n\n\nPar contre, si on veut faire varier la couleur en fonction des valeurs prises par une variable, on réalise un mappage, et on doit donc placer l’attribut color à l’intérieur de aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\nOn peut mélanger attributs liés à une variable (mappage, donc dans aes()) et attributs constants (donc à l’extérieur). Dans l’exemple suivant, la taille varie en fonction de la variable pop_tot, mais la couleur est constante pour tous les points.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, size = pop_tot),\n        color = \"royalblue\"\n    )\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLa règle est donc simple mais très importante :\nSi on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit en-dehors de la fonction aes().\n\n\n\n\ngeom_bar et position\nUn des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une deuxième variable :\n\nggplot(rp) +\n    geom_bar(aes(x = departement, fill = pop_cl))\n\n\n\n\nL’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut l’argument vaut position = \"stack\" et elles sont donc “empilées”. Mais on peut préciser position = \"dodge\" pour les mettre côte à côte.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"dodge\"\n    )\n\n\n\n\nOu encore position = \"fill\" pour représenter non plus des effectifs, mais des proportions.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    )\n\n\n\n\nLà encore, on peut utiliser coord_flip() si on souhaite une visualisation avec des barres horizontales.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    ) +\n    coord_flip()"
  },
  {
    "objectID": "Seance2.html#représentation-de-plusieurs-geom",
    "href": "Seance2.html#représentation-de-plusieurs-geom",
    "title": "Séance 2",
    "section": "Représentation de plusieurs geom",
    "text": "Représentation de plusieurs geom\nOn peut représenter plusieurs geom simultanément sur un même graphique, il suffit de les ajouter à tour de rôle avec l’opérateur +.\nPar exemple, on peut superposer la position des points au-dessus d’un boxplot. On va pour cela ajouter un geom_point après avoir ajouté notre geom_boxplot.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_point(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand une commande ggplot2 devient longue, il peut être plus lisible de la répartir sur plusieurs lignes. Dans ce cas, il faut penser à placer l’opérateur + en fin de ligne, afin que R comprenne que la commande n’est pas complète et qu’il prenne en compte la suite.\n\n\nPour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_jitter(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\nPour simplifier un peu le code, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages).\n\nggplot(rp, aes(x = departement, y = maison)) +\n    geom_boxplot() +\n    geom_jitter(color = \"red\", alpha = 0.2)\n\n\n\n\nAutre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nEt on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_density2d(color = \"red\") +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nPlusieurs sources de données\nOn peut associer à différents geom des sources de données différentes. Supposons qu’on souhaite afficher sur un nuage de points les noms des communes de plus de 50000 habitants. On commencer par créer un tableau de données contenant uniquement ces communes à l’aide de la fonction filter.\n\ncom50 &lt;- filter(rp, pop_tot &gt;= 50000)\n\nOn fait ensuite le nuage de points comme précédemment :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2)\n\n\n\n\nPour superposer les noms de communes de plus de 50 000 habitants, on peut ajouter un geom_text, mais en spécifiant que les données proviennent du nouveau tableau com50 et non de notre tableau initial rp. On le fait en passant un argument data spécifique à geom_text :\n\nggplot(data = rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_text(\n        data = com50, aes(label = commune),\n        color = \"red\", size = 3\n    )\n\n\n\n\nAinsi, on obtient un graphique avec deux geom superposés, mais dont les données proviennent de deux tableaux différents."
  },
  {
    "objectID": "Seance2.html#faceting",
    "href": "Seance2.html#faceting",
    "title": "Séance 2",
    "section": "Faceting",
    "text": "Faceting\nLe faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives.\nPar exemple, on a vu qu’on peut représenter l’histogramme du pourcentage de cadres dans nos communes avec le code suivant :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres))\n\n\n\n\nOn souhaite comparer cette distribution de la part des cadres selon le département, et donc faire un histogramme pour chacun de ces départements. C’est ce que permettent les fonctions facet_wrap et facet_grid.\nfacet_wrap prend un paramètre de la forme vars(variable), où variable est le nom de la variable en fonction de laquelle on souhaite faire les différents graphiques. Ceux-ci sont alors affichés les uns à côté des autres et répartis automatiquement dans la page.\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_wrap(vars(departement))\n\n\n\n\nPour facet_grid, les graphiques sont disposés selon une grille. La fonction prend alors deux arguments, rows et cols, auxquels on passe les variables à afficher en ligne ou en colonne via la fonction vars().\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(rows = vars(departement))\n\n\n\n\nUn des intérêts du faceting dans ggplot2 est que tous les graphiques générés ont les mêmes échelles, ce qui permet une comparaison directe.\nEnfin, notons qu’on peut même faire du faceting sur plusieurs variables à la fois. On peut par exemple faire des histogrammes de la répartition de la part des cadres pour chaque croisement des variables departement et pop_cl :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(\n        rows = vars(departement), cols = vars(pop_cl)\n    )\n\n\n\n\nL’histogramme en haut à gauche représente la répartition du pourcentage de cadres parmi les communes de 2000 à 3000 habitants dans les Bouches-du-Rhône, etc."
  },
  {
    "objectID": "Seance2.html#scales",
    "href": "Seance2.html#scales",
    "title": "Séance 2",
    "section": "Scales",
    "text": "Scales\nOn a vu qu’avec ggplot2 on définit des mappages entre des attributs graphiques (position, taille, couleur, etc.) et des variables d’un tableau de données. Ces mappages sont définis, pour chaque geom, via la fonction aes().\nLes scales dans ggplot2 permettent de modifier la manière dont un attribut graphique va être relié aux valeurs d’une variable, et dont la légende correspondante va être affichée. Par exemple, pour l’attribut color, on pourra définir la palette de couleur utilisée. Pour size, les tailles minimales et maximales, etc.\nPour modifier une scale existante, on ajoute un nouvel élément à notre objet ggplot2 avec l’opérateur +. Cet élément prend la forme scale_&lt;attribut&gt;_&lt;type&gt;.\nVoyons tout de suite quelques exemples.\n\nscale_size\nSi on souhaite modifier les tailles minimales et maximales des objets quand on a effectué un mappage de type size, on peut utiliser la fonction scale_size et son argument range.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(range = c(0, 20))\n\n\n\n\nÀ comparer par exemple à :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(range = c(2, 8))\n\n\n\n\nOn peut ajouter d’autres paramètres à scale_size. Le premier argument est toujours le titre donné à la légende.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(\n        \"Population\",\n        range = c(0, 15)\n    )\n\n\n\n\nOn peut aussi définir manuellement les éléments de légende représentés.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +\n    scale_size(\n        \"Population\",\n        range = c(0, 15),\n        breaks = c(1000, 5000, 10000, 50000)\n    )\n\n\n\n\n\n\nscale_x, scale_y\nLes scales scale_x_&lt;type&gt; et scale_y_&lt;type&gt; modifient les axes x et y du graphique.\nscale_x_continuous et scale_y_continuous s’appliquent lorsque la variable x ou y est numérique (quantitative).\nC’est le cas de notre nuage de points croisant part de cadres et part de diplômés du supérieur.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres))\n\n\n\n\nComme on représente des pourcentages, on peut vouloir forcer les axes x et y à s’étendre des valeurs 0 à 100. On peut le faire en ajoutant un élément scale_x_continuous et un élément scale_y_continuous, et en utilisant leur argument limits.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_continuous(limits = c(0, 100)) +\n    scale_y_continuous(limits = c(0, 100))\n\n\n\n\nLà aussi, on peut modifier les étiquettes des axes en indiquant une chaîne de caractères en premier argument.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_continuous(\"Part des diplômés du supérieur (%)\", limits = c(0, 100)) +\n    scale_y_continuous(\"Part des cadres (%)\", limits = c(0, 100))\n\n\n\n\nOn peut utiliser scale_x_log10 et scale_y_log10 pour passer un axe à une échelle logarithmique.\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres)) +\n    scale_x_log10(\"Diplômés du supérieur\")\n\n\n\n\nscale_x_discrete et scale_y_discrete s’appliquent lorsque l’axe correspond à une variable discrète (qualitative). C’est le cas par exemple de l’axe des x dans un diagramme en barres.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    scale_x_discrete(\"Département\")\n\n\n\n\nL’argument limits de scale_x_discrete permet d’indiquer quelles valeurs sont affichées et dans quel ordre.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    scale_x_discrete(\"Département\", limits = c(\"Oise\", \"Lozère\", \"Rhône\"))\n\nWarning: Removed 150 rows containing non-finite values (`stat_count()`).\n\n\n\n\n\n\n\nscale_color, scale_fill\nCes scales permettent, entre autre, de modifier les palettes de couleur utilisées pour le dessin (color) ou le remplissage (fill) des éléments graphiques. Dans ce qui suit, pour chaque fonction scale_color présentée il existe une fonction scale_fill équivalente et avec en général les mêmes arguments.\n\nVariables quantitatives\nLe graphique suivant colore les points selon la valeur d’une variable numérique quantitative (ici la part de chômeurs) :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom))\n\n\n\n\nOn peut modifier les couleurs utilisées avec les arguments low et high de la fonction scale_color_gradient. Ici on souhaite que la valeur la plus faible soit blanche, et la plus élevée rouge :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_gradient(\"Taux de chômage\", low = \"white\", high = \"red\")\n\n\n\n\nOn peut aussi utiliser des palettes prédéfinies. L’une des plus populaires est la palette viridis, accessible en utilisant scale_color_viridis_c :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_viridis_c(\"Taux de chômage\")\n\n\n\n\nviridis propose également trois autres palettes, magma, inferno et plasma, accessibles via l’argument option :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_viridis_c(\"Taux de chômage\", option = \"plasma\")\n\n\n\n\nOn peut aussi utiliser scale_color_distiller, qui transforme une des palettes pour variable qualitative de scale_color_brewer en palette continue pour variable numérique :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +\n    scale_color_distiller(\"Taux de chômage\", palette = \"Spectral\")\n\n\n\n\nLa liste des palettes de scale_color_brewer est indiquée en fin de section suivante.\n\n\nVariables qualitatives\nSi on a fait un mappage avec une variable discrète (qualitative), comme ici avec le département :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement))\n\n\n\n\nUne première possibilité est de modifier la palette manuellement avec scale_color_manual et son argument values :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n    scale_color_manual(\n        \"Département\",\n        values = c(\"red\", \"#FFDD45\", rgb(0.1, 0.2, 0.6), \"darkgreen\", \"grey80\")\n    )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nL’exemple précédent montre plusieurs manières de définir manuellement des couleurs dans R :\n\nPar code hexadécimal : \"#FFDD45\"\nEn utilisant la fonction rgb et en spécifiant les composantes rouge, vert, bleu par des nombres entre 0 et 1 (et optionnellement une quatrième composante d’opacité, toujours entre 0 et 1) : rgb(0.1,0.2,0.6)\nEn donnant un nom de couleur : \"red\", \"darkgreen\"\n\nLa liste complète des noms de couleurs connus par R peut être obtenu avec la fonction colors(). Vous pouvez aussi retrouver en ligne la liste des couleurs et leur nom (PDF).\n\n\nIl est cependant souvent plus pertinent d’utiliser des palettes prédéfinies. Celles du site Colorbrewer, initialement prévues pour la cartographie, permettent une bonne lisibilité, et peuvent être adaptées pour certains types de daltonisme.\nCes palettes s’utilisent via la fonction scale_color_brewer, en passant le nom de la palette via l’argument palette. Par exemple, si on veut utiliser la palette Set1 :\n\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +\n    scale_color_brewer(\"Département\", palette = \"Set1\")\n\n\n\n\nLe graphique suivant, accessible via la fonction display.brewer.all(), montre la liste de toutes les palettes disponibles via scale_color_brewer. Elles sont réparties en trois familles : les palettes séquentielles (pour une variable quantitative), les palettes qualitatives, et les palettes divergentes (typiquement pour une variable quantitative avec une valeur de référence, souvent 0, et deux palettes continues distinctes pour les valeurs inférieures et pour les valeurs supérieures).\n\nRColorBrewer::display.brewer.all()\n\n\n\n\n\n\n\n\n\nIl existe d’autres méthodes pour définir les couleurs : pour plus d’informations on pourra se reporter à l’article de la documentation officielle sur ce sujet."
  },
  {
    "objectID": "Seance2.html#thèmes",
    "href": "Seance2.html#thèmes",
    "title": "Séance 2",
    "section": "Thèmes",
    "text": "Thèmes\nLes thèmes permettent de contrôler l’affichage de tous les éléments du graphique qui ne sont pas reliés aux données : titres, grilles, fonds, etc.\nIl existe un certain nombre de thèmes préexistants, par exemple le thème theme_bw :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme_bw()\n\n\n\n\nOu le thème theme_minimal :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme_minimal()\n\n\n\n\nOn peut cependant modifier manuellement les différents éléments. Par exemple, les fonctions ggtitle, xlab et ylab permettent d’ajouter ou de modifier le titre du graphique, ainsi que les étiquettes des axes x et y :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    ggtitle(\"Un bien bel histogramme\") +\n    xlab(\"Pourcentage de cadres\") +\n    ylab(\"Effectif\")\n\n\n\n\nLes éléments personnalisables étant nombreux, un bon moyen de se familiariser avec tous les arguments est sans doute l’addin RStudio ggThemeAssist. Pour l’utiliser il suffit d’installer le package du même nom, de sélectionner dans son script RStudio le code correspondant à un graphique ggplot2, puis d’aller dans le menu Addins et choisir ggplot Theme Assistant. Une interface graphique s’affiche alors permettant de modifier les différents éléments. Si on clique sur Done, le code sélectionné dans le script est alors automatiquement mis à jour pour correspondre aux modifications effectuées.\nCe qui permet d’obtenir très facilement des résultats extrêmement moches :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    theme(\n        panel.grid.major = element_line(\n            colour = \"dodgerblue\",\n            size = 0.5, linetype = \"dotdash\"\n        ), axis.title = element_text(\n            family = \"serif\",\n            size = 18, face = \"italic\", colour = \"white\"\n        ),\n        axis.text = element_text(\n            family = \"serif\",\n            size = 15, face = \"bold\"\n        ), axis.text.x = element_text(family = \"mono\"),\n        plot.title = element_text(family = \"serif\"),\n        legend.text = element_text(family = \"serif\"),\n        legend.title = element_text(family = \"serif\"),\n        panel.background = element_rect(fill = \"coral\"),\n        plot.background = element_rect(fill = \"blueviolet\")\n    )"
  },
  {
    "objectID": "Seance2.html#ladd-in-esquisse",
    "href": "Seance2.html#ladd-in-esquisse",
    "title": "Séance 2",
    "section": "L’add-in esquisse",
    "text": "L’add-in esquisse\nesquisse est un package développé notamment par Victor Perrier de dreamRs et qui fournit une interface graphique pour la construction de graphiques avec ggplot2.\nPour l’utiliser, il faut évidemment préalablement installer l’extension :\n\ninstall.packages(\"esquisse\")\n\nPour lancer l’interface, ouvrez le menu Addins dans la barre d’outils de RStudio, et cliquez sur ‘ggplot2’ builder3.\n\nUne fenêtre s’ouvre : la première étape consiste à choisir un data frame de votre environnement, et éventuellement à ne sélectionner que certaines de ses variables.\n Une fois le choix effectué, cliquez sur Validate imported data.\nL’interface principale s’affiche alors. La liste des variables du data frame apparaît en haut, et vous pouvez les faire glisser dans les zones X, Y, Fill, Color, Size et Facet pour créer des mappages. Le graphique se met automatiquement à jour.\n\nPar défaut, esquisse sélectionne le type de graphique le plus approprié selon la nature de vos variables. Mais vous pouvez choisir un autre type de graphique à l’aide de l’icône en haut à gauche, parmi onze disponibles (dont Auto):\n.\nEnfin, une série de menus en bas de l’interface vous permet de personnaliser les titres, les annotations (labels), la présentation ou de filtrer des valeurs de vos variables.\nQuand vous avez généré un graphique que vous souhaitez conserver, ouvrez le menu Export & code :\n\nVous y trouverez le code R correspondant au graphique actuellement affiché. Vous pouvez dès lors le copier pour le coller dans votre script, ou cliquer sur Insert code in script pour l’insérer directement dans votre script à l’endroit où se trouve votre curseur.\nesquisse ne propose pas (encore) tous les geom ou toutes les possibilités de ggplot2, mais ça peut être un outil très utile et pratique pour une exploration rapide de données ou lorsqu’on est un peu perdu dans la syntaxe et les fonctions de l’extension.\nPour plus d’informations, vous pouvez vous référer à la page du projet sur GitHub (en anglais)."
  },
  {
    "objectID": "Seance2.html#ressources",
    "href": "Seance2.html#ressources",
    "title": "Séance 2",
    "section": "Ressources",
    "text": "Ressources\nLa documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne.\nUne “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Cheatsheets &gt; Data visualization with ggplot2) ou en ligne.\nLes parties Data visualisation et Graphics for communication de l’ouvrage en ligne R for data science, de Hadley Wickham, sont une très bonne introduction à ggplot2.\nPlusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, toujours de Hadley Wickham, et le R Graphics Cookbook de Winston Chang.\nLe site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes.\nEnfin, si ggplot2 présente déjà un très grand nombre de fonctionnalités, il existe aussi un système d’extensions permettant d’ajouter des geom, des thèmes, etc. Le site ggplot2 extensions est une très bonne ressource pour les parcourir et les découvrir, notamment grâce à sa galerie."
  },
  {
    "objectID": "Seance2.html#exercices-1",
    "href": "Seance2.html#exercices-1",
    "title": "Séance 2",
    "section": "Exercices",
    "text": "Exercices\nPour les exercices qui suivent, on commence par charger les extensions nécessaires et les données du jeu de données rp2018. On crée alors un objet rp69 comprenant uniquement les communes du Rhône et de la Loire.\n\nlibrary(tidyverse)\nlibrary(questionr)\ndata(rp2018)\n\nrp69 &lt;- filter(rp2018, departement %in% c(\"Rhône\", \"Loire\"))\n\nExercice 1\nFaire un nuage de points croisant le pourcentage de sans diplôme (dipl_aucun) et le pourcentage d’ouvriers (ouvr).\nExercice 2\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers, avec les points en rouge et de transparence 0.2.\nExercice 3\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches.\nExercice 4\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes sous la forme d’un diagramme en bâtons.\nExercice 5\nFaire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Faire varier la couleur selon le département (departement).\nSur le même graphique, faire varier la taille des points selon la population totale de la commune (pop_tot).\nEnfin, toujours sur le même graphique, rendre les points transparents en plaçant leur opacité à 0.5.\nExercice 6\nReprésenter la répartition du pourcentage de propriétaires (variable proprio) selon la taille de la commune en classes (variable pop_cl) sous forme de boîtes à moustaches. Faire varier la couleur de remplissage (attribut fill) selon le département.\nExercice 7\nReprésenter la répartition du nombre de communes selon la taille de la commune en classes (variable pop_cl) sous forme de diagramme en bâtons empilés, avec une couleur différente selon le département.\nFaire varier la valeur du paramètre position pour afficher les barres les unes à côté des autres.\nChanger à nouveau la valeur du paramètre position pour représenter les proportions de communes de chaque département pour chaque catégorie de taille.\nExercice 8\nFaire un nuage de points représentant en abscisse le pourcentage de cadres (cadres) et en ordonnée le pourcentage de diplômés du supérieur (dipl_sup). Représenter ce nuage par deux graphiques différents selon le département en utilisant facet_grid.\nSur le même graphique, faire varier la taille des points selon la population totale de la communes (variable pop_tot) et rendre les points transparents.\nExercice 9\nFaire le nuage de points croisant pourcentage de chômeurs (chom) et pourcentage de sans diplôme. Y ajouter les noms des communes correspondant (variable commune), en rouge et en taille 2.5 :\nExercice 10\nDans le graphique précédent, n’afficher que le nom des communes ayant plus de 15% de chômage."
  },
  {
    "objectID": "Seance2.html#footnotes",
    "href": "Seance2.html#footnotes",
    "title": "Séance 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nVous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎\nIl est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎\nVous pouvez aussi lancer la commande esquisser::esquisse() dans la Console.↩︎"
  },
  {
    "objectID": "pptS2.html#pourquoi-travailler-sur-le-fait-migratoire",
    "href": "pptS2.html#pourquoi-travailler-sur-le-fait-migratoire",
    "title": "Powerpoint - Séance 2",
    "section": "Pourquoi travailler sur le fait migratoire",
    "text": "Pourquoi travailler sur le fait migratoire\n\nLe droit des étranger.es est surtout droit contre les étranger.es : les moyens dont les États se dotent pour contrôler l’entrée et la vie des étranger.es sur son territoire\nLe conflit entre la souveraineté Étatique et le droit des personnes pose un problème juridique parfois tranché grâce à la statistique. Proportionnalité du droit : les moyens de contrôle dérogatoires restent-ils légaux ?\nFabrication du droit de l’État lié à la conjoncture politique et la perception des flux migratoires\n\n\n\nConstruction d’un droit contre les étrangers plutôt que droit des étrangers, droit des États à contrôler les étrangers. Lien entre les décisions judiciaires et la perception du fait migratoire : puisque la souveraineté des États entre en conflit avec le droit des personnes, il y a une incertitude juridique sur le degré de contrôle légal et réalisable dans les faits, c’est-à-dire les moyens de coercion.\nÀ partir de quel seuil les flux migratoires deviennent « massifs », et assez importants pour adopter des procédés dérogatoires sans enfreindre le principe de proportionnalité ?\nFabrication du droit de l’État lié à la conjoncture politique et la perception des flux migratoires\nFabrication du droit de l’État lié aux usages sociaux des statistiques par ceux qui pratiquent et produisent le droit (jurisprudence, interprétation des constitutions internationales, traités, droits nationaux, respect des procédures, situation d’urgence ..)"
  },
  {
    "objectID": "pptS2.html#le-fait-migratoire-daprès-les-graphiques-de-françois-héran",
    "href": "pptS2.html#le-fait-migratoire-daprès-les-graphiques-de-françois-héran",
    "title": "Powerpoint - Séance 2",
    "section": "Le fait migratoire d’après les graphiques de François Héran",
    "text": "Le fait migratoire d’après les graphiques de François Héran\n\n\nLe graphique\n\nAnnées 1850/1871 : doublement, craintes très fortes des population allogènes alors qu’en proportion, ce n’est rien.\nFin XIXe, stagnation, grande crise, incidence directe des conditions économiques sur les flux migratoires.\nPremière Guerre Mondiale, données manquante (recensement tous les 5 ans). Appel massif aux étranger·es, plus seulement les voisin·es puisqu’on va chercher les Polonais·es (avant plutôt Belges, Allemand·es, Italien·nes, Suisses). Les charbonnages de France.\nCrise des années 30, reflux très important, renvoi de + de 100 000 polonais·es « manu militari »\nDébut années 50, les années de reconstruction et de rattrapage économique. 1974, stop à l’immigration de travail. Obsession de VGE avec les maghrébin·es, et d’autres haut·es fonctionnaires.\nDepuis 2000, la migration progresse de façon rapide et constante. Recensement tournant, estimation annuelle.\n\nInsister sur\n\nles deux dimensions et les deux échelles (avec une légende chacune) ainsi que les effets d’optiques : rappeler les valeurs chiffrées, ordre de grandeur\nsémiologie graphique : deux figurés, deux couleurs opposées avec cohérence des couleurs\nla forme même du graphique : ce sont des points reliés par des droites, soit une « linéarisation » des niveaux mesurés à intervalles fixes\nl’illusion de continuité : pour le coup, relative stabilité de la définition d’immigré·e, donc possible de remonter à longtemps\nles ruptures : données manquantes, changement de mode de collecte\nles légendes\nRevenir après sur concrètement, à quoi ressemble le tableau du recensement et quelles opérations on doit faire pour arriver à un tableau qui contient toutes les informations nécessaires?"
  },
  {
    "objectID": "pptS2.html#la-progression-mondiale",
    "href": "pptS2.html#la-progression-mondiale",
    "title": "Powerpoint - Séance 2",
    "section": "La progression mondiale",
    "text": "La progression mondiale"
  },
  {
    "objectID": "pptS2.html#les-titres-de-séjour",
    "href": "pptS2.html#les-titres-de-séjour",
    "title": "Powerpoint - Séance 2",
    "section": "Les titres de séjour",
    "text": "Les titres de séjour"
  },
  {
    "objectID": "pptS2.html#les-titres-de-séjours-familiaux",
    "href": "pptS2.html#les-titres-de-séjours-familiaux",
    "title": "Powerpoint - Séance 2",
    "section": "Les titres de séjours familiaux",
    "text": "Les titres de séjours familiaux"
  },
  {
    "objectID": "pptS2.html#les-données-du-recensement-de-la-population",
    "href": "pptS2.html#les-données-du-recensement-de-la-population",
    "title": "Powerpoint - Séance 2",
    "section": "Les données du recensement de la population",
    "text": "Les données du recensement de la population\n\n\n\n\nLa version anonymisée du recensement est en accès libre sur le site de l’INSEE. Plusieurs fichiers existent (niveau logement, niveau individu localisé à la région, au canton-ville) et censurent différents types d’information.\nLes données harmonisées entre 1968 et 2019 permettent de créer des séries longues beaucoup plus simplement qu’en compilant les différents recensements.\n\n\n\n\n\ndim(rp)\n\n[1] 51531264        4\n\nhead(rp, 20)\n\n    AN_RECENS POND REG_NAIS NATIO\n 1:      1968 1568       84   000\n 2:      1968   12       84   1ES\n 3:      1968   40       84   1IT\n 4:      1968    4       84   3DZ\n 5:      1968 1696       84   000\n 6:      1968    8       84   1ES\n 7:      1968   24       84   1IT\n 8:      1968   12       84   3DZ\n 9:      1968 1432       84   000\n10:      1968    4       84   1ES\n11:      1968   28       84   1IT\n12:      1968    4       84   1PT\n13:      1968   16       84   3DZ\n14:      1968 1604       84   000\n15:      1968   16       84   1ES\n16:      1968   32       84   1IT\n17:      1968    4       84   1PT\n18:      1968    4       84   3DZ\n19:      1968    4       84   3TN\n20:      1968 1616       84   000"
  },
  {
    "objectID": "pptS2.html#opérations-nécessaires-pour-construire-les-graphiques-dévolution-du-nombre-et-de-la-proportion-dimmigré.es",
    "href": "pptS2.html#opérations-nécessaires-pour-construire-les-graphiques-dévolution-du-nombre-et-de-la-proportion-dimmigré.es",
    "title": "Powerpoint - Séance 2",
    "section": "Opérations nécessaires pour construire les graphiques d’évolution du nombre et de la proportion d’immigré.es",
    "text": "Opérations nécessaires pour construire les graphiques d’évolution du nombre et de la proportion d’immigré.es\n\nCréer une variable qui renseigne le statut d’immigration\nCompter pour chaque année le nombre d’immigré.es (effectifs)\nDiviser le nombre d’immigré.es par le nombre de français.es à une année donnée\nConstruire un graphique avec un abscisse pour les années et une ordonnée pour le nombre ou la proportion\nPlacer les points et les relier avec des traits\nAjouter des légendes"
  },
  {
    "objectID": "pptS2.html#créer-une-variable-dimmigration",
    "href": "pptS2.html#créer-une-variable-dimmigration",
    "title": "Powerpoint - Séance 2",
    "section": "Créer une variable d’immigration",
    "text": "Créer une variable d’immigration"
  },
  {
    "objectID": "pptS2.html#calculer-les-effectifs",
    "href": "pptS2.html#calculer-les-effectifs",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les effectifs",
    "text": "Calculer les effectifs\n\n\n\n## Obtenir les effectifs absolus\ntab_eff &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) # Compte des effectifs pondérés\n\n\n\ntab_eff\n\n    AN_RECENS IMMI        n\n 1:      1968    0 46416268\n 2:      1968    1  3238284\n 3:      1975    0 48711970\n 4:      1975    1  3887460\n 5:      1982    0 50258576\n 6:      1982    1  4037036\n 7:      1990    0 53855423\n 8:      1990    1  4222237\n 9:      1999    0 55769985\n10:      1999    1  4374266\n11:      2008    0 58588985\n12:      2008    1  5347567\n13:      2013    0 59729778\n14:      2013    1  5835094\n15:      2019    0 60469081\n16:      2019    1  6515809"
  },
  {
    "objectID": "pptS2.html#calculer-les-pourcentages---1",
    "href": "pptS2.html#calculer-les-pourcentages---1",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les pourcentages - 1",
    "text": "Calculer les pourcentages - 1\n\n\n\n## Obtenir les pourcentages\ntab_p &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) %&gt;% # Compte des effectifs pondérés\n  group_by(AN_RECENS) %&gt;% # Opération par année\n  mutate(p = n/sum(n)) %&gt;% # Part dans la population\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde qu'une ligne sur deux\n  select(-IMMI) # On enlève la colonne immigration\n\n\n\ntab_p\n\n    AN_RECENS IMMI        n          p\n 1:      1968    0 46416268 0.93478374\n 2:      1968    1  3238284 0.06521626\n 3:      1975    0 48711970 0.92609312\n 4:      1975    1  3887460 0.07390688\n 5:      1982    0 50258576 0.92564710\n 6:      1982    1  4037036 0.07435290\n 7:      1990    0 53855423 0.92730015\n 8:      1990    1  4222237 0.07269985\n 9:      1999    0 55769985 0.92727042\n10:      1999    1  4374266 0.07272958\n11:      2008    0 58588985 0.91636135\n12:      2008    1  5347567 0.08363865\n13:      2013    0 59729778 0.91100274\n14:      2013    1  5835094 0.08899726\n15:      2019    0 60469081 0.90272718\n16:      2019    1  6515809 0.09727282"
  },
  {
    "objectID": "pptS2.html#calculer-les-pourcentages---2",
    "href": "pptS2.html#calculer-les-pourcentages---2",
    "title": "Powerpoint - Séance 2",
    "section": "Calculer les pourcentages - 2",
    "text": "Calculer les pourcentages - 2\n\n\n\ntab_p &lt;-\n  rp %&gt;% # Opérateur PIPE\n  mutate( # Fonction pour créer une variable\n    IMMI = # Nom de la variable\n      ifelse(NATIO != \"000\" & REG_NAIS == \"99\", # Condition\n             \"Immigré.e\", # Valeur si la conditin est vérifiée\n             \"Pas immigré.e\") # Valeur si la condition n'est pas vérifiée\n  ) %&gt;%\n  count(AN_RECENS, IMMI, wt = POND) %&gt;% # Compte des effectifs pondérés\n  group_by(AN_RECENS) %&gt;% # Opération par année\n  mutate(p = n/sum(n)) %&gt;% # Part dans la population\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde qu'une ligne sur deux\n  select(-IMMI) # On enlève la colonne immigration\n\n\n\ntab_p\n\n   AN_RECENS       n          p\n1:      1968 3238284 0.06521626\n2:      1975 3887460 0.07390688\n3:      1982 4037036 0.07435290\n4:      1990 4222237 0.07269985\n5:      1999 4374266 0.07272958\n6:      2008 5347567 0.08363865\n7:      2013 5835094 0.08899726\n8:      2019 6515809 0.09727282"
  },
  {
    "objectID": "pptS2.html#construction-graphique",
    "href": "pptS2.html#construction-graphique",
    "title": "Powerpoint - Séance 2",
    "section": "Construction graphique",
    "text": "Construction graphique"
  },
  {
    "objectID": "Seance1.html",
    "href": "Seance1.html",
    "title": "Séance 1",
    "section": "",
    "text": "R Studio fonctionne en complément du logiciel de programmation R. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts.\n\n\n\n\nL’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap.\n\n\n\n\nNous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”.\n\n\n\nLes deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML.\n\n\n\n\n\n\n\nPour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre1 :\n [1] 4\n\n\n\n\n\n\nNous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur2.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)\n\n\n\n\n\nR étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante.\n\n\n\nExercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance1.html#les-4-panneaux-de-linterface",
    "href": "Seance1.html#les-4-panneaux-de-linterface",
    "title": "Séance 1",
    "section": "",
    "text": "L’interface est organisée en quatre grandes zones. La zone en bas à gauche se nomme la Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui.\nDans la console, la ligne commençant par le caractère &gt; est appelée l’invite de commande (ou prompt en anglais). Si le curseur y clignote, cela signifie que R est disponible et en attente de votre prochaine instruction. Vous pouvez y taper la commande : 2 + 2 et appuyer sur Entrée.\n\n\n\nLorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n10+2\n10 + 2\n10       +       2\nQuand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut ↑ et vers le bas ↓ de votre clavier pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée.\nEnfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe +.\n4 *\n+\nCela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap."
  },
  {
    "objectID": "Seance1.html#les-scripts",
    "href": "Seance1.html#les-scripts",
    "title": "Séance 1",
    "section": "",
    "text": "Nous n’allons pas utiliser R en saisissant des commandes directement dans la console. Les commandes vont être regroupées dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats.\nLe texte que vous lisez se situe dans la zone réservée aux scripts. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script.\nPour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup.\nOn peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save.\nLes scripts des cours ne sont pas dans le format .R qui contient uniquement des commandes R. Ils sont adaptés au format Quarto dont l’extension est .Qmd. Ce format permet de combiner du texte et du code en délimitant des blocs de code (code chunks). Deux modes d’affichages sont disponibles, l’affichage source qui a la même apparence qu’un code .R classique, et l’affichage visual qui ressemble à un logiciel de traitement de texte classique.\nLe format Quarto permet aussi d’utiliser d’autres langages que R comme Latex ou Python. Le rectangle gris ci-dessous correspond à un bloc de code auquel on ajoute l’en-tête {r} pour spécifier le langage que Quarto devra utiliser. Le code peut être lancé de la même façon qu’un script R (Ctrl + Entrée). Vous pouvez aussi cliquer sur le triangle vert en haut à droite pour lancer l’intégralité du bloc de code. Cela évite de devoir sélectionner toutes les lignes qu’on veut lancer ensemble.\n\n2+2\n\n[1] 4\n\n4+4\n\n[1] 8\n\n\nLe résultat apparaît par défaut en bas du bloc de code. Il est possible de demander à R d’afficher les résultats dans la console comme dans un script .R. Il suffit d’aller dans les paramètres (petite roue crantée dans la partie haute de la zone du script) pour sélectionner “Chunk Output in Console”."
  },
  {
    "objectID": "Seance1.html#lenvironnement-et-lespace-multifonction",
    "href": "Seance1.html#lenvironnement-et-lespace-multifonction",
    "title": "Séance 1",
    "section": "",
    "text": "Les deux panneaux latéraux sont l’environnement le navigateur.\n\nL’environnement est un espace de stockage temporaire, c’est là où seront stockées les données que vous allez importer dans le logiciel ainsi que les objets que vous allez créer.\nL’espace multifonction a plusieurs onglets :\n\nL’onglet Files est un explorateur de fichiers comme Windows en propose un. En général, on créer un dossier quelque part dans ses documents (ici c’est un cloud donc c’est un dossier en ligne) où seront stocker les scripts, les données et les sorties (graphiques, tableaux) dans des dossiers séparés. Créer un projet Rstudio, qui sera un fichier .Rprojet, permettra au logiciel de savoir que vous voulez travailler à partir de ce dossier où vous avez tout centralisé. L’intérêt est de pouvoir travailler sur plusieurs projets en même temps et simplement ouvrir le projet sur lequel vous voulez travailler pour que tout soit déjà prêt.\nL’onglet Plot permettra d’afficher les graphiques dans le logiciel.\nL’onglet Packages présente la librairie des packages. Un package, c’est un outil qui ajoute à R comme on aujouterait une extension sur un navigateur. Ils sont généralement développés par la communauté et ils permettent d’importer des fonctions additionnelles à celles implémentées de base dans R.\nL’onglet Help correspond à la documentation. Il sera indispensable pour utiliser les fonctions de R puisque c’est dans ces aides qu’on sait ce que fait une fonction et comment l’utiliser.\nL’onglet Viewer complète l’onglet Plot, il permet d’afficher des sorties comme des tableaux HTML."
  },
  {
    "objectID": "Seance1.html#objets",
    "href": "Seance1.html#objets",
    "title": "Séance 1",
    "section": "",
    "text": "Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche.\nPrenons tout de suite un exemple.\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’un objet, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre objet x contient bien la valeur 2.\nOn peut évidemment réutiliser cet objet dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant d’objets qu’on le souhaite.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite).\n\n\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\"\n\n\n\n\n\nImaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien :\n\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n[1] 167.4\n\n\nCette manière de faire n’est clairement pas pratique du tout. On va donc plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\ndiplome[1]\n\n[1] \"CAP\"\n\ndiplome[4]\n\n[1] \"CAP\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre1 :\n [1] 4"
  },
  {
    "objectID": "Seance1.html#fonctions",
    "href": "Seance1.html#fonctions",
    "title": "Séance 1",
    "section": "",
    "text": "Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur2.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(x = tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide.\n\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\nmean(tailles)\nmean(poids)\n\nimc &lt;- poids / (tailles / 100) ^ 2\nmin(imc)\nmax(imc)\n\n\n\n\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)"
  },
  {
    "objectID": "Seance1.html#sec-packages",
    "href": "Seance1.html#sec-packages",
    "title": "Séance 1",
    "section": "",
    "text": "R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande :\n\ninstall.packages(\"questionr\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante :\n\nlibrary(questionr)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme :\n\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(questionr)\n\nSi vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante."
  },
  {
    "objectID": "Seance1.html#exercices",
    "href": "Seance1.html#exercices",
    "title": "Séance 1",
    "section": "",
    "text": "Exercice 1\nConstruire un vecteur x qui contient les valeurs 120, 134, 256, 12\n\nx &lt;- c(120, 134, 256, 12)\n\nUtiliser ce vecteur x pour générer les deux vecteurs c(220, 234, 356, 112) et c(240, 268, 512, 24)\n\nx + 100\n\n[1] 220 234 356 112\n\nx * 2\n\n[1] 240 268 512  24\n\n\nExercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n# Réponse\nconjoint1 + conjoint2\n\n[1] 2650 3050 3440 2100\n\n(conjoint1 + conjoint2) / 2\n\n[1] 1325 1525 1720 1050\n\nrev_men &lt;- conjoint1 + conjoint2\nrev_men/2\n\n[1] 1325 1525 1720 1050\n\n\nExercice 3\nDans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\n\n# Réponse\nmin(conjoint1)\n\n[1] 1180\n\nmax(conjoint1)\n\n[1] 2100\n\nrange(conjoint1)\n\n[1] 1180 2100\n\n\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\n# Données\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n# Réponse\nmin(conjoint1, na.rm = T)\n\n[1] 1180\n\n\nExercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\n# Données\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\n\n# Réponse\nmean(temperature)\n\n[1] 12.5\n\n\nCalculer la quantité totale de précipitations sur l’année.\n\n# Réponse\nsum(precipitations)\n\n[1] 831.9\n\n\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations) \n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2"
  },
  {
    "objectID": "Seance1.html#jeu-de-données-dexemple",
    "href": "Seance1.html#jeu-de-données-dexemple",
    "title": "Séance 1",
    "section": "Jeu de données d’exemple",
    "text": "Jeu de données d’exemple\nDans cette partie nous allons utiliser un jeu de données présent dans l’extension questionr. L’extension est déjà installée sur le service R Studio du SSP Cloud, il faudrait autrement l’installer en lançant la commande install.packages(\"questionr\") . Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) :\n\nlibrary(questionr)\n\nL’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension.\nLe jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. La commande data permet d’accéder aux données contenues dans le package. En temps normal et en dehors de cet exemple pédagogique, vous aurez à importer des fichiers stocker sur votre propre ordinateur avec une commande du type read_csv2(\"chemin du fichier/fichier.csv\"). l\n\n# Pour éviter d'encombrer l'environnement de travail, on le vide avant de charger les données\n# On vide l'environnement à l'aide de la balayette située en haut de l'environnement\n# Ou à l'aide de la fonction rm()\nrm(list = ls())\n\n# Chargement des données\ndata(hdv2003)\n\nUn tableau de données apparaît maintenant dans votre environnement. C’est un objet comme l’étaient les vecteurs étudiés plus haut et cet objet est appelé hdv2003 ."
  },
  {
    "objectID": "Seance1.html#tableau-de-données-data-frame",
    "href": "Seance1.html#tableau-de-données-data-frame",
    "title": "Séance 1",
    "section": "Tableau de données (data frame)",
    "text": "Tableau de données (data frame)\nUn data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel.\nSi on se contente d’exécuter le nom de notre tableau de données R va, comme à son habitude, nous l’afficher dans la console (ou sous le bloc de code si vous n’avez pas modifié la zone de sortie).\n\nhdv2003\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n2  2  23 Femme                                                 &lt;NA&gt; 9738.396\n3  3  59 Homme                    Derniere annee d'etudes primaires 3994.102\n4  4  34 Homme Enseignement superieur y compris technique superieur 5731.662\n5  5  71 Femme                    Derniere annee d'etudes primaires 4329.094\n                  occup     qualif freres.soeurs clso\n1 Exerce une profession    Employe             8  Oui\n2       Etudiant, eleve       &lt;NA&gt;             2  Oui\n3 Exerce une profession Technicien             2  Non\n4 Exerce une profession Technicien             1  Non\n5              Retraite    Employe             0  Oui\n                        relig                     trav.imp    trav.satisf\n1 Ni croyance ni appartenance                Peu important Insatisfaction\n2 Ni croyance ni appartenance                         &lt;NA&gt;           &lt;NA&gt;\n3 Ni croyance ni appartenance Aussi important que le reste      Equilibre\n4  Appartenance sans pratique Moins important que le reste   Satisfaction\n5         Pratiquant regulier                         &lt;NA&gt;           &lt;NA&gt;\n  hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1       Non        Non          Non     Oui    Non    Non   Non         0\n2       Non        Non          Non     Non    Non    Oui   Oui         1\n3       Non        Non          Non     Non    Non    Non   Oui         0\n4       Non        Non          Non     Oui    Oui    Oui   Oui         2\n5       Non        Non          Non     Non    Non    Non   Non         3\n [ reached 'max' / getOption(\"max.print\") -- omitted 1995 rows ]\n\n\nUne autre manière d’afficher le contenu du tableau est de cliquer sur le nom de l’objet dans l’onglet Environment, ou d’utiliser la fonction View :\n\nView(hdv2003)\n\nIl est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille3.\nUn data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire :\n\nd &lt;- hdv2003\n\nce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite.\n\nStructure du tableau\nUn tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau.\n\nnrow(d)\n\n[1] 2000\n\n\n\nncol(d)\n\n[1] 20\n\n\nLa fonction dim renvoie ses dimensions, donc les deux nombres précédents.\n\ndim(d)\n\n[1] 2000   20\n\n\nLa fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables.\n\nnames(d)\n\n [1] \"id\"            \"age\"           \"sexe\"          \"nivetud\"      \n [5] \"poids\"         \"occup\"         \"qualif\"        \"freres.soeurs\"\n [9] \"clso\"          \"relig\"         \"trav.imp\"      \"trav.satisf\"  \n[13] \"hard.rock\"     \"lecture.bd\"    \"peche.chasse\"  \"cuisine\"      \n[17] \"bricol\"        \"cinema\"        \"sport\"         \"heures.tv\"    \n\n\nEnfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type et affiche les premières valeurs.\n\nstr(d)\n\n'data.frame':   2000 obs. of  20 variables:\n $ id           : int  1 2 3 4 5 6 7 8 9 10 ...\n $ age          : int  28 23 59 34 71 35 60 47 20 28 ...\n $ sexe         : Factor w/ 2 levels \"Homme\",\"Femme\": 2 2 1 1 2 2 2 1 2 1 ...\n $ nivetud      : Factor w/ 8 levels \"N'a jamais fait d'etudes\",..: 8 NA 3 8 3 6 3 6 NA 7 ...\n $ poids        : num  2634 9738 3994 5732 4329 ...\n $ occup        : Factor w/ 7 levels \"Exerce une profession\",..: 1 3 1 1 4 1 6 1 3 1 ...\n $ qualif       : Factor w/ 7 levels \"Ouvrier specialise\",..: 6 NA 3 3 6 6 2 2 NA 7 ...\n $ freres.soeurs: int  8 2 2 1 0 5 1 5 4 2 ...\n $ clso         : Factor w/ 3 levels \"Oui\",\"Non\",\"Ne sait pas\": 1 1 2 2 1 2 1 2 1 2 ...\n $ relig        : Factor w/ 6 levels \"Pratiquant regulier\",..: 4 4 4 3 1 4 3 4 3 2 ...\n $ trav.imp     : Factor w/ 4 levels \"Le plus important\",..: 4 NA 2 3 NA 1 NA 4 NA 3 ...\n $ trav.satisf  : Factor w/ 3 levels \"Satisfaction\",..: 2 NA 3 1 NA 3 NA 2 NA 1 ...\n $ hard.rock    : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ lecture.bd   : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 1 1 1 1 ...\n $ peche.chasse : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 1 1 1 2 2 1 1 ...\n $ cuisine      : Factor w/ 2 levels \"Non\",\"Oui\": 2 1 1 2 1 1 2 2 1 1 ...\n $ bricol       : Factor w/ 2 levels \"Non\",\"Oui\": 1 1 1 2 1 1 1 2 1 1 ...\n $ cinema       : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 1 2 1 2 1 1 2 2 ...\n $ sport        : Factor w/ 2 levels \"Non\",\"Oui\": 1 2 2 2 1 2 1 1 1 2 ...\n $ heures.tv    : num  0 1 0 2 3 2 2.9 1 2 2 ...\n\n\n\n\nAccéder aux variables d’un tableau\nUne opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape :\n\nd$sexe\n\n  [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme Homme\n [13] Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme Femme Femme\n [25] Femme Homme Femme Homme Homme Homme Homme Homme Homme Homme Femme Femme\n [37] Homme Femme Femme Homme Femme Homme Homme Femme Femme Homme Femme Femme\n [49] Femme Femme Homme Femme Homme Femme Homme Femme Femme Femme Homme Femme\n [61] Femme Homme Homme Homme Homme Femme Homme Homme Femme Femme Homme Homme\n [73] Femme Femme Femme Femme Homme Femme Femme Femme Femme Femme Femme Homme\n [85] Homme Femme Homme Homme Homme Homme Homme Femme Homme Femme Femme Femme\n [97] Homme Homme Femme Femme\n [ reached getOption(\"max.print\") -- omitted 1900 entries ]\nLevels: Homme Femme\n\n\nR va afficher l’ensemble des valeurs de la variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment.\nLa fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères.\nSi on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail.\n\nhead(d$age)\n\n[1] 28 23 59 34 71 35\n\n\n\ntail(d$age)\n\n[1] 46 45 46 24 24 66\n\n\nLe deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher.\n\n\nCréer une nouvelle variable\nOn peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur.\nPar exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé.\n\nhead(d$heures.tv)\n\n[1] 0 1 0 2 3 2\n\n\nOn peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée convertie en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante :\n\nd$minutes.tv &lt;- d$heures.tv * 60\n\nOn peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau.\n\nhead(d$minutes.tv)\n\n[1]   0  60   0 120 180 120"
  },
  {
    "objectID": "Seance1.html#analyse-univariée",
    "href": "Seance1.html#analyse-univariée",
    "title": "Séance 1",
    "section": "Analyse univariée",
    "text": "Analyse univariée\nOn a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $.\nSi on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.).\n\nAnalyser une variable quantitative\nUne variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv).\n\nIndicateurs de centralité\nCaractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent.\nPour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range.\n\nmin(d$age)\n\n[1] 18\n\nmax(d$age)\n\n[1] 97\n\nrange(d$age)\n\n[1] 18 97\n\n\nOn peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean.\n\nmean(d$age)\n\n[1] 48.157\n\n\nIl existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median.\n\nmedian(d$age)\n\n[1] 48\n\n\nUne différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2019, le salaire net moyen des salariés à temps plein dans le secteur privé en France était de 2424 euros, tandis que le salaire net médian n’était que de 1940 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut.\n\n\nIndicateurs de dispersion\nLes indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées.\nL’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations :\n\nmax(d$age) - min(d$age)\n\n[1] 79\n\n\nLes indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation).\n\nvar(d$age)\n\n[1] 287.0249\n\n\n\nsd(d$age)\n\n[1] 16.94181\n\n\nPlus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées.\nUne autre manière de mesurer la dispersion est de calculer les quartiles :\n\nle premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus\nle deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane)\nle troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus\n\nOn peut les calculer avec la fonction quantile :\n\n## Premier quartile\nquantile(d$age, prob = 0.25)\n\n25% \n 35 \n\n\n\n## Troisième quartile\nquantile(d$age, prob = 0.75)\n\n75% \n 60 \n\n\nquantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc.\nNotons enfin que la fonction summary permet d’obtenir d’un seul coup plusieurs indicateurs classiques :\n\nsummary(d$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  18.00   35.00   48.00   48.16   60.00   97.00 \n\n\n\n\n\nAnalyser une variable qualitative\nUne variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)…\nÀ noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs.\n\nTri à plat\nL’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table.\n\ntable(d$sexe)\n\n\nHomme Femme \n  899  1101 \n\n\nCe tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes.\n\ntable(d$qualif)\n\n\n      Ouvrier specialise         Ouvrier qualifie               Technicien \n                     203                      292                       86 \nProfession intermediaire                    Cadre                  Employe \n                     160                      260                      594 \n                   Autre \n                      58 \n\n\nUn tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif.\n\ntab &lt;- table(d$qualif)\nsort(tab)\n\n\n                   Autre               Technicien Profession intermediaire \n                      58                       86                      160 \n      Ouvrier specialise                    Cadre         Ouvrier qualifie \n                     203                      260                      292 \n                 Employe \n                     594 \n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$qualif, useNA = \"always\").\n\n\nÀ noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles.\n\nsummary(d$qualif)\n\n      Ouvrier specialise         Ouvrier qualifie               Technicien \n                     203                      292                       86 \nProfession intermediaire                    Cadre                  Employe \n                     160                      260                      594 \n                   Autre                     NA's \n                      58                      347"
  },
  {
    "objectID": "Seance1.html#les-classes-de-vecteur",
    "href": "Seance1.html#les-classes-de-vecteur",
    "title": "Séance 1",
    "section": "Les classes de vecteur",
    "text": "Les classes de vecteur\nLes vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent.\nOn a ainsi des vecteurs de type integer ou double, qui contiennent respectivement des nombres entiers ou décimaux :\n\nlibrary(questionr)\ndata(hdv2003)\ntypeof(hdv2003$age)\n\n[1] \"integer\"\n\n\n\ntypeof(hdv2003$heures.tv)\n\n[1] \"double\"\n\n\nDes vecteurs de type character, qui contiennent des chaînes de caractères :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\ntypeof(vec)\n\n[1] \"character\"\n\n\nEt des vecteurs de type logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE).\n\nvec &lt;- c(TRUE, FALSE, FALSE, TRUE)\ntypeof(vec)\n\n[1] \"logical\"\n\n\nOn peut convertir un vecteur d’un type en un autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA.\n\nx &lt;- c(\"1\", \"2.35\", \"8.2e+03\", \"foo\")\nas.numeric(x)\n\nWarning: NAs introduced by coercion\n\n\n[1]    1.00    2.35 8200.00      NA\n\ny &lt;- 2:6\nas.character(y)\n\n[1] \"2\" \"3\" \"4\" \"5\" \"6\"\n\n\nOn peut sélectionner certains éléments d’un vecteur à l’aide de l’opérateur []. La manière la plus simple est d’indiquer la position des éléments qu’on veut sélectionner :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[c(1, 3)]\n\n[1] \"Jaune\" \"Rouge\"\n\n\nLa sélection peut aussi être utilisée pour modifier certains éléments d’un vecteur, par exemple :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec[2] &lt;- \"Violet\"\nvec\n\n[1] \"Jaune\"  \"Violet\" \"Rouge\"  \"Vert\""
  },
  {
    "objectID": "Seance1.html#sec-tests",
    "href": "Seance1.html#sec-tests",
    "title": "Séance 1",
    "section": "Tests et comparaison",
    "text": "Tests et comparaison\nUn test est une opération logique de comparaison qui renvoie vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur.\nParmi les opérateurs de comparaison disponibles, on trouve notamment :\n\n== qui teste l’égalité\n!= qui teste la différence\n&gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité\n%in% qui teste l’appartenance à un ensemble de valeurs\n\nExemple le plus simple :\n\n2 == 3\n\n[1] FALSE\n\n\n\n2 != 3\n\n[1] TRUE\n\n\nExemple appliqué à un vecteur :\n\nx &lt;- 1:10\nx &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nOn peut combiner plusieurs tests avec les opérateurs logiques et (&) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6 inclus, on peut faire :\n\nx &gt;= 3 & x &lt;= 6\n\n [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nSi on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec == \"Jaune\" | vec == \"Vert\"\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nÀ noter que dans ce cas, on peut utiliser l’opérateur %in%4, qui teste si une valeur fait partie des éléments d’un vecteur :\n\nvec %in% c(\"Jaune\", \"Vert\")\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, si on souhaite tester si une valeur x est inconnue (ou ‘manquante’), c’est-à-dire si elle est codée NA (Not Available), faire le test x == NA ne donnera pas le résultat escompté. En effet, fidèle à sa réputation de rigueur informaticienne, pour R NA == NA ne vaut pas TRUE mais… NA (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).\nPour tester si une valeur est inconnue (NA), il faut utiliser la fonction dédiée is.na et faire is.na(x). Cependant, par convention, NA %in% NA vaut TRUE.\n\n\nEnfin, on peut inverser un test avec l’opérateur non (!) :\n\n!(vec %in% c(\"Jaune\", \"Vert\"))\n\n[1] FALSE FALSE  TRUE FALSE"
  },
  {
    "objectID": "Seance1.html#footnotes",
    "href": "Seance1.html#footnotes",
    "title": "Séance 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEt permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎\nc est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎\nLa seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎\nPour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎"
  },
  {
    "objectID": "rappel_S1S2.html",
    "href": "rappel_S1S2.html",
    "title": "Rappel avant la troisième séance",
    "section": "",
    "text": "La deuxième séance a été consacrée au recodage et à la visualisation de données. Nous sommes revenu.es sur les graphiques présentés par François Héran pour reconstituer le passage des données brutes, le recensement, aux représentations graphiques. Voici un résumé des éléments avec lesquels il faut être familier.e pour la troisième séance."
  },
  {
    "objectID": "rappel_S1S2.html#les-bases-de-la-première-séance",
    "href": "rappel_S1S2.html#les-bases-de-la-première-séance",
    "title": "Rappel avant la troisième séance",
    "section": "Les bases de la première séance",
    "text": "Les bases de la première séance\nL’essentiel de l’analyse des données repose sur la transformation de tableaux de données. Les lignes représentent des individus statistiques (qui peuvent être des personnes, des ménages, ou d’autres unités enquêtées). Les colonnes sont des variables numériques ou catégorielles.\nOn prend ici l’exemple du recensement de la population restreint à la ville de Lyon en 2009 et 2019. Lancer le bloc de code suivant sans se soucier du code ni du message retourné par R.\n\n# Ne pas tenir compte de ces lignes, c'est le chargement des données\nrp &lt;- aws.s3::s3read_using(FUN = data.table::fread,\n                           object = \"/diffusion/RP_LYON_2009_2019.csv\",\n                           bucket = \"aubinpoissonnier\",\n                           opts = list(\"region\" = \"\"))\n\nOn appelle les colonnes des tableaux de données des vecteurs car ce sont des suites de valeurs (la valeur de la variable pour l’individu 1, pour l’individu 2 etc). Une fonction s’écrit sous la forme nom_fonction(). On peut utiliser l’onglet “Help” pour connaître les différents arguments ou paramètres d’une fonction. On sépare les arguments des fonctions par des virgules s’il y en a plusieurs. Il faut toujours veiller à fermer les parenthèses. La fonction str pour structure résume toutes les colonnes du tableau. Elle a un seul argument, l’objet qu’on veut décrire (ici le tableau). La fonction head renvoie les premières lignes du tableau, elle peut prendre un deuxième argument pour choisir le nombre de lignes.\n\n# Ici, rp correspond au tableau de données du rencesement\nstr(rp)\n\nClasses 'data.table' and 'data.frame':  377833 obs. of  11 variables:\n $ id    : int  1 1 1 1 1 1 1 1 1 1 ...\n $ ARM   : int  69388 69388 69388 69384 69383 69388 69384 69383 69383 69383 ...\n $ IPONDI: num  1.178 1.178 1.178 2.965 0.956 ...\n $ CS1   : int  8 3 8 8 8 4 5 8 4 6 ...\n $ IMMI  : int  2 2 2 1 2 2 2 2 2 2 ...\n $ SEXE  : int  1 2 1 2 1 1 2 1 2 1 ...\n $ AGEREV: int  14 43 11 85 23 28 50 23 23 21 ...\n $ NPERR : int  3 3 3 1 1 1 1 2 2 1 ...\n $ NBPI  : int  3 3 3 4 1 1 2 1 1 3 ...\n $ LPRM  : chr  \"3\" \"1\" \"3\" \"1\" ...\n $ annee : int  2019 2019 2019 2019 2019 2019 2019 2019 2019 2019 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n# Deux arguments indiqués de manière implicite\nhead(rp, 10)\n\n    id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee\n 1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019\n 2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019\n 3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019\n 4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019\n 5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019\n 6:  1 69388 1.0714436   4    2    1     28     1    1    1  2019\n 7:  1 69384 2.6176763   5    2    2     50     1    2    1  2019\n 8:  1 69383 3.0192726   8    2    1     23     2    1    1  2019\n 9:  1 69383 3.0192726   4    2    2     23     2    1    2  2019\n [ reached getOption(\"max.print\") -- omitted 1 row ]\n\n# Ce qui est équivalent à la manière explicite\n# x = correspond à l'argument \"objet sur lequel j'applique la fonction\"\n# n = correspond à l'argument \"nombre de lignes à afficher\"\nhead(x = rp, n = 10)\n\n    id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee\n 1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019\n 2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019\n 3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019\n 4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019\n 5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019\n 6:  1 69388 1.0714436   4    2    1     28     1    1    1  2019\n 7:  1 69384 2.6176763   5    2    2     50     1    2    1  2019\n 8:  1 69383 3.0192726   8    2    1     23     2    1    1  2019\n 9:  1 69383 3.0192726   4    2    2     23     2    1    2  2019\n [ reached getOption(\"max.print\") -- omitted 1 row ]\n\n\nIci toutes les vecteurs/colonnes sont de type numérique. Il sera possible de modifier les colonnes qui devraient être des facteurs car ce sont des variables catégorielles : la variable IMMI devrait par exemple être une variable catégorielle qui prend deux modalités, “Immigré.e” et “Pas immigré.e”.\nLa fonction table permet de faire un tri croisé sur une variable. On remarque que les données de 2009 et 2019 sont regroupées dans un même tableau. C’est ce qui permettra une comparaison temporelle mais on verra comment en tenir compte par la suite pour ne pas mélanger les données des deux enquêtes.\n\n# L'opérateur $ permet d'accéder à une colonne précise grâce au nom.\n# En faisant un tri croisé sur $annee, je compte le nombre d'individus recensé.es\n# en 2009 et en 2019. \ntable(rp$annee)\n\n\n  2009   2019 \n182070 195763 \n\n# Il y 182070 lignes qui ont la valeur 2009, 182070 ont donc été personnes recensées\n# pour le recensement de 2009\n\nL’essentiel du recodage s’opère avec des instructions logiques simples (égal, différent, inférieur ou supérieur à) que l’on peut combiner sur une variable (être cadre ou profession intermédiaire) ou plusieurs variables (être cadre et avoir plus de 60 ans).\n\n## Opérateur égal\n# Pour du numérique\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n# Pour du factoriel ou du texte\n\"Jaune\" == \"Jaune\"\n\n[1] TRUE\n\n\"Jaune\" == \"Vert\"\n\n[1] FALSE\n\n# Opérateur différent\n1 != 1\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n# Inférieur ou supérieur\n1 &gt; 2\n\n[1] FALSE\n\n1 &lt; 2\n\n[1] TRUE\n\n# Compris dans un ensemble de valeurs\n1 %in% c(1, 2, 3) # c(1, 2, 3) est un vecteur créé par la fonction c(). Il contient les valeur de 1, 2, 3\n\n[1] TRUE\n\n1 %in% c(2, 3, 4)\n\n[1] FALSE\n\n\"Jaune\" %in% c(\"Jaune\", \"Vert\")\n\n[1] TRUE\n\n\"Jaune\" %in% c(\"Rouge\", \"Bleu\")\n\n[1] FALSE\n\n# Cumul des conditions\n# Opérateur et (&) : 1 est-il inférieur à 2 et à 3 ?\n1 &lt; 2 & # On revient à la ligne pour que ça soit plus lisible\n  1 &lt; 3\n\n[1] TRUE\n\n# 1 est-il inférieur à 2 et supérieur à 2 ?\n1 &lt; 2 &\n  1 &gt; 2\n\n[1] FALSE"
  },
  {
    "objectID": "rappel_S1S2.html#lintroduction-au-recodage-et-à-la-visualisation-de-données",
    "href": "rappel_S1S2.html#lintroduction-au-recodage-et-à-la-visualisation-de-données",
    "title": "Rappel avant la troisième séance",
    "section": "L’introduction au recodage et à la visualisation de données",
    "text": "L’introduction au recodage et à la visualisation de données\n\nLe recodage\nIl existe plusieurs façons de recoder sur R. On utilisera uniquement le recodage qui utilise les opérateurs logiques pour se concentrer sur deux fonctions polyvalentes, ifelse et case_when.\nLa fonction ifelse permet de faire une action sous condition : si l’âge est supérieur à 18, donne la valeur “majeur.e”, sinon donne la valeur “mineur.e”. case_when étend ce fonctionnement à plus d’une possibilité : si l’âge est supérieur à 18 donne “majeur.e”, si l’âge est compris entre 18 et 64 donne “adulte”, si l’âge est supérieur à 64 donne “senior”.\nIl faut associer ces fonctions à d’autres fonctions qui disent à R quoi faire avec le tableau. La fonction mutate permet de créer une nouvelle colonne. On pourra dire à R : crée une nouvelle colonne (mutate) à partir d’un test sur la valeur initiale de la variable (ifelse).\nVoici le code pour créer une variable binaire mineur.e/majeur.e.\n\n# Le package à charger pour faire les recodages\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Voici deux versions du ecodage de l'âge des personnes recensées, soit la variable AGEREV. La première est lisible, la deuxième est commentée ligne par ligne.\n\n# Version plus lisible sans les commentaires\nmutate(\n  rp,\n  age_rec = \n    ifelse(\n      AGEREV &gt; 17,\n      \"Majeur.e\",\n      \"Mineur.e\"\n    )\n)\n\n        id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee  age_rec\n     1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019 Mineur.e\n     2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019 Majeur.e\n     3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019 Mineur.e\n     4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019 Majeur.e\n     5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019 Majeur.e\n    ---                                                                       \n377829:  2 69381 0.9999903   5    1    1     31    NA   NA    Z  2009 Majeur.e\n377830:  2 69381 0.9999903   6    2    1     43    NA   NA    Z  2009 Majeur.e\n [ reached getOption(\"max.print\") -- omitted 3 rows ]\n\n# Version commentée\nmutate( # J'utilise la fonction mutate pour créer une colonne\n  rp, # Le premier argument de mutate, le tableau à transformer\n  age_rec = # Le deuxième argument de mutate, le nom de la colonne à créer (à gauche du =) et la valeur que je lui donne (à droite du =)\n    ifelse( # Elle sera créée à l'aide du test opérée par la fonction ifelse\n      AGEREV &gt; 17, # Le premier argument de ifelse, la condition\n      \"Majeur.e\", # Le deuxième argument de ifelse, la valeur à donner si la condition est vérifiée,\n      \"Mineur.e\" # Le troisième argument de ] ifelse, la valeur à donner si la condition n'est pas vérifié\n    ) # Je ferme la parenthèse de la fonction ifelse\n) # Je ferme la parenthèse de la fonction mutate\n\n        id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee  age_rec\n     1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019 Mineur.e\n     2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019 Majeur.e\n     3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019 Mineur.e\n     4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019 Majeur.e\n     5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019 Majeur.e\n    ---                                                                       \n377829:  2 69381 0.9999903   5    1    1     31    NA   NA    Z  2009 Majeur.e\n377830:  2 69381 0.9999903   6    2    1     43    NA   NA    Z  2009 Majeur.e\n [ reached getOption(\"max.print\") -- omitted 3 rows ]\n\n# On obtient bien une nouvelle variable/colonne nommée age_rec qui prend soit la valeur \"Mineur.e\", soit la valeur \"Majeur.e\"\n\nDès qu’on veut utiliser plus d’un test (par exemple, obtenir trois valeurs : mineur.e, adulte, senior), il faut utiliser la fonction case_when.\n\n# Version lisible\nmutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\n        id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee  age_rec\n     1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019 Mineur.e\n     2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019   Adulte\n     3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019 Mineur.e\n     4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019   Senior\n     5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019   Adulte\n    ---                                                                       \n377829:  2 69381 0.9999903   5    1    1     31    NA   NA    Z  2009   Adulte\n377830:  2 69381 0.9999903   6    2    1     43    NA   NA    Z  2009   Adulte\n [ reached getOption(\"max.print\") -- omitted 3 rows ]\n\n# Version commentée\nmutate( # Je crée une variable grâce à la fonction mutate\n  rp, # Le premier argument, je transforme le tableau rp\n  age_rec = # Le deuxième argument, la variable à créer\n    case_when( # Qui sera créee grâce à la fonction case_when\n      # À gauche du \"~\", c'est la condition, à droite la valeur\n      AGEREV &lt; 18 ~ \"Mineur.e\", # Si AGEREV est strictement inférieur à 18, alors la variable prendra la valeur \"Mineur.e\"\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\", # Si AGEREV est strictement supérieur à 17 ET qu'AGEREV est strictement inférieur à 65, alors la variable prendra la valeur \"Adulte\"\n      AGEREV &gt; 64 ~ \"Senior\" # Si AGEREV est strictement supérieur à 64, alors la variable prendra la valeur \"Senior\"\n    ) # Je ferme la parenthèse de la fonction case_when\n) # Je ferme la parenthèse de la fonction mutate\n\n        id   ARM    IPONDI CS1 IMMI SEXE AGEREV NPERR NBPI LPRM annee  age_rec\n     1:  1 69388 1.1778303   8    2    1     14     3    3    3  2019 Mineur.e\n     2:  1 69388 1.1778303   3    2    2     43     3    3    1  2019   Adulte\n     3:  1 69388 1.1778303   8    2    1     11     3    3    3  2019 Mineur.e\n     4:  1 69384 2.9651895   8    1    2     85     1    4    1  2019   Senior\n     5:  1 69383 0.9564125   8    2    1     23     1    1    1  2019   Adulte\n    ---                                                                       \n377829:  2 69381 0.9999903   5    1    1     31    NA   NA    Z  2009   Adulte\n377830:  2 69381 0.9999903   6    2    1     43    NA   NA    Z  2009   Adulte\n [ reached getOption(\"max.print\") -- omitted 3 rows ]\n\n\nIl manque deux choses aux recodages ci-dessus. Nous n’avons pas enregistré notre travail car nous n’avons pas créé de nouvel objet avec l’opérateur d’assignation &lt;-. On peut soit réécrire sur le tableau de données original ou en créer un nouveau qui sera notre nouveau support de travail.\n\n# Je transforme directement le tableau initial\nrp &lt;- # Crée un nouvel objet rp (qui existait déjà, donc on réécrit desus) à partir du tableau initial (rp) transformé  avec mutate\n  mutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\n# Je créer un autre tableau sur lequel je travail\nrp2 &lt;- # Crée un nouvel objet rp2 (qui n'existait pas) à partir du tableau initial (rp) transformé avec mutate\n  mutate(\n  rp,\n  age_rec =\n    case_when(\n      AGEREV &lt; 18 ~ \"Mineur.e\",\n      AGEREV &gt; 17 & AGEREV &lt; 65 ~ \"Adulte\",\n      AGEREV &gt; 64 ~ \"Senior\"\n    )\n)\n\nDeuxième élément manquant, nous n’avons pas spécifier la nature de notre nouvelle colonne/vecteur. On cherche ici à créer un facteur puisqu’on a une variable catégorielle. La fonction fct permet de créer un vecteur et de spécifier l’ordre de ses modalités (quand on fera des tableaux ou des graphiques, on voudra que “Senior” apparaisse en dernier, et non entre “Mineur.e” et “Majeur.e” !)\n\n# Un vecteur de type texte qui renseigne la catégorie d'âge de 6 personnes\ncat_age &lt;- c(\"Mineur.e\", \n             \"Adulte\", \n             \"Adulte\", \n             \"Senior\", \n             \"Mineur.e\",\n             \"Senior\")\n# Le tri croisé ne donne pas quelque chose d'intuitif :\ntable(cat_age)\n\ncat_age\n  Adulte Mineur.e   Senior \n       2        2        2 \n\n# La catégorie adulte apparaît avant mineur.e\n# On le transforme en facteur\ncat_age &lt;-\n  fct(cat_age, # Le premier argument, le facteur à transformer\n      levels = # Le deuxième argument, les modalités (levels) avec l'ordre d'apparition \n        c(\"Mineur.e\", \"Adulte\", \"Senior\")\n      )\n# Le problème est résolu\ntable(cat_age)\n\ncat_age\nMineur.e   Adulte   Senior \n       2        2        2 \n\n\n\n\nSavoir utiliser tidyverse et enchaîner les opérations\nLes graphiques utilisés par François Héran nous ont servi d’exemple pour comprendre toutes les opérations nécessaires pour passer de données tabulaires brutes – un recensement où chaque individu est représenté par une ligne – à des graphiques qui représentent l’évolution du nombre d’immigré.es et de la proportion d’immigré.es sur plusieurs années. Vous pouvez retrouver le powerpoint à cette adresse, je vous conseille d’aller regarder comment chaque opération est traduite par une ligne de code.\nIl faut à partir d’ici bien comprendre la logique d’enchaînement des opérations propre au tidyverse. Nous avons jusqu’à présent vu qu’on pouvait emboîter les fonctions, par exemple créer un vecteur avec c() puis en faire un facteur avec fct() :\n\nfct(\n  c(\"Jaune\", \"Vert\")\n)\n\n[1] Jaune Vert \nLevels: Jaune Vert\n\n\nIci l’objet brut qu’on va vouloir transformer se situe à la fin du code. L’opérateur pipe %&gt;% permet d’enchaîner les opérations. Il prend un objet et il applique une par une les fonctions qu’on lui donne. C’est l’image d’un objet passant par un tuyau et qu’on modifie progressivement jusqu’au produit final.\n\nc(\"Jaune\", \"Vert\") %&gt;% # Prends ce vecteur\n  fct() # Applique lui la fonction fct()\n\n[1] Jaune Vert \nLevels: Jaune Vert\n\n\nVoici un exemple à partir du recensement lyonnais. Il faudra vous familiariser au fur et à mesure avec la fonction adaptée à chaque opération. Les codes sont commentés dans le premier bloc de code. Je vous conseille d’aller voir les blocs de codes suivants pour vous rendre compte de la transformation progressive du tableau.\n\n# Compter le nombre d'immigré.es et de non-immigré.es à Lyon en 2019\nrp %&gt;% # Prends le tableau de données du recensement\n  filter(annee == 2019) %&gt;% # Garde uniquement les données de 2019\n  mutate( # Crée une nouvelle variable \n    # Le dictionnaire des codes nous dit que la variable IMMI brute vaut 1 si la personne est immigrée, 2 si elle ne l'est pas. On le recode en facteur.\n    IMMI = \n      fct(\n        ifelse(IMMI == 1,\n             \"Immigré.e\",\n             \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;% \n  count(IMMI, # Compte les effectifs pour la variable IMMI\n        wt = IPONDI) # en tenant compte de la pondération (IPONDI est la variable de poids, on la donne à l'argument wt pour weights)\n\n            IMMI         n\n1: Pas immigré.e 452997.59\n2:     Immigré.e  69898.94\n\n# Comparer la proportion d'immigré.es en 2009 et 2019\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee, # On compte d'abord en fonction de l'année\n        IMMI,  # Puis de la varible d'immigration\n        wt = IPONDI) %&gt;%\n  # On crée une nouvelle colonne pour les pourcentages. Il faut pour cela faire une opération groupée : calculer la population totale en 2009 et 2019 = nombre d'immigré.es + nombre de non-immigré.es\n  group_by(annee) %&gt;% # On dit au tidyverse de faire les prochaines opérations au sein du groupe défini par la variable \"annee\"\n  mutate( \n    # La proportion, c'est l'effectif divisé par la population totale. L'effectif ici c'est n, la population totale c'est la somme des n (calculée pour chaque année de façon indépendante !)\n    p =\n      n/sum(n)\n  ) %&gt;%\n  filter(IMMI == \"Immigré.e\") %&gt;% # On ne garde que le pourcentage d'immigré.e car les lignes sont redondantes\n  select(-IMMI) # On enlève la variable IMMI vu qu'on n'a plus que les lignes \"Immigré.e\"\n\n# A tibble: 2 × 3\n# Groups:   annee [2]\n  annee      n     p\n  &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1  2009 57138. 0.119\n2  2019 69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  )\n\n        id   ARM    IPONDI CS1          IMMI SEXE AGEREV NPERR NBPI LPRM annee\n     1:  1 69388 1.1778303   8 Pas immigré.e    1     14     3    3    3  2019\n     2:  1 69388 1.1778303   3 Pas immigré.e    2     43     3    3    1  2019\n     3:  1 69388 1.1778303   8 Pas immigré.e    1     11     3    3    3  2019\n     4:  1 69384 2.9651895   8     Immigré.e    2     85     1    4    1  2019\n     5:  1 69383 0.9564125   8 Pas immigré.e    1     23     1    1    1  2019\n    ---                                                                       \n377829:  2 69381 0.9999903   5     Immigré.e    1     31    NA   NA    Z  2009\n377830:  2 69381 0.9999903   6 Pas immigré.e    1     43    NA   NA    Z  2009\n         age_rec\n     1: Mineur.e\n     2:   Adulte\n     3: Mineur.e\n     4:   Senior\n     5:   Adulte\n    ---         \n377829:   Adulte\n377830:   Adulte\n [ reached getOption(\"max.print\") -- omitted 3 rows ]\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  )\n\n   annee          IMMI         n\n1:  2009 Pas immigré.e 422649.12\n2:  2009     Immigré.e  57137.59\n3:  2019 Pas immigré.e 452997.59\n4:  2019     Immigré.e  69898.94\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   annee [2]\n  annee IMMI                n     p\n  &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1  2009 Pas immigré.e 422649. 0.881\n2  2009 Immigré.e      57138. 0.119\n3  2019 Pas immigré.e 452998. 0.866\n4  2019 Immigré.e      69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n)) %&gt;%\n  filter(IMMI == \"Immigré.e\")\n\n# A tibble: 2 × 4\n# Groups:   annee [2]\n  annee IMMI           n     p\n  &lt;int&gt; &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1  2009 Immigré.e 57138. 0.119\n2  2019 Immigré.e 69899. 0.134\n\n\n\nrp %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \n               \"Immigré.e\",\n               \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\")\n      )\n  ) %&gt;%\n  count(annee,\n        IMMI,\n        wt = IPONDI\n  ) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p =\n           n/sum(n)) %&gt;%\n  filter(IMMI == \"Immigré.e\") %&gt;%\n  select(-IMMI)\n\n# A tibble: 2 × 3\n# Groups:   annee [2]\n  annee      n     p\n  &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1  2009 57138. 0.119\n2  2019 69899. 0.134"
  },
  {
    "objectID": "pptS4.html#la-lecture-dune-boîte-à-moustaches",
    "href": "pptS4.html#la-lecture-dune-boîte-à-moustaches",
    "title": "Powerpoint - Séance 4",
    "section": "La lecture d’une boîte à moustaches",
    "text": "La lecture d’une boîte à moustaches\n\n\n\n\n\n\n\n\n\n50% de la population regarde la télévision moins de 2 heures par jour, 50% de la population la regarde plus de 2 heures par jour.\nIl faut regarder moins d’1 heure par jour la télé pour faire partie des 25% de la population qui regarde le moins la télé.\nIl faut regarder plus de 3 heures par jour la télé pour faire partie des 25% de la population qui regarde le plus la télé.\nLes 50% de la population qui ont une consommation intermédiaire regardent la télé entre 1 heure et 3 heures par jour. Autrement dit, il ne faut pas regarder moins de 1 heure ni regarde plus de 3 heures la télévision par jour pour être dans la norme."
  },
  {
    "objectID": "pptS4.html#lannotation-dun-graphique",
    "href": "pptS4.html#lannotation-dun-graphique",
    "title": "Powerpoint - Séance 4",
    "section": "L’annotation d’un graphique",
    "text": "L’annotation d’un graphique\n\n\nLa note de lecture permet de s’assurer de la bonne compréhension d’un graphique. Elle correspond à un exemple de lecture pour chaque dimension du tableau ou de la représentation graphique présentés.\nLe champ doit rappeler la population de référence. Quand certaines catégories sont ambigues, il faut préciser ce que celles-ci recouvrent. Par exemple, les retraité·es sont parfois regroupé·es dans la catégorie “inactif” et parfois rattaché·es à leur ancienne position professionnelle.\nLa source indique l’origine des données, l’auteur·e et la date de production. . . ."
  },
  {
    "objectID": "pptS4.html#choisir-les-bonnes-formulations-selon-la-nature-des-statistiques-représentées",
    "href": "pptS4.html#choisir-les-bonnes-formulations-selon-la-nature-des-statistiques-représentées",
    "title": "Powerpoint - Séance 4",
    "section": "Choisir les bonnes formulations selon la nature des statistiques représentées",
    "text": "Choisir les bonnes formulations selon la nature des statistiques représentées\n\n\nEn moyenne, les étudiant·es sont les plus jeunes (âge moyen : 21 ans) et passent le moins de temps devant la télévision (temps quotidien moyen : 1,3 heures).\nEn moyenne, les retraité·es sont les plus âgé·es (âge moyen : 70 ans) et passent le plus de temps devant la télévision (temps quotidien moyen : 2,8 heures).\nEn moyenne, les chômeur·es et les personnes employé·es ont des âges proches (respectivement 35 ans et 39 ans). Néanmoins, les chômeur·es passent plus de temps devant la télévision (temps quotidien moyen : 2,8 heures) que les personnes employé·es (temps quotidien moyen : 1,8 heures)."
  },
  {
    "objectID": "pptS4.html#lexploration-des-données",
    "href": "pptS4.html#lexploration-des-données",
    "title": "Powerpoint - Séance 4",
    "section": "L’exploration des données",
    "text": "L’exploration des données\nTous comme les différents indicateurs statistiques (moyenne, variance, corrélation), les représentations graphiques n’ont pas toujours vocation à être utilisées dans l’argumentation scientifique finale. La majorité des visualisations graphiques ne sont pas publiées. Elles servent à explorer les données et à accompagner la construction de l’objet de recherche.\nElles permettent de tester temporairement des hypothèses ou d’identifier des régularités sociales à partir de la distribution des données : est-ce que les niveaux de qualifications semblent être répartis à peu près similairement chez les hommes et chez les femmes ? Est-ce que le nombre moyen d’heures passées devant la télé a l’air de croître avec l’âge ?"
  },
  {
    "objectID": "pptS4.html#le-raisonnement-inférentiel",
    "href": "pptS4.html#le-raisonnement-inférentiel",
    "title": "Powerpoint - Séance 4",
    "section": "Le raisonnement inférentiel",
    "text": "Le raisonnement inférentiel\nSi les traitements statistiques et les représentations graphiques semblent aller dans le sens d’une hypothèse scientifique, il faut alors s’assurer de leur fiabilité vis-à-vis de la question de recherche.\n\nLes statistiques descriptives correspondent (dans un sens restreint) aux opérations de calcul réalisées sur des populations exhaustives. Cela dépend de la base de données : recensement de la population vs enquêtes par questionnaires; bases administratives complètes vs collecte de données de terrain.\nOn appelle population de référence la population que l’on souhaite étudier : les étudiant·es, les entreprises du CAC40, les député·es de l’Assemblée Nationale etc.\nLes statistiques inférentielles correspondent aux opérations réalisées sur une partie de la population de référence, appelée échantillon, dans le but de tirer des conclusions fiables sur celle-ci. La fiabilité de nos affirmations dépend de la représentativité de notre échantillon – ce qui implique de mettre en place des procédures d’échantillonnage et de pondération adéquates – et de ses effectifs.\nL’essentiel de l’analyse quantitative en science sociale repose sur l’estimation de paramètres à l’aide d’estimateurs ainsi que sur l’élaboration de modèles confirmés ou infirmés par des tests d’hypothèse.\n\nOn peut vouloir décrire la structure d’âge d’une population en calculant la moyenne de l’âge (le paramètre M). Comme on dispose rarement d’information sur l’ensemble de la population, on réalise une estimation de la valeur réelle du paramètre grâce à un outil statistique, la moyenne observée (m). La théorie statistique permet de construire des intervalles de confiance renseignant sur la qualité de cette estimation. Elle peut être très précise ou au contraire imprécise.\nOn peut vouloir savoir si le niveau de qualification professionnelle est dépendant du genre, c’est-à-dire si le niveau de qualification diffère en fonction du genre des individus. On doit ici aussi souvent partir d’un échantillon observé et mettre en place des thèses d’hypothèse pour conclure, selon un certain niveau de risque ou seuil de confiance, s’il existe ou non un lien entre les variables étudiées."
  },
  {
    "objectID": "pptS4.html#le-cadre-général-du-raisonnement-statistique-inférentiel",
    "href": "pptS4.html#le-cadre-général-du-raisonnement-statistique-inférentiel",
    "title": "Powerpoint - Séance 4",
    "section": "Le cadre général du raisonnement statistique inférentiel",
    "text": "Le cadre général du raisonnement statistique inférentiel\n\nTiré du Raisonnement statistique en sociologie, Selz et Mailllochon, 2009"
  },
  {
    "objectID": "pptS4.html#la-lecture-dun-tableau-croisé",
    "href": "pptS4.html#la-lecture-dun-tableau-croisé",
    "title": "Powerpoint - Séance 4",
    "section": "La lecture d’un tableau croisé",
    "text": "La lecture d’un tableau croisé\n\n\n\n\n\n\n  \n    \n    \n    \n    \n  \n  \n    \n      Typologie des familles par classe d'âge en 2003\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille (en %)\n      \n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n9%\n70%\n20%\n    31 à 60 ans\n7%\n55%\n38%\n    61 ans et plus\n14%\n57%\n29%\n    Ensemble\n9%\n59%\n32%\n  \n  \n  \n    \n       Lecture : en 2003, 7% des personnes âgées de 31 à 60 ans n’avaient pas de frères et soeurs. Dans l’ensemble, 9% de la population française toutes catégories d’âge confondues n’avaient pas de frères et soeurs \nChamp : personnes majeures habitant en France métropolitaine \nSource : Histoire de Vie 2003 (N = 2000) | A. POISSONNIER | 2023\n    \n  \n\n\n\n\n\nLes personnes âgées de 18 à 30 ans sont sur-représentées parmi les familles d’1 à 3 frères et soeurs (70% contre 59% dans l’ensemble) et sous-représentées parmi les familles de plus de 3 frères et soeurs (20% contre 32% dans l’ensemble).\nLes personnes âgées de 31 à 60 ans sont sous-représentées parmi les familles d’1 à 3 frères et soeurs (55% contre 59% dans l’ensemble) et sur-représentées parmi les familles de plus de 3 frères et soeurs (38% contre 32% dans l’ensemble).\nLes personnes de plus de 61 ans sont sur-représentées parmi les familles uniques (14% contre 9% dans l’ensemble)."
  },
  {
    "objectID": "pptS4.html#une-idée-de-la-variabilité-des-données",
    "href": "pptS4.html#une-idée-de-la-variabilité-des-données",
    "title": "Powerpoint - Séance 4",
    "section": "Une idée de la variabilité des données",
    "text": "Une idée de la variabilité des données\n\n\n\n\n\n\n  \n    \n    \n    \n    \n  \n  \n    \n      Typologie des familles par classe d'âge en 2003\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille (en %)\n      \n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n9% ± 2%\n70% ± 0%\n20% ± 1%\n    31 à 60 ans\n7% ± 1%\n55% ± 0%\n38% ± 0%\n    61 ans et plus\n14% ± 1%\n57% ± 0%\n29% ± 1%\n    Ensemble\n9%\n59%\n32%\n  \n  \n  \n    \n       Lecture : en 2003, 7% des personnes âgées de 31 à 60 ans n’avaient pas de frères et soeurs. Dans l’ensemble, 9% de la population française toutes catégories d’âge confondues n’avaient pas de frères et soeurs \nChamp : Individus de 18 ans et plus habitant en France métropolitaine \nSource : Histoire de Vie 2003 (N = 2000) | A. POISSONNIER | 2023"
  },
  {
    "objectID": "pptS4.html#le-test-du-khi2",
    "href": "pptS4.html#le-test-du-khi2",
    "title": "Powerpoint - Séance 4",
    "section": "Le test du Khi2",
    "text": "Le test du Khi2\nLe test du Khi2 sert à tester la dépendance entre des variables catégorielles à plusieurs modalités. Il repose sur une idée simple : si les effectifs du tri croisé de deux variables sont très différents des effectifs qu’on devrait observer si les deux variables étaient indépendantes, alors on peut raisonnablement conclure qu’elles n’ont pas d’effets l’une sur l’autre. Voilà pourquoi on part d’abord du tableau de contingence qui présente les effectifs observés du croisement de deux variables.\n\n\n\n\n\n\n  \n    \n    \n    \n    \n    \n  \n  \n    \n      Tableau de contingence : effectifs observés\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille\n      \n      Ensemble\n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n33\n242\n76\n351\n    31 à 60 ans\n72\n616\n473\n1 161\n    61 ans et plus\n62\n260\n166\n488\n    Ensemble\n167\n1 118\n715\n2 000"
  },
  {
    "objectID": "pptS4.html#les-effectifs-marginaux",
    "href": "pptS4.html#les-effectifs-marginaux",
    "title": "Powerpoint - Séance 4",
    "section": "Les effectifs marginaux",
    "text": "Les effectifs marginaux\nIl faut par la suite adopter un raisonnement conditionnel : si les deux variables étaient indépendantes, quels seraient nos effectifs ? Ce sont les effectifs marginaux (les totaux d’ensemble) qui nous permettent de calculer ces valeurs.\n\nOn sait que la catégorie d’âge 18 à 30 ans représente \\(\\frac{351}{2000}=17,55\\%\\) de la population.\nOn sait que les familles uniques représentent \\(\\frac{167}{2000}=8,35\\%\\) de la population.\nPar déduction, parmi les 18-30 ans, soit \\(17,55\\%\\) des \\(2000\\) individus, il devrait y en avoir \\(8,35\\%\\) qui appartiennent à une famille unique. On obtient \\(29\\) individus.\n\n\n\n\n\n\n\n  \n    \n    \n    \n    \n    \n  \n  \n    \n      Tableau de contingence : effectifs observés\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille\n      \n      Ensemble\n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n33\n242\n76\n351\n    31 à 60 ans\n72\n616\n473\n1 161\n    61 ans et plus\n62\n260\n166\n488\n    Ensemble\n167\n1 118\n715\n2 000"
  },
  {
    "objectID": "pptS4.html#les-effectifs-théoriques",
    "href": "pptS4.html#les-effectifs-théoriques",
    "title": "Powerpoint - Séance 4",
    "section": "Les effectifs théoriques",
    "text": "Les effectifs théoriques\nLe tableau des effectifs théoriques contient bien de nouvelles valeurs pour les cases des catégories, mais les mêmes valeurs pour les cases d’ensemble. Il faut maintenant mesurer à quel point ces deux tableaux diffèrent : on calculera simplement des écarts.\n\n\n\n\n\n\n  \n    \n    \n    \n    \n    \n  \n  \n    \n      Tableau de contingence : effectifs théoriques\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille\n      \n      Ensemble\n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n29\n196\n125\n351\n    31 à 60 ans\n97\n649\n415\n1 161\n    61 ans et plus\n41\n273\n174\n488\n    Ensemble\n167\n1 118\n714\n2 000"
  },
  {
    "objectID": "pptS4.html#les-écarts-au-carré-rapportés-à-leffectif-théorique",
    "href": "pptS4.html#les-écarts-au-carré-rapportés-à-leffectif-théorique",
    "title": "Powerpoint - Séance 4",
    "section": "Les écarts au carré rapportés à l’effectif théorique",
    "text": "Les écarts au carré rapportés à l’effectif théorique\nAinsi, la valeur du Khi2 est donnée par la formule :\n\\[\n{\\chi}^2=\\sum_{i,j}^{}\\frac{(Eff^{theo}_{i,j}-Eff^{obs}_{i,j})^2}{Eff^{theo}_{i,j}}\n\\]\n\n\n\n\n\n\n  \n    \n    \n    \n    \n    \n  \n  \n    \n      Tableau de contingence : écarts au carré rapportés à l'effectif théorique\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille\n      \n      Ensemble\n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n(29 - 33)2/29\n(196 - 242)2/196\n(125 - 76)2/125\n351\n    31 à 60 ans\n(97 - 72)2/97\n(649 - 616)2/649\n(415 - 473)2/415\n1 161\n    61 ans et plus\n(41 - 62)2/41\n(273 - 260)2/273\n(174 - 166)2/174\n488\n    Ensemble\n167\n1 118\n715\n2 000"
  },
  {
    "objectID": "pptS4.html#le-test-statistique-et-la-p-value-associée",
    "href": "pptS4.html#le-test-statistique-et-la-p-value-associée",
    "title": "Powerpoint - Séance 4",
    "section": "Le test statistique et la p-value associée",
    "text": "Le test statistique et la p-value associée\n\nLa statistique de test \\(\\chi^2\\) donne donc une mesure de l’écart à l’indépendance : jusqu’à quel point ce qu’on observe est éloigné d’une situation où il n’y aurait pas de lien entre les variables ?\nLe test statistique part de la valeur du \\(\\chi^2\\) et la compare avec les écarts qu’on considérerait comme étant le fruit du hasard. Grâce à la loi Normale, on sait modéliser l’aléa de sous forme de probabilités, donc le risque de se tromper en concluant quelque chose à partir des écarts observés.\n\nL’hypothèse nulle du test est celle qu’on essaie souvent de rejeter : la catégorie d’âge et le type de famille n’ont pas de lien entre eux\nL’hypothèse alternative est celle qu’on accepte quand l’hypothèse nulle est rejetée : la catégorie d’âge et le type de famille sont bien interdépendants\nLa logique est similaire à celle d’un procès : on suppose qu’une personne est innocente jusqu’au point où on a assez d’éléments pour raisonnablement juger qu’elle ne l’est pas, même s’il y a toujours un risque de se tromper.\n\nLa p-value, c’est le plus petit niveau de risque tel qu’on peut encore rejeter l’hypothèse nulle. Au vu de la grandeur ou de la petitesse des écarts à l’indépendance mesuré par le \\(\\chi^2\\), est-ce qu’en affirmant qu’il y a un lien entre les variables je risque de me tromper dans 50%, dans 10% ou dans seulement 1% des cas ? En général, on prend comme niveau de risque acceptable 10% pour affirmer que la relation est significative.\nMais attention :\n\nC’est un seuil arbitraire qui s’est cristallisé dans la pratique mais il n’y a aucune justification mathématique à ce niveau.\nQuand p est supérieur au seuil, c’est soit qu’il y a interdépendance, soit que votre échantillon était trop petit pour conclure avec fiabilité sur l’interdépendance des variables.\np ne mesure pas l’intensité de la relation entre les deux variables, seulement la significativité du lien.\np n’est pas la probabilité que les deux variables soient interdépendantes. C’est seulement la probabilité de se tromper en affirmant cela à partir de ce que vous avez observé !"
  },
  {
    "objectID": "pptS4.html#réaliser-un-test-du-khi2-dans-r",
    "href": "pptS4.html#réaliser-un-test-du-khi2-dans-r",
    "title": "Powerpoint - Séance 4",
    "section": "Réaliser un test du Khi2 dans R",
    "text": "Réaliser un test du Khi2 dans R\nLe type de famille et la catégorie d’âge sont-ils interdépendantes ?\n\n\n\n## Test d'indépendance du Khi2 sans pondération\nchisq.test(hdv2003$cat_age, hdv2003$type_fam)\n\n\n    Pearson's Chi-squared test\n\ndata:  hdv2003$cat_age and hdv2003$type_fam\nX-squared = 58.943, df = 4, p-value = 4.837e-12\n\n\n\n\n## Test d'indépendance du Khi2 avec pondération\n# Utilisation du package survey\nlibrary(survey)\n# On crée une base de données qui tient compte de la pondération\nhdv2003_ponderes &lt;- svydesign(ids = ~ 1, \n                              data = hdv2003,\n                              weights = hdv2003$poids)\n# On utilise les fonctions du package survey pour faire le test\nsvychisq(formula = ~cat_age+type_fam,\n         design = hdv2003_ponderes)\n\n\n    Pearson's X^2: Rao & Scott adjustment\n\ndata:  svychisq(formula = ~cat_age + type_fam, design = hdv2003_ponderes)\nF = 10.697, ndf = 3.9378, ddf = 7871.6107, p-value = 1.523e-08\n\n\n\n\n\nLa valeur du Khi2 associé au tri croisé de la catégorie d’âge et du type de famille est d’environ 59.\nCette valeur aboutit à une p-valeur extrêmement petite : il y a 11 zéros après la virgule ! On rejette donc l’hypothèse nulle au profit de l’hypothèse alternative au seuil de 1% (pas besoin de dire au seuil de 0,000…1%), selon laquelle ces deux variables sont bien interdépendantes."
  },
  {
    "objectID": "pptS4.html#le-sexe-et-le-type-de-famille-sont-ils-interdépendants",
    "href": "pptS4.html#le-sexe-et-le-type-de-famille-sont-ils-interdépendants",
    "title": "Powerpoint - Séance 4",
    "section": "Le sexe et le type de famille sont-ils interdépendants ?",
    "text": "Le sexe et le type de famille sont-ils interdépendants ?\n\n## Test d'indépendance du Khi2 sans pondération\nchisq.test(hdv2003$sexe, hdv2003$type_fam)\n\n\n    Pearson's Chi-squared test\n\ndata:  hdv2003$sexe and hdv2003$type_fam\nX-squared = 0.043188, df = 2, p-value = 0.9786\n\n\n\nLa valeur du khi2 associé au tri croisé du sexe et du type de famille est inférieure à 0,1\nLa p-valeur est extrêmement élevée. Il y a plus de 95% de chances de se tromper en affirmant que le sexe et la structure familiale sont interdépendants. On est dans une sorte d’impasse : on ne peut pas rejeter l’hypothèse nulle, mais on ne peut pas dire qu’elle est vérifiée !\nUn plus grand échantillon pourrait être capable d’appréhender des effets subtiles du sexe des enfants sur les comportements de fécondité des parents, par exemple si les parents cherchent à avoir un nouvel enfant quand le premier est une fille. Cela établirait in fine un lien entre ces deux variables qui n’est pas perceptible avec seulement 2000 enquêté·es. En l’état, on ne peut donc rien dire."
  },
  {
    "objectID": "pptS4.html#linterprétation-et-les-hypothèses-sociologiques",
    "href": "pptS4.html#linterprétation-et-les-hypothèses-sociologiques",
    "title": "Powerpoint - Séance 4",
    "section": "L’interprétation et les hypothèses sociologiques",
    "text": "L’interprétation et les hypothèses sociologiques\nLes conclusions tirées des tests d’hypothèse sont ne concernent donc que lespossibilités d’inférence de nos données. Elles n’ont de sens que lorsque ces tests sont mis en place pour répondre à une question de recherche et lorsqu’ils sont suivis d’une interprétation sociologique. Il faut toujours se demander :\n\nLa (non)-significativité de mes résultats est-elle surtout le fruit des catégories choisies, de la taille de mon échantillon et de la façon dont il a été constitué, ou est-elle vraisemblable d’un point de vue sociologique ?\nExemple : une enquête réalisée sur internet interroge le lien entre l’âge et le fait de posséder un portable et un ordinateur. Elle trouve que les senior ne détiennent pas significativement moins d’ordinateurs et de portables que les plus jeunes.\nEst-ce que le lien statistique mis en lumière suggère un lien de causalité entre ces variables, qui a un vrai sens sociologique, ou ai-je seulement identifié une corrélation peu intéressante, qui cache une troisième variable explicative, voire fallacieuse, le lien n’étant que le pur fruit du hasard ?\nExemple : une enquête par questionnaire cherche à savoir si les parisien·nes ont plus souvent des accidents de voiture que les habitant·es du reste du territoire français. Elle trouve au contraire que les parisien·nes sont sous-représenté·es parmi les accidents mineurs et graves.\nQuelles sont les connaissances sociologiques et les résultats empiriques d’autres recherches qui peuvent expliquer le lien d’interdépendance indiqué par les tests ?"
  },
  {
    "objectID": "pptS4.html#linterprétation-démographique-du-lien-entre-la-catégorie-dâge-et-la-typologie-familiale",
    "href": "pptS4.html#linterprétation-démographique-du-lien-entre-la-catégorie-dâge-et-la-typologie-familiale",
    "title": "Powerpoint - Séance 4",
    "section": "L’interprétation démographique du lien entre la catégorie d’âge et la typologie familiale",
    "text": "L’interprétation démographique du lien entre la catégorie d’âge et la typologie familiale\n\n\n\n\n\n\n\n\n  \n    \n    \n    \n    \n  \n  \n    \n      Typologie des familles par classe d'âge en 2003\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille (en %)\n      \n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n9%\n70%\n20%\n    31 à 60 ans\n7%\n55%\n38%\n    61 ans et plus\n14%\n57%\n29%\n    Ensemble\n9%\n59%\n32%\n  \n  \n  \n    \n       Lecture : en 2003, 7% des personnes âgées de 31 à 60 ans n’avaient pas de frères et soeurs. Dans l’ensemble, 9% de la population française toutes catégories d’âge confondues n’avaient pas de frères et soeurs \nChamp : personnes majeures habitant en France métropolitaine \nSource : Histoire de Vie 2003 (N = 2000) | A. POISSONNIER | 2023\n    \n  \n\n\n\n\n\n\n\n\n\nLes personnes âgées de 18 à 30 ans en 2003 sont nées entre 1973 et 1985; de 31 à 60 ans entre 1943 et 1972; de 61 ans et plus avant 1943\nLe lien entre la catégorie d’âge et la typologie familiale s’explique en partie par les différences générationnelles de fécondité. Les 31-60 ans correspondent grossièrement aux générations nées pendant le baby-boom."
  },
  {
    "objectID": "pptS4.html#le-test-de-student-pour-comparer-deux-moyennes",
    "href": "pptS4.html#le-test-de-student-pour-comparer-deux-moyennes",
    "title": "Powerpoint - Séance 4",
    "section": "Le test de Student pour comparer deux moyennes",
    "text": "Le test de Student pour comparer deux moyennes\nLa logique des tests d’hypothèses vue dans le cadre du \\(\\chi^2\\) est valable pour tout un ensemble de tests qui servent des objectifs précis. Le test de Student permet de comparer la moyenne de deux groupes distincts.\n\n\n\n\n\n    Welch Two Sample t-test\n\ndata:  heures.tv by sexe\nt = -0.62219, df = 1955.7, p-value = 0.5339\nalternative hypothesis: true difference in means between group Homme and group Femme is not equal to 0\n95 percent confidence interval:\n -0.2051015  0.1063062\nsample estimates:\nmean in group Homme mean in group Femme \n           2.219330            2.268727 \n\n\n\n    Welch Two Sample t-test\n\ndata:  heures.tv by cinema\nt = 8.6488, df = 1977.5, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group Non and group Oui is not equal to 0\n95 percent confidence interval:\n 0.5078710 0.8057376\nsample estimates:\nmean in group Non mean in group Oui \n         2.517848          1.861044 \n\n\n\n\n\n\n    Design-based t-test\n\ndata:  heures.tv ~ sexe\nt = 0.98807, df = 1993, p-value = 0.3232\nalternative hypothesis: true difference in mean is not equal to 0\n95 percent confidence interval:\n -0.09570646  0.29006822\nsample estimates:\ndifference in mean \n        0.09718088 \n\n\n\n    Design-based t-test\n\ndata:  heures.tv ~ cinema\nt = -6.4033, df = 1993, p-value = 1.891e-10\nalternative hypothesis: true difference in mean is not equal to 0\n95 percent confidence interval:\n -0.7981794 -0.4238941\nsample estimates:\ndifference in mean \n        -0.6110367"
  },
  {
    "objectID": "DM_corrige_code.html",
    "href": "DM_corrige_code.html",
    "title": "DM d’application - Code complété",
    "section": "",
    "text": "options(max.print = 20)\nlibrary(questionr)\nlibrary(Hmisc)\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:questionr':\n\n    describe, wtd.mean, wtd.table, wtd.var\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::lag()       masks stats::lag()\n✖ dplyr::src()       masks Hmisc::src()\n✖ dplyr::summarize() masks Hmisc::summarize()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata(\"hdv2003\")\n\n\n\n\nCe DM doit vous permettre de réviser les fonctions vues sur R. Votre rendu permettra de vous accorder maximum 2 points bonus mais ce sera l’évaluation en janvier qui déterminera votre note. Il faudra remplir tous les blocs de code en dessous des consignes. Si malgré plusieurs essais vous ne parvenez pas à faire fonctionner votre code, il ne faut ni le supprimer ni recopier le code d’une autre personne. Vous pouvez vous entraider si vous vous retrouvez bloquée mais gardez une trace de votre travail en écrivant le code fonctionnel dans un nouveau bloc de code (petit icône vert “+C” en haut à droite du panneau des scritps, à côté du bouton pour lancer le code). Vous ne serez pas pénalisées et c’est la seule façon d’identifier les points mal compris ou les erreurs systématiques grâce à la correction.\nIl faut écrire en dessous des blocs pour répondre aux consignes et, quand c’est nécessaire (j’indiquerai “Commentez les résultats”), proposer une analyse simple des résultats obtenus. La première partie du cours a été plutôt focalisée sur les compétences sur R que sur les méthodes d’analyses quantitatives même si nous nous sommes entraîné·es à l’oral à interpréter les résultats statistiques. On reprendra à la rentrée ce qui aura potentiellement posé problème.\nExemple d’une consigne et de la façon dont il faut remplir le script :\nUtilisez la fonction nrowpour compter le nombre d’individus dans notre tableau hdv2003\n\nnrow(hdv2003)\n\n[1] 2000\n\n\nIl y a 2000 individus dans notre tableau de données.\nUtilisez les fonctions count, group_by et mutate pour connaître la part d’hommes et de femmes qui déclarent pratiquer la chasse ou la pêche. Faites de même pour la lecture de BD.\n\nhdv2003 %&gt;%\n  count(sexe, peche.chasse, wt = poids) %&gt;%\n  group_by(sexe) %&gt;%\n  mutate(p = n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   sexe [2]\n  sexe  peche.chasse        n      p\n  &lt;fct&gt; &lt;fct&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1 Homme Non          4101242. 0.796 \n2 Homme Oui          1048141. 0.204 \n3 Femme Non          5615441. 0.948 \n4 Femme Oui           306403. 0.0517\n\nhdv2003 %&gt;%\n  count(sexe, lecture.bd, wt = poids) %&gt;%\n  group_by(sexe) %&gt;%\n  mutate(p = n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   sexe [2]\n  sexe  lecture.bd        n      p\n  &lt;fct&gt; &lt;fct&gt;         &lt;dbl&gt;  &lt;dbl&gt;\n1 Homme Non        5065699. 0.984 \n2 Homme Oui          83683. 0.0163\n3 Femme Non        5731322. 0.968 \n4 Femme Oui         190522. 0.0322\n\n\n20,4% des hommes déclarent pratiquer la chasse ou la pêche contre seulement 5,2% des femmes. Au contraire, seulement 1,6% des hommes déclarent lire des BD contre 3,2% des femmes. Les pratiques de loisirs semblent donc dépendantes du genre. La chasse et la pêche apparaissent comme communs, un homme cinq déclarent l’avoir comme loisir, mais particulièrement masculin puisque quatre fois moins de femmes les pratiquent (on ne se soucie pas ici du test statistique qui montrerait que ce loisir est dépendant du genre, le Khi2 sera revu au cours de la quatrième séance).\n\n\n\nRevenez sur les scripts des séances précédentes si vous ne vous souvenez plus des fonctions à utiliser. Je rappelle que j’ai repris en grande partie l’introduction à R et au Tidyverse de Julien Barnier pour les 2 premières séances, n’hésitez pas à naviguer sur son site ou à faire des recherches google en français ou en anglais. Il faut aussi utiliser le panneau d’aide (en appuyant sur la touche F1 ou en lançant la commande help(nom_fonction) dans votre console) pour connaître les arguments à utiliser. Pour les fonctions de l’univers tidyverse, utilisez plutôt le site en ligne de chaque package pour vous orienter (dplyr pour la transformation des données, ggplot2 pour la visualisation de données). Les aides-mémoires sont accessibles directement depuis R-Studio en allant dans l’onglet Help &gt; Cheat Sheets."
  },
  {
    "objectID": "DM_corrige_code.html#bloc-de-code-à-lancer-pour-charger-les-packages-et-les-données",
    "href": "DM_corrige_code.html#bloc-de-code-à-lancer-pour-charger-les-packages-et-les-données",
    "title": "DM d’application - Code complété",
    "section": "",
    "text": "options(max.print = 20)\nlibrary(questionr)\nlibrary(Hmisc)\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:questionr':\n\n    describe, wtd.mean, wtd.table, wtd.var\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::lag()       masks stats::lag()\n✖ dplyr::src()       masks Hmisc::src()\n✖ dplyr::summarize() masks Hmisc::summarize()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata(\"hdv2003\")"
  },
  {
    "objectID": "DM_corrige_code.html#les-consignes",
    "href": "DM_corrige_code.html#les-consignes",
    "title": "DM d’application - Code complété",
    "section": "",
    "text": "Ce DM doit vous permettre de réviser les fonctions vues sur R. Votre rendu permettra de vous accorder maximum 2 points bonus mais ce sera l’évaluation en janvier qui déterminera votre note. Il faudra remplir tous les blocs de code en dessous des consignes. Si malgré plusieurs essais vous ne parvenez pas à faire fonctionner votre code, il ne faut ni le supprimer ni recopier le code d’une autre personne. Vous pouvez vous entraider si vous vous retrouvez bloquée mais gardez une trace de votre travail en écrivant le code fonctionnel dans un nouveau bloc de code (petit icône vert “+C” en haut à droite du panneau des scritps, à côté du bouton pour lancer le code). Vous ne serez pas pénalisées et c’est la seule façon d’identifier les points mal compris ou les erreurs systématiques grâce à la correction.\nIl faut écrire en dessous des blocs pour répondre aux consignes et, quand c’est nécessaire (j’indiquerai “Commentez les résultats”), proposer une analyse simple des résultats obtenus. La première partie du cours a été plutôt focalisée sur les compétences sur R que sur les méthodes d’analyses quantitatives même si nous nous sommes entraîné·es à l’oral à interpréter les résultats statistiques. On reprendra à la rentrée ce qui aura potentiellement posé problème.\nExemple d’une consigne et de la façon dont il faut remplir le script :\nUtilisez la fonction nrowpour compter le nombre d’individus dans notre tableau hdv2003\n\nnrow(hdv2003)\n\n[1] 2000\n\n\nIl y a 2000 individus dans notre tableau de données.\nUtilisez les fonctions count, group_by et mutate pour connaître la part d’hommes et de femmes qui déclarent pratiquer la chasse ou la pêche. Faites de même pour la lecture de BD.\n\nhdv2003 %&gt;%\n  count(sexe, peche.chasse, wt = poids) %&gt;%\n  group_by(sexe) %&gt;%\n  mutate(p = n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   sexe [2]\n  sexe  peche.chasse        n      p\n  &lt;fct&gt; &lt;fct&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1 Homme Non          4101242. 0.796 \n2 Homme Oui          1048141. 0.204 \n3 Femme Non          5615441. 0.948 \n4 Femme Oui           306403. 0.0517\n\nhdv2003 %&gt;%\n  count(sexe, lecture.bd, wt = poids) %&gt;%\n  group_by(sexe) %&gt;%\n  mutate(p = n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   sexe [2]\n  sexe  lecture.bd        n      p\n  &lt;fct&gt; &lt;fct&gt;         &lt;dbl&gt;  &lt;dbl&gt;\n1 Homme Non        5065699. 0.984 \n2 Homme Oui          83683. 0.0163\n3 Femme Non        5731322. 0.968 \n4 Femme Oui         190522. 0.0322\n\n\n20,4% des hommes déclarent pratiquer la chasse ou la pêche contre seulement 5,2% des femmes. Au contraire, seulement 1,6% des hommes déclarent lire des BD contre 3,2% des femmes. Les pratiques de loisirs semblent donc dépendantes du genre. La chasse et la pêche apparaissent comme communs, un homme cinq déclarent l’avoir comme loisir, mais particulièrement masculin puisque quatre fois moins de femmes les pratiquent (on ne se soucie pas ici du test statistique qui montrerait que ce loisir est dépendant du genre, le Khi2 sera revu au cours de la quatrième séance)."
  },
  {
    "objectID": "DM_corrige_code.html#les-ressources",
    "href": "DM_corrige_code.html#les-ressources",
    "title": "DM d’application - Code complété",
    "section": "",
    "text": "Revenez sur les scripts des séances précédentes si vous ne vous souvenez plus des fonctions à utiliser. Je rappelle que j’ai repris en grande partie l’introduction à R et au Tidyverse de Julien Barnier pour les 2 premières séances, n’hésitez pas à naviguer sur son site ou à faire des recherches google en français ou en anglais. Il faut aussi utiliser le panneau d’aide (en appuyant sur la touche F1 ou en lançant la commande help(nom_fonction) dans votre console) pour connaître les arguments à utiliser. Pour les fonctions de l’univers tidyverse, utilisez plutôt le site en ligne de chaque package pour vous orienter (dplyr pour la transformation des données, ggplot2 pour la visualisation de données). Les aides-mémoires sont accessibles directement depuis R-Studio en allant dans l’onglet Help &gt; Cheat Sheets."
  },
  {
    "objectID": "DM_corrige_code.html#rappel-sur-le-fonctionnement-de-lunivers-tidyverse",
    "href": "DM_corrige_code.html#rappel-sur-le-fonctionnement-de-lunivers-tidyverse",
    "title": "DM d’application - Code complété",
    "section": "Rappel sur le fonctionnement de l’univers tidyverse",
    "text": "Rappel sur le fonctionnement de l’univers tidyverse\nOn rappelle que l’opérateur %&gt;% permet d’enchaîner les opérations. Cet opérateur est adapté à l’univers tidyverse dans lequel il n’est plus nécessaire d’utiliser l’opérateur $ pour travailler sur une colonne une fois qu’on a annoncé les données à utiliser. Voici un exemple pour le tri croisé.\nLancez bien chaque bloc de code individuellement pour observer les résultats obtenus.\n\n## Faire un tri croisé avec le R de base sur la variable sexe\ntable(hdv2003$sexe)\n\n\nHomme Femme \n  899  1101 \n\n# Ici, on a un seul argument : la colonne sexe récupérée en écrivant hdv2003$sexe\n\n\n## Faire un tri croisé avec la fonction count du tidyverse (spécifiquement, le package dplyr du tidyverse), sans utiliser l'opérateur pipe\ncount(hdv2003, sexe)\n\n   sexe    n\n1 Homme  899\n2 Femme 1101\n\n# Ici, on a 2 arguments, le tableau de données puis la colonne sur laquelle on fait l'opération\n\n\n## Faire un tri croisé avec la fonction count et l'opérateur pipe\nhdv2003 %&gt;%\n  count(sexe)\n\n   sexe    n\n1 Homme  899\n2 Femme 1101\n\n# Ici, on a \"envoyé\" le tableau hdv2003 à la deuxième ligne pour la deuxième opération. Du coup, hdv2003 est automatiquement considéré comme le premier argument de count, et il faut quand même rajouter le deuxième argument de la colonne sur laquelle on travaille\n\n\n# L'enchaînement des transformations peut continuer. On peut \"envoyer\" notre tri croisé pour continuer à le transformer, par exemple en crééant une nouvelle colonne qui convertit l'unité en milliers d'individus (division par 1000 des effectifs)\nhdv2003 %&gt;%\n  count(sexe) %&gt;%\n  mutate(n_1000 = # la colonne à créer\n           n/1000) # qui vaut la colonne des effectifs n divisée par 1000\n\n   sexe    n n_1000\n1 Homme  899  0.899\n2 Femme 1101  1.101\n\n\nOn rappelle les opérateurs logiques :\n\n== pour tester l’égalité\n!= pour tester la différence\n%in% pour tester l’inclusion dans un ensemble de valeurs, par exemple de 1 à 10 : x %in% 1:10\n&gt; &gt;= &lt; &lt;= pour supérieur, supérieur ou égal, inférieur et inférieur ou égal\nLes opérateurs pour combiner les conditions\n\n& pour la combinaison de deux conditions : opérateur ET\n| pour l’alternative entre deux conditions : opérateur OU\n! pour inverser le sens logique du test\n() pour faire des blocs de condition\n\n\n\n# Un exemple simple\nx &lt;- 5\n\n## Cumul de deux conditions (ET) équivalentes mais écrites différemment\n# x est-il supérieur à 2 et inférieur à 10\n(x &gt; 2 & x &lt; 10) & # ET\n  # l'inverse de \"x inférieur à 2 et supérieur à 10\"\n  # soit x supérieur à 2 et inférieur à 10\"\n  !(x &lt; 2 & x &gt; 10)\n\n[1] TRUE"
  },
  {
    "objectID": "DM_corrige_code.html#recoder-des-données",
    "href": "DM_corrige_code.html#recoder-des-données",
    "title": "DM d’application - Code complété",
    "section": "Recoder des données",
    "text": "Recoder des données\nAjoutez une colonne au tableau hdv2003 appelée fam_nombreuse avec la fonction mutate. Utilisez la fonction ifelse pour recoder la variable freres.soeurs : dans le cas où l’enquêté.e a plus de 5 frères et soeurs, la variable prend la valeur “plus de 5 frères et soeurs”, sinon la valeur “5 ou moins frères et soeurs”. N’oubliez pas qu’il faut réécrire sur hdv2003 avec l’opérateur d’assignation &lt;- pour modifier le tableau, sinon le tableau transformé sera juste affiché dans la console mais rien ne sera enregistré.\n\nhdv2003 &lt;-\n  hdv2003 %&gt;%\n  mutate(\n    fam_nombreuse = ifelse(freres.soeurs &gt; 5,\n                           \"plus de 5 frères et soeurs\",\n                           \"5 ou moins frères et soeurs\")\n  )\n\nEn plus d’ifelse, utilisez la fonction fct pour que la nouvelle colonne obtenue soit un facteur. L’ordre des modalités doit être : “5 ou moins frères et soeurs” puis “plus de 5 fréres et soeurs”.\n\nhdv2003 &lt;-\n  hdv2003 %&gt;%\n  mutate(\n    fam_nombreuse = \n      fct(\n        ifelse(freres.soeurs &gt; 5,\n               \"plus de 5 frères et soeurs\",\n               \"5 ou moins frères et soeurs\"),\n        c(\"5 ou moins frères et soeurs\",\n          \"plus de 5 frères et soeurs\")\n      )\n  )\n\nUtilisez la fonction case_when pour créer une colonne appelée type_fam qui aura 3 modalités : pas de frères et soeurs, 1 à 3 frères et soeurs, plus de 5 frères et soeurs. Il faut à nouveau utiliser la fonction fct pour que la nouvelle colonne soit bien un facteur dont vous préciserez l’ordre des modalités. On rappelle que l’opérateur : permet d’avoir des séquences de nombre : le vecteur c(1, 2, 3) peut s’écrire 1:3.\n\nhdv2003 &lt;-\n  hdv2003 %&gt;%\n  mutate(\n    type_fam = \n      fct(\n        case_when(freres.soeurs == 0 ~ \"pas de frères et soeurs\",\n                  freres.soeurs %in% 1:3 ~ \"1 à 3 frères et soeurs\",\n                  freres.soeurs &gt; 3 ~ \"plus de 3 frères et soeurs\"),\n        levels = c(\"pas de frères et soeurs\",\n                   \"1 à 3 frères et soeurs\",\n                   \"plus de 3 frères et soeurs\")\n      )\n  )\n\nUtilisez la fonction case_when pour créer trois classes d’âges à partir de la variable age : 18 à 30 ans, 31 à 60 ans, 61 ans et plus. Appelez la nouvelle colonne cat_age et n’oubliez pas d’en faire un facteur dont les modalités sont dans le bon ordre.\n\nhdv2003 &lt;-\n  hdv2003 %&gt;%\n  mutate(\n    cat_age = \n      fct(\n        case_when(age %in% 18:30 ~ \"18 à 30 ans\",\n                  age %in% 31:60 ~ \"31 à 60 ans\",\n                  age &gt; 60 ~ \"61 ans et plus\"),\n        levels = c(\"18 à 30 ans\",\n                   \"31 à 60 ans\",\n                   \"61 ans et plus\")\n      )\n  )\n\nRemarque : l’âge est une propriété sociale qui peut être mesurée par des variables de plusieurs natures. Théoriquement, l’âge est une variable quantitative continue : il peut prendre un nombre infini de valeurs qu’on exprime avec une précision plus ou moins grandes (avoir 19 ans, 3 mois, 2 jours, 3 heures etc). L’âge est dans les faits souvent exprimé sous forme de variable quantitative discrète prenant un nombre fini de valeurs (18 ans, 19 ans, avec comme minimum 0 an et un maximum autour de 120 ans). L’enquête histoire de vie mesure l’âge en années révolues, ce qui correspond bien à des nombres entiers plutôt que des nombreux décimaux. Ici, l’utilisation de classes d’âge permet de traiter l’âge comme une variable qualitative : chaque enquêté.e appartient à une catégorie d’âge parmi les 3 options disponibles."
  },
  {
    "objectID": "DM_corrige_code.html#construire-un-tableau-de-contingence-à-partir-dun-tri-croisé-de-deux-variables-catérogielles",
    "href": "DM_corrige_code.html#construire-un-tableau-de-contingence-à-partir-dun-tri-croisé-de-deux-variables-catérogielles",
    "title": "DM d’application - Code complété",
    "section": "Construire un tableau de contingence à partir d’un tri croisé de deux variables catérogielles",
    "text": "Construire un tableau de contingence à partir d’un tri croisé de deux variables catérogielles\nUtilisez la fonction count pour faire un tri croisé des variables cat_age et type_fam. N’oubliez pas qu’il faut utiliser l’argument wt = pour que les calculs utilisent la variable de pondération poids\n\nhdv2003 %&gt;%\n  count(cat_age, type_fam, wt = poids)\n\n      cat_age                   type_fam         n\n1 18 à 30 ans    pas de frères et soeurs  253115.8\n2 18 à 30 ans     1 à 3 frères et soeurs 1889411.7\n3 18 à 30 ans plus de 3 frères et soeurs  537738.0\n4 31 à 60 ans    pas de frères et soeurs  378411.4\n5 31 à 60 ans     1 à 3 frères et soeurs 3138094.0\n6 31 à 60 ans plus de 3 frères et soeurs 2176295.3\n [ reached 'max' / getOption(\"max.print\") -- omitted 3 rows ]\n\n\nReprenez le code que vous venez d’écrire et continuez à transformer le tableau avec l’opérateur %&gt;% pour calculer des pourcentages. Il faudra utiliser la fonction group_by associée à la fonction mutate pour créer une nouvelle colonne appelée p qui fait la division de n, les effectifs de chaque ligne (= l’effectif de chaque type familial calculé au sein de chaque catégorie d’âge), par sum(n), le total d’individu dans chaque catégorie d’âge. Retournez voir la séance 3 pour trouver la présentation de cette opération si vous n’y arrivez pas.\n\nhdv2003 %&gt;%\n  count(cat_age, type_fam, wt = poids) %&gt;%\n  group_by(cat_age) %&gt;%\n  mutate(p = n/sum(n)) %&gt;%\n  ungroup()\n\n# A tibble: 9 × 4\n  cat_age        type_fam                          n      p\n  &lt;fct&gt;          &lt;fct&gt;                         &lt;dbl&gt;  &lt;dbl&gt;\n1 18 à 30 ans    pas de frères et soeurs     253116. 0.0944\n2 18 à 30 ans    1 à 3 frères et soeurs     1889412. 0.705 \n3 18 à 30 ans    plus de 3 frères et soeurs  537738. 0.201 \n4 31 à 60 ans    pas de frères et soeurs     378411. 0.0665\n5 31 à 60 ans    1 à 3 frères et soeurs     3138094. 0.551 \n6 31 à 60 ans    plus de 3 frères et soeurs 2176295. 0.382 \n7 61 ans et plus pas de frères et soeurs     383987. 0.142 \n8 61 ans et plus 1 à 3 frères et soeurs     1530113. 0.567 \n9 61 ans et plus plus de 3 frères et soeurs  784061. 0.291 \n\n\nCalculez maintenant les moyennes d’ensemble pour pouvoir interpréter les pourcentages du tri croisé. Elles correspondent à la part de chaque type familial dans la population, soit le tri à plat de variable type_fam transformé en pourcentages. Il faut à nouveau utiliser les fonctions count et mutate mais group_by ne sera pas nécessaire car on n’a croisé aucune variable dans le compte des effectifs.\n\nhdv2003 %&gt;%\n  count(cat_age, wt = poids) %&gt;%\n  mutate(p = n/sum(n))\n\n         cat_age       n         p\n1    18 à 30 ans 2680265 0.2420929\n2    31 à 60 ans 5692801 0.5141978\n3 61 ans et plus 2698160 0.2437092"
  },
  {
    "objectID": "DM_corrige_code.html#lire-et-interpréter-un-tableau-de-contingence",
    "href": "DM_corrige_code.html#lire-et-interpréter-un-tableau-de-contingence",
    "title": "DM d’application - Code complété",
    "section": "Lire et interpréter un tableau de contingence",
    "text": "Lire et interpréter un tableau de contingence\nVoici le tableau croisé que l’on peut construire à partir des pourcentages obtenus par le code.\n\nCommentez en deux temps ce tableau :\n\nPrésenter les résultats de ce tableau en quelques phrases et expliquez ce qu’on apprend du lien entre le type de famille et l’âge des enquêté·es\nExpliquez ce résultat à l’aide du graphique ci-dessous\n\n\n\nDéfinitions :\n\nLa descendance finale d’une génération représente le nombre moyen d’enfants mis au monde par les femmes nées au cours d’une année donnée et ayant survécu jusqu’à l’âge de 50 ans au moins.\nL’indice conjoncturel de fécondité est la somme des taux de fécondité par âge observés une année donnée. Il indique le nombre total d’enfants des femmes d’une génération fictive qui aurait à chaque âge la fécondité observée à cet âge l’année considérée\n\n\n\nlibrary(gt)\n\n\nAttaching package: 'gt'\n\n\nThe following object is masked from 'package:Hmisc':\n\n    html\n\nhdv2003 %&gt;%\n  count(cat_age, type_fam, wt = poids) %&gt;%\n  group_by(cat_age) %&gt;%\n  mutate(p = n/sum(n),\n         tot = sum(n)) %&gt;%\n  select(-n) %&gt;%\n  ungroup() %&gt;%\n  pivot_wider(values_from = p,\n              names_from = type_fam) %&gt;%\n  gt(rowname_col = \"cat_age\") %&gt;%\n  grand_summary_rows(\n    columns = 3:5,\n    fns = list(Ensemble = ~ wtd.mean(., w =tot)),\n    fmt = ~fmt_percent(.x, decimals = 0)\n  ) %&gt;%\n  fmt_percent(columns = 3:5,\n              decimals = 0) %&gt;%\n  tab_stubhead(\"Catégorie d'âge\") %&gt;%\n  tab_spanner(columns = 3:5,\n              \"Type de famille (en %)\") %&gt;%\n  cols_hide(\"tot\") %&gt;%\n  tab_header(\"Typologie des familles par classe d'âge en 2003\") %&gt;%\n  tab_footnote(md(\"Lecture : en 2003, 7% des personnes âgées de 31 à 60 ans n'avaient pas de frères et soeurs. Dans l'ensemble, 9% de la population française toutes catégories d'âge confondues n'avaient pas de frères et soeurs \\\\\n  Champ : Individus de 18 ans et plus habitant en France métropolitaine \\\\\n                  Source : Histoire de Vie 2003 | A. POISSONNIER | 2023\")) |&gt;\n  cols_width(\n    is.numeric ~ px(120),\n    is.factor ~ px(180))\n\n\n\n\n\n  \n    \n    \n    \n    \n  \n  \n    \n      Typologie des familles par classe d'âge en 2003\n    \n    \n    \n      Catégorie d'âge\n      \n        Type de famille (en %)\n      \n    \n    \n      pas de frères et soeurs\n      1 à 3 frères et soeurs\n      plus de 3 frères et soeurs\n    \n  \n  \n    18 à 30 ans\n9%\n70%\n20%\n    31 à 60 ans\n7%\n55%\n38%\n    61 ans et plus\n14%\n57%\n29%\n    Ensemble\n9%\n59%\n32%\n  \n  \n  \n    \n       Lecture : en 2003, 7% des personnes âgées de 31 à 60 ans n’avaient pas de frères et soeurs. Dans l’ensemble, 9% de la population française toutes catégories d’âge confondues n’avaient pas de frères et soeurs \nChamp : Individus de 18 ans et plus habitant en France métropolitaine \nSource : Histoire de Vie 2003 | A. POISSONNIER | 2023"
  },
  {
    "objectID": "DM_corrige_code.html#boîte-à-moustaches",
    "href": "DM_corrige_code.html#boîte-à-moustaches",
    "title": "DM d’application - Code complété",
    "section": "Boîte à moustaches",
    "text": "Boîte à moustaches\nRevenez sur le TP et le corrigé de la troisième séance si le fonctionnement du package ggplot2 n’est plus clair pour vous. À l’aide des fonctions ggplot et geom_boxplot, construisez une boîte à moustache représentant la distribution du nombre d’heures passées devant la télévision heures.tv. N’oubliez pas d’utiliser l’argument weight = pour spécifier les poids à utiliser.\n\nMoins de combien d’heures environ passent devant la télévision les 50% de la population qui regardent le moins la télévision ?\nAu moins combien d’heures environ passent devant la télévision les 25% de la population qui regardent le plus la télévision ?\nEnviron combien d’heures au minimum et combien d’heures au maximum faut-il regarder la télévision pour faire partie des 50% de la population qui a une consommation intermédiaire (= ne fait pas partie des 25% qui passent le moins de temps devant la télé, ni des 25% qui passent le plus de temps devant la télé)\n\n\nggplot(hdv2003) +\n  geom_boxplot(aes(x = heures.tv,\n                   weight = poids))\n\nWarning: Removed 5 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nConstruire un graphique similaire où le temps passé devant la télé est représenté sur l’axe des abscisses en fonction du niveau de qualification renseigné par la variable qualif\n\nggplot(hdv2003) +\n  geom_boxplot(aes(x = heures.tv,\n                   y = qualif,\n                   weight = poids))\n\nWarning: Removed 5 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nConstruire un graphique similaire où le temps passé devant la télé est représenté sur l’axe des ordonnées en fonction du niveau de qualification renseigné par la variable qualif\n\nggplot(hdv2003) +\n  geom_boxplot(aes(y = heures.tv,\n                   x = qualif,\n                   weight = poids))\n\nWarning: Removed 5 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nConstruire un graphique similaire où le temps passé devant la télé est représenté sur l’axe des abscisses en fonction du niveau de qualification renseigné par la variable qualif , cette-fois ci en excluant au préalable les enquêté·es qui ont un niveau de qualification égal à “Autre” ou “NA”. Il faudra utiliser la fonction filter, n’oubliez pas que l’on peut utiliser l’opérateur %&gt;% pour transformer le tableau de données avant de l’envoyer dans la fonction ggplot.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_boxplot(aes(x = heures.tv,\n                   y = qualif,\n                   weight = poids))\n\nWarning: Removed 4 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nRemarque : Les valeurs manquantes sont parfois codées sous forme logique NA plutôt que sous forme de texte. Il faut normalement utiliser la fonction is.na pour faire un test logique !is.na(qualif) qui les exclue. Le ! est très important car is.na(qualif) retournerait toutes les lignes pour lesquelles la variable qualif prend la valeur logique NA, alors que nous voulons l’inverse ! Le verbe filter comprend quand même qu’il faut supprimer les NA logiques de qualif si vous utilisez le test qualif != \"NA\" normalement adapté au codage des valeurs manquantes sous forme de texte, en tant que modalité à part entière du facteur étudié.\nReprenez votre code et à l’aide de la fonction lims, recentrez le graphique pour que l’axe des abscisses aillent de 0 heures à 8 heures passées devant la télé.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_boxplot(aes(x = heures.tv,\n                   y = qualif,\n                   weight = poids)) +\n  lims(x = c(0, 8))\n\nWarning: Removed 19 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\nReprenez votre code et ajoutez à l’aide de la fonction labs un titre au graphique, un intitulé pour l’axe des ordonnées et l’axes des abscisses, une légende précisant une note de lecture, le champ et la source (origine des données/auteur·e/date). Astuce : si le texte dépasse du graphique, vous pouvez ajoutez “\\n” au milieu de votre texte pour qu’il y ait un retour à la ligne.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_boxplot(aes(x = heures.tv,\n                   y = qualif,\n                   weight = poids)) +\n  lims(x = c(0, 8)) +\n  labs(title = \"Nombre d'heures passées par jour devant la télévision selon le niveau\\nde qualification\",\n       x = \"Heures passées devant la télévision\",\n       y = \"Niveau de qualification\",\n       caption = \"Note de lecture : 50% des cadres passent moins d'environ une heure et demie devant la télévision,\\n25% passent moins d'environ 1 heures et quart, 25% passent plus d'environ 2 heures\n       Source : Histoire de vie 2003 | A. POISSONNIER | 2023\")\n\nWarning: Removed 19 rows containing non-finite values (`stat_boxplot()`)."
  },
  {
    "objectID": "DM_corrige_code.html#diagrammes-en-bâton",
    "href": "DM_corrige_code.html#diagrammes-en-bâton",
    "title": "DM d’application - Code complété",
    "section": "Diagrammes en bâton",
    "text": "Diagrammes en bâton\n\nEffectifs absolus\nUtilisez les fonctions ggplot et geom_bar pour représenter la distribution du niveau de qualification qualif. N’oubliez à nouveau pas les poids et retirez préalablement les enquêté·es pour qui qualif vaut “Autre” ou “NA” à l’aide la fonction filter.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_bar(aes(x = qualif,\n               weight = poids))\n\n\n\n\nRajoutez l’argument fill en dehors de la fonction aes pour colorer toutes les barres en rouge.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_bar(aes(x = qualif,\n               weight = poids),\n           fill = \"red\")\n\n\n\n\nRéessayez en ajoutant maintenant l’argument fill à l’intérieur d’aes pour colorer les barres en fonction du sexe (variable sexe)\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_bar(aes(x = qualif,\n               fill = sexe,\n               weight = poids))\n\n\n\n\nConstruisez un diagramme en bâtons où le sexe apparaît en abscisse et le niveau de qualification apparaît sous forme de couleur.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_bar(aes(x = sexe,\n               fill = qualif,\n               weight = poids))\n\n\n\n\nReprenez votre code et ajoutez l’argument position = \"dodge\" en dehors d’aes pour décaler les bâtons de chaque niveau de qualification. Commentez le graphique obtenu.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  ggplot() +\n  geom_bar(aes(x = sexe,\n               fill = qualif,\n               weight = poids),\n           position = \"dodge\")\n\n\n\n\n\n\nPourcentages\nRéalisez le même diagramme en bâtons que précédemment, qui représente le sexe en abscisse et qui distingue le niveau de qualification par couleur mises côte-à-côte, en représentant cette fois-ci des pourcentages plutôt que des effectifs absolus. Il faudra à nouveau utiliser l’opérateur %&gt;% pour enchaîner les transformations, associé aux fonctions count, group_by et mutate. Aidez-vous des codes présentés dans la troisième séance et rappelez vous qu’il faudra spécifier la hauteur des barres avec l’argument y = p, p étant le nom de la colonne des pourcentages, et ajouter en dehors d’aes l’arguement stat = \"identity\", ce qui indique à geom_bar que les pourcentages doivent être représentés comme tels car vous avez déjà fait les calculs à la main.\n\nhdv2003 %&gt;%\n  filter(qualif != \"Autre\" &\n           qualif != \"NA\") %&gt;%\n  count(sexe, qualif, wt = poids) %&gt;%\n  group_by(sexe) %&gt;%\n  mutate(p = n/sum(n)) %&gt;%\n  ungroup() %&gt;%\n  ggplot() +\n  geom_bar(aes(x = sexe,\n               y = p,\n               fill = qualif),\n           stat = \"identity\",\n           position = \"dodge\")"
  },
  {
    "objectID": "DM_corrige_code.html#nuage-de-points-et-graphique-linéaire",
    "href": "DM_corrige_code.html#nuage-de-points-et-graphique-linéaire",
    "title": "DM d’application - Code complété",
    "section": "Nuage de points et graphique linéaire",
    "text": "Nuage de points et graphique linéaire\nConstruisez un nuage de points avec geom_point dans lequel la variable age est en abscisse et la variable heures.tv en ordonnées. Par définition, on ne peut spécifier de poids dans cette représentation.\n\nggplot(hdv2003) +\n  geom_point(aes(x = age,\n                 y = heures.tv))\n\nWarning: Removed 5 rows containing missing values (`geom_point()`).\n\n\n\n\n\nUtilisez maintenant geom_count à la place de geom_point et spécifiez bien l’argument weight =. Que permet de faire cette fonction ?\n\nggplot(hdv2003) +\n  geom_count(aes(x = age,\n                 y = heures.tv,\n                 weight = poids))\n\nWarning: Removed 5 rows containing non-finite values (`stat_sum()`).\n\n\n\n\n\nTrouvez-vous ces deux visualisations graphiques lisibles et convaincantes ? Pourquoi ?\nLe code ci-dessous crée une variable age5 correspondant à des classes d’âges de 5 ans, sauf la dernière regroupant les personnes de 76 ans et plus. Complétez ce code avec l’opérateur %&gt;%, les fonctions group_by, summarize et wtd.mean pour calculer la moyenne pondérée d’heures passées à la télévision par classe d’âge. Vous apellerez la colonne créée dans summarize heures.tv, et tab doit être un tableau de 2 colonnes (age5 et heures.tv avec une ligne par classe d’âge).\n\ntab &lt;- \n  hdv2003 %&gt;%\n  mutate(age5 = \n           cut(age,\n               breaks = c(seq(15, 75, 5), 120))\n         ) %&gt;%\n  group_by(age5) %&gt;%\n  summarize(heures.tv = wtd.mean(heures.tv, poids))\n\nLancez maintenant ce bloc de code et commentez le graphique.\n\ntab %&gt;%\n  ggplot() +\n  geom_line(aes(x = age5,\n                group = 1,\n                y = heures.tv))"
  },
  {
    "objectID": "DM_corrige_code.html#nuage-détiquettes-ou-de-texte",
    "href": "DM_corrige_code.html#nuage-détiquettes-ou-de-texte",
    "title": "DM d’application - Code complété",
    "section": "Nuage d’étiquettes ou de texte",
    "text": "Nuage d’étiquettes ou de texte\nCalculez à l’aide des fonctions group_by et summarize et wtd.mean les moyennes d’âge et d’heures passées devant la télévision pour chaque statut d’occupation (variable occup). Utilisez ggplot et geom_label pour créer un nuage d’étiquettes plaçant chaque statut d’occupation (étudiant·e, retraité·e etc) dans un plan où l’âge sera en abscisse et le nombre d’heures en ordonnée. Copiez votre code et voyez ce qui diffère en remplaçant geom_label par geom_text. Commentez le graphique.\n\nhdv2003 %&gt;%\n  group_by(occup) %&gt;%\n  summarize(\n    heures.tv = wtd.mean(heures.tv, poids),\n    age = wtd.mean(age, poids)) %&gt;%\n  ggplot() + \n  geom_label(aes(x = age,\n                y = heures.tv,\n                label = occup))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse quantitative - M2 Villes et environnements urbains",
    "section": "",
    "text": "Ce site est dédié au cours d’analyse quantitative du premier semestre du M2 Villes et environnements urbains. Les pages intitulées “Séance” reprennent dans un autre ordre l’introduction à R et au tidyverse de Julien Barnier. Elles doivent vous servir de documentation. Tout leur contenu n’aura pas été vu en cours et ne vous sera pas forcément utile, il faut néanmoins vous y référez pour faciliter l’écriture de votre code."
  },
  {
    "objectID": "Seance3.html",
    "href": "Seance3.html",
    "title": "Séance 3",
    "section": "",
    "text": "La première séance a introduit le langage de programmation R et l’interface RStudio. La deuxième séance a introduit l’univers tidyverse à l’aide de l’exemple du cours au collège de France de François Héran.\nL’objectif est de devenir capable de transformer un tableau de données pour passer de l’information brute à l’analyse de données. La méthode présentée dans ce cours consiste à décomposer et enchaîner les opérations nécessaires à la production de statistiques et de graphiques. Elle demande un temps d’apprentissage plus long que les fonctions synthétiques. Une fois les bases acquises, vous aurez néanmoins la possibilité d’adapter facilement votre code aux traitements statistiques qui vous intéressent.\nCette troisième séance reviendra d’abord sur la production de tri à plats et de tri croisés puis sur la visualisation des données."
  },
  {
    "objectID": "Seance3.html#acquis-des-premières-et-deuxièmes-séances-programme-du-jour",
    "href": "Seance3.html#acquis-des-premières-et-deuxièmes-séances-programme-du-jour",
    "title": "Séance 3",
    "section": "",
    "text": "La première séance a introduit le langage de programmation R et l’interface RStudio. La deuxième séance a introduit l’univers tidyverse à l’aide de l’exemple du cours au collège de France de François Héran.\nL’objectif est de devenir capable de transformer un tableau de données pour passer de l’information brute à l’analyse de données. La méthode présentée dans ce cours consiste à décomposer et enchaîner les opérations nécessaires à la production de statistiques et de graphiques. Elle demande un temps d’apprentissage plus long que les fonctions synthétiques. Une fois les bases acquises, vous aurez néanmoins la possibilité d’adapter facilement votre code aux traitements statistiques qui vous intéressent.\nCette troisième séance reviendra d’abord sur la production de tri à plats et de tri croisés puis sur la visualisation des données."
  },
  {
    "objectID": "Seance3.html#tris-à-plat-et-tris-croisés-compter-les-unités",
    "href": "Seance3.html#tris-à-plat-et-tris-croisés-compter-les-unités",
    "title": "Séance 3",
    "section": "Tris à plat et tris croisés : compter les unités",
    "text": "Tris à plat et tris croisés : compter les unités\nRéaliser un tri à plat ou un tri croisé consiste simplement à compter les individus qui appartiennent à des catégories plus ou moins spécifiques. Le tri à plat compte sur une dimension : le nombre d’hommes et le nombre de femmes. Le tri croisé ajoute une ou plusieurs dimensions : le nombre d’hommes agriculteurs et le nombre de femmes agricultrices. Rappel : La fonction count compte la variable donnée. Indiquer plusieurs variables revient à faire un tri croisé, soit compter des effectifs dans des catégories toujours plus précises. L’argument wt = permet d’indiquer les poids des individus.\nReprenons l’exemple du recensement de la population lyonnaise en 2009 et 2019.\n\n# Regardons à nouveau la structure de l'extrait du recensement\nstr(rp)\n\nClasses 'data.table' and 'data.frame':  377833 obs. of  10 variables:\n $ annee : Factor w/ 2 levels \"2009\",\"2019\": 2 2 2 2 2 2 2 2 2 2 ...\n $ ARM   : int  69388 69388 69388 69384 69383 69388 69384 69383 69383 69383 ...\n $ IPONDI: num  1.178 1.178 1.178 2.965 0.956 ...\n $ CS1   : Factor w/ 8 levels \"1\",\"2\",\"3\",\"4\",..: 8 3 8 8 8 4 5 8 4 6 ...\n $ IMMI  : Factor w/ 2 levels \"1\",\"2\": 2 2 2 1 2 2 2 2 2 2 ...\n $ SEXE  : Factor w/ 2 levels \"1\",\"2\": 1 2 1 2 1 1 2 1 2 1 ...\n $ AGEREV: int  14 43 11 85 23 28 50 23 23 21 ...\n $ NPERR : int  3 3 3 1 1 1 1 2 2 1 ...\n $ NBPI  : int  3 3 3 4 1 1 2 1 1 3 ...\n $ LPRM  : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 3 1 3 1 1 1 1 1 2 1 ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n# La variable annee est un facteur à deux modalités\nclass(rp$annee)\n\n[1] \"factor\"\n\nlevels(rp$annee)\n\n[1] \"2009\" \"2019\"\n\n# La variable IPONDI est une variable numérique\nclass(rp$IPONDI)\n\n[1] \"numeric\"\n\n\nComplétez ce code pour compter la population lyonnaise en 2009 et 2019\n\nrp %&gt;%\n  count(annee, wt = IPONDI)\n\n   annee        n\n1:  2009 479786.7\n2:  2019 522896.5\n\n\nComplétez ce code pour compter la population lyonnaise par arrondissement en 2009 et 2019\n\nrp %&gt;%\n  count(annee, ARM, wt = IPONDI)\n\n    annee   ARM         n\n 1:  2009 69381  28283.00\n 2:  2009 69382  30518.00\n 3:  2009 69383  95462.80\n 4:  2009 69384  35056.55\n 5:  2009 69385  46797.00\n 6:  2009 69386  49141.42\n 7:  2009 69387  69162.78\n 8:  2009 69388  76781.25\n 9:  2009 69389  48583.91\n10:  2019 69381  29648.00\n11:  2019 69382  31298.00\n12:  2019 69383 102720.60\n13:  2019 69384  36051.48\n14:  2019 69385  49670.00\n15:  2019 69386  52850.00\n16:  2019 69387  82545.87\n17:  2019 69388  86135.57\n18:  2019 69389  51977.00\n\n\nComplétez ce code pour compter la population lyonnaise par arrondissement et par sexe en 2009 et 2019\n\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI)\n\n    annee   ARM SEXE        n\n 1:  2009 69381    1 13550.49\n 2:  2009 69381    2 14732.51\n 3:  2009 69382    1 14440.44\n 4:  2009 69382    2 16077.56\n 5:  2009 69383    1 44708.85\n 6:  2009 69383    2 50753.96\n 7:  2009 69384    1 16076.23\n 8:  2009 69384    2 18980.32\n 9:  2009 69385    1 21116.68\n10:  2009 69385    2 25680.32\n11:  2009 69386    1 22276.92\n12:  2009 69386    2 26864.50\n13:  2009 69387    1 32999.05\n14:  2009 69387    2 36163.73\n15:  2009 69388    1 35639.23\n16:  2009 69388    2 41142.01\n17:  2009 69389    1 23050.31\n18:  2009 69389    2 25533.60\n19:  2019 69381    1 14533.11\n20:  2019 69381    2 15114.89\n21:  2019 69382    1 14637.82\n22:  2019 69382    2 16660.18\n23:  2019 69383    1 48527.88\n24:  2019 69383    2 54192.73\n25:  2019 69384    1 16538.39\n26:  2019 69384    2 19513.09\n27:  2019 69385    1 22921.85\n28:  2019 69385    2 26748.15\n29:  2019 69386    1 24357.64\n30:  2019 69386    2 28492.36\n31:  2019 69387    1 39524.19\n32:  2019 69387    2 43021.68\n33:  2019 69388    1 40121.70\n34:  2019 69388    2 46013.87\n35:  2019 69389    1 24781.01\n36:  2019 69389    2 27195.99\n    annee   ARM SEXE        n"
  },
  {
    "objectID": "Seance3.html#calcul-des-pourcentages-dans-un-tri",
    "href": "Seance3.html#calcul-des-pourcentages-dans-un-tri",
    "title": "Séance 3",
    "section": "Calcul des pourcentages dans un tri",
    "text": "Calcul des pourcentages dans un tri\n\nCréer une nouvelle colonne qui fait la division\nOn peut obtenir des pourcentages en divisant la population dans la sous-catégorie par la population totale. On utilise la fonction mutate pour créer une nouvelle variable. On l’associe à la fonction sum pour calculer la populaton totale.\nComplétez ce code pour calculer la part de chaque arrondissement dans la population lyonnaise en 2019\n\nrp %&gt;%\n  count(ARM, wt = IPONDI) %&gt;%\n  mutate(p = n/sum(n))\n\n     ARM         n          p\n1: 69381  57931.00 0.05777597\n2: 69382  61816.00 0.06165058\n3: 69383 198183.41 0.19765306\n4: 69384  71108.03 0.07091774\n5: 69385  96467.00 0.09620885\n6: 69386 101991.42 0.10171848\n7: 69387 151708.64 0.15130266\n8: 69388 162916.82 0.16248085\n9: 69389 100560.91 0.10029180\n\n\n\n\nLes pourcentages dans les sous-populations\nLa définition de la population totale dépend du type de pourcentage que vous voulez calculer. Il faudra modifier en conséquence votre code pour que la fonction sum n’additionne pas toutes les lignes du tableau !\nPar exemple :\n\nAu numérateur, le nombre de femmes habitant dans le 1er arrondissement de Lyon en 2019.\nAu dénominateur\n\nLe nombre d’habitant.es dans le 1er arrondissement de Lyon en 2019. On obtient la part femmes dans l’arrondissement.\nIl faudra faire la somme de la population au sein de chaque arrondissement à une année donnée, soit indiquer group_by(annee, ARM)\nLe nombre d’habitant.es à Lyon en 2019. On obtient la part que représentent les femmes du 1er arrondissement dans la population lyonnaise.\nIl faudra faire la somme de la population pour chaque année uniquement, soit indiquer group_by(annee)\n\n\n\n# Quelle est la part de femmes dans le premier arrondissement lyonnais en 2019 ?\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee, ARM) %&gt;%\n  mutate(p = n/sum(n)) %&gt;%\n  ungroup() %&gt;%\n  filter(annee == 2019 &\n           ARM == 69381 &\n           SEXE == 2)\n\n# A tibble: 1 × 5\n  annee   ARM SEXE       n     p\n  &lt;fct&gt; &lt;int&gt; &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 2019  69381 2     15115. 0.510\n\n# Il y a 51,0% de femmes dans le 1er arrondissement en 2019.\n\n# Quelle part représentent les femmes du premier arrondissement parmi la population lyonnaise en 2019 ?\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee) %&gt;%\n  mutate(p = n/sum(n)) %&gt;%\n  ungroup() %&gt;%\n  filter(annee == 2019 &\n           ARM == 69381 &\n           SEXE == 2)\n\n# A tibble: 1 × 5\n  annee   ARM SEXE       n      p\n  &lt;fct&gt; &lt;int&gt; &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 2019  69381 2     15115. 0.0289\n\n# Les femmes du 1er arrondissement représentent 2,9% de la population lyonnaise en 2019."
  },
  {
    "objectID": "Seance3.html#la-mise-en-forme-des-tableaux",
    "href": "Seance3.html#la-mise-en-forme-des-tableaux",
    "title": "Séance 3",
    "section": "La mise en forme des tableaux",
    "text": "La mise en forme des tableaux\n\nChanger le format d’un tableau\nLes tableaux obtenus deviennent rapidement trop longs pour être lisibles. La présentation habituelle des tableaux croisés consiste à indiquer les modalités de la variable 1 en ligne et les modalités de la variable 2 en colonnes. C’est la fonction pivot_wider qui permet de transformer un tableau long en un tableau large.\n\n# La part d'hommes et de femmes par arrondissement en 2019\n## Code pour obtenir le tableau sous format long\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee, ARM) %&gt;%\n  mutate(p = n/sum(n)) %&gt;% \n  ungroup() %&gt;%\n  filter(annee == 2019) %&gt;%\n  select(-annee, -n) # On enlève la colonne des effectifs pour ne garder que les pourcentages\n\n# A tibble: 18 × 3\n     ARM SEXE      p\n   &lt;int&gt; &lt;fct&gt; &lt;dbl&gt;\n 1 69381 1     0.490\n 2 69381 2     0.510\n 3 69382 1     0.468\n 4 69382 2     0.532\n 5 69383 1     0.472\n 6 69383 2     0.528\n 7 69384 1     0.459\n 8 69384 2     0.541\n 9 69385 1     0.461\n10 69385 2     0.539\n11 69386 1     0.461\n12 69386 2     0.539\n13 69387 1     0.479\n14 69387 2     0.521\n15 69388 1     0.466\n16 69388 2     0.534\n17 69389 1     0.477\n18 69389 2     0.523\n\n## Il faut rajouter une fonction pour l'élargir\n### Ici en mettant le sexe en colonne et l'arrondissement en ligne\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee, ARM) %&gt;%\n  mutate(p = n/sum(n)) %&gt;% \n  ungroup() %&gt;%\n  filter(annee == 2019) %&gt;%\n  select(-annee, -n) %&gt;% \n  pivot_wider(\n    names_from = SEXE, # La variable qui donnera leur nom aux colonnes du tableau élargi\n    values_from = p # La variable qui donnera les valeurs à mettre dans les colonnes\n  )\n\n# A tibble: 9 × 3\n    ARM   `1`   `2`\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 69381 0.490 0.510\n2 69382 0.468 0.532\n3 69383 0.472 0.528\n4 69384 0.459 0.541\n5 69385 0.461 0.539\n6 69386 0.461 0.539\n7 69387 0.479 0.521\n8 69388 0.466 0.534\n9 69389 0.477 0.523\n\n### Là en mettant l'arrondissement en colonne et le sexe en ligne\n## Ce n'est pas la présentation habituelle car on regarde la proportion d'hommes et de femmes\n## Mais ce format est parfois nécessaire pour que les tableaux rentrent dans le document final\nrp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee, ARM) %&gt;%\n  mutate(p = n/sum(n)) %&gt;% \n  ungroup() %&gt;%\n  filter(annee == 2019) %&gt;%\n  select(-annee, -n) %&gt;%\n  pivot_wider(\n    names_from = ARM, # La variable qui donnera leur nom aux colonnes du tableau élargi\n    values_from = p # La variable qui donnera les valeurs à mettre dans les colonnes\n  )\n\n# A tibble: 2 × 10\n  SEXE  `69381` `69382` `69383` `69384` `69385` `69386` `69387` `69388` `69389`\n  &lt;fct&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 1       0.490   0.468   0.472   0.459   0.461   0.461   0.479   0.466   0.477\n2 2       0.510   0.532   0.528   0.541   0.539   0.539   0.521   0.534   0.523\n\n\n\n\nMettre en forme\nLa mise en forme des tableaux sur R et leur exportation demande de nombreuses étapes supplémentaires. Le plus simple pour vous pourrait être de construire votre tableau en recopiant à la main les valeurs sans faire d’erreurs, ou bien utiliser la fonction View() et copier coller les valeurs dans un logiciel de traitement de texte (Word ou Libre Office Writer) ou un tableur (Excel ou Libre Office Calc). N’oubliez pas d’ajouter les parts dans l’ensemble de la population pour comparer.\n\ntab &lt;- \n  rp %&gt;%\n  count(annee, ARM, SEXE, wt = IPONDI) %&gt;%\n  group_by(annee, ARM) %&gt;%\n  mutate(p = n/sum(n)) %&gt;% \n  ungroup() %&gt;%\n  filter(annee == 2019) %&gt;%\n  select(-annee, -n) %&gt;%\n  pivot_wider(\n    names_from = SEXE,\n    values_from = p\n  )\n# View(tab)\n\n## Je calcule les parts dans l'ensemble de la population, soit juste la part d'hommes et la part de femmes dans la population lyonnaise en 2019.\nrp %&gt;%\n  count(annee, SEXE, wt = IPONDI) %&gt;% # Ici j'ai enlevé le croisement avec les arrondissements pour le compte des effectifs\n  group_by(annee) %&gt;% # Je calcule les parts sans le croisement avec les arrondissements\n  mutate(p = n/sum(n)) %&gt;% \n  ungroup() %&gt;%\n  filter(annee == 2019) %&gt;%\n  select(-annee, -n)\n\n# A tibble: 2 × 2\n  SEXE      p\n  &lt;fct&gt; &lt;dbl&gt;\n1 1     0.470\n2 2     0.530"
  },
  {
    "objectID": "Seance3.html#la-visualisation-de-données-avec-ggplot2---la-logique-additive",
    "href": "Seance3.html#la-visualisation-de-données-avec-ggplot2---la-logique-additive",
    "title": "Séance 3",
    "section": "La visualisation de données avec ggplot2 - La logique additive",
    "text": "La visualisation de données avec ggplot2 - La logique additive\n\nLa logique additive - Les variable catégorielles\nLe package ggplot2 permet de faire l’essentiel de la représentation graphique des données. Il a l’avantage de fonctionner selon une logique proche à l’enchaînement des opérations du l’univers tidyverse, sauf qu’il additionne des couches avec l’opérateur + quand les verbes de dplyr enchaînaient des fonctions avec l’opérateur %&gt;%.\n\nLa fonction ggplot permet de déclarer les données sur lesquelles on va travailler.\nLes fonctions de la forme geom_ permettent de produire des graphiques. On indique les variables à utiliser à l’intérieur de la fonction aes().\nD’autres fonctions permettent de paramétrer le graphique, ajouter des légendes et d’autres modifications.\n\n\n# Créons un tableau avec les seules données du RP de 2019\nrp19 &lt;- filter(rp, annee == 2019)\n\n# Créons un diagramme en bâtons de la population des arrondissements lyonnais\nggplot(rp19) +\n  geom_bar(aes(x = ARM))\n\n\n\n\n\n\nCohérence entre les données, le type de graphique et le code\nLe graphique ci-dessus est un exemple très commun des problèmes qui émergent quand on ne s’assure pas de la cohérence entre les données dont on dispose, le type de graphique qu’on construit et le code qu’on écrit. Il faut toujours régler les problèmes au fur et à mesure, c’est la seule façon d’isoler les problèmes et de les régler efficacement.\n\nclass(rp19$ARM)\n\n[1] \"integer\"\n\n# Les arrondissements sont considérés comme des valeurs numériques.\n# Il faut les convertir en facteurs. Profitons-en pour recoder.\nrp19 &lt;-\n  rp19 %&gt;%\n  mutate(\n    arrondissements =\n      fct(\n        case_when(\n          ARM == 69381 ~ \"1er\",\n          ARM == 69382 ~ \"2nd\",\n          ARM == 69383 ~ \"3e\",\n          ARM == 69384 ~ \"4e\",\n          ARM == 69385 ~ \"5e\",\n          ARM == 69386 ~ \"6e\",\n          ARM == 69387 ~ \"7e\",\n          ARM == 69388 ~ \"8e\",\n          ARM == 69389 ~ \"9e\"\n        ),\n        levels = c(\"1er\",\n                   \"2nd\",\n                   \"3e\",\n                   \"4e\",\n                   \"5e\",\n                   \"6e\",\n                   \"7e\",\n                   \"8e\",\n                   \"9e\")\n        )\n  )\n\n# On vérifie notre recodage\nlevels(rp19$arrondissements)\n\n[1] \"1er\" \"2nd\" \"3e\"  \"4e\"  \"5e\"  \"6e\"  \"7e\"  \"8e\"  \"9e\" \n\n# Le graphique actualisé\nggplot(rp19) +\n  geom_bar(aes(x = arrondissements))\n\n\n\n\nSachant que la fonction pour représenter des histogrammes (pour les variables quantitatives) est geom_histogram et que la variable de l’âge des individus rencensés est AGEREV, vérifiez que la variable d’âge est de la bonne classe d’objet et construisez un histogramme qui représente la distribution des âges.\n\nclass(rp19$AGEREV)\n\n[1] \"integer\"\n\nggplot(rp19) +\n  geom_histogram(aes(x = AGEREV))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nDistinguer les paramètres liés aux variables et les paramètres indépendants\nIl faut bien distinguer deux types de commandes données aux fonctions geom_. Celles à l’intérieur de aes vont interroger les données pour produire quelque chose : compter les effectifs des modalités d’une variable, différencier la coulour ou la forme des points selon les modalités d’une variable etc. Les arguments à l’extérieur de aes s’appliquent uniformément à tous les éléments du graphique.\nAvant de le montrer en graphique, recodez la variable SEXE en facteur. La valeur 1 correspond aux hommes et 2 aux femmes. Faites en sorte que la modalité “Femme” soit la première modalité du nouveau facteur plutôt que l’inverse.\n\nrp19 &lt;-\n  rp19 %&gt;%\n  mutate(\n    SEXE = \n      fct(\n        ifelse(SEXE == 1, \"Homme\", \"Femme\"),\n        levels = c(\"Femme\", \"Homme\"))\n  )\n\n\nggplot(rp19) +\n  geom_bar(aes(x = arrondissements),\n           fill = \"red\")\n\n\n\nggplot(rp19) +\n  geom_bar(aes(x = arrondissements,\n               fill = SEXE))\n\n\n\nggplot(rp19) +\n  geom_bar(aes(x = arrondissements,\n               fill = SEXE,\n               weight = IPONDI))\n\n\n\nrp19 &lt;-\n  rp19 %&gt;%\n  mutate(\n    IMMI = \n      fct(\n        ifelse(IMMI == 1, \"Immigré.e\", \"Pas immigré.e\"),\n        levels = c(\"Pas immigré.e\", \"Immigré.e\"))\n  )\n\nggplot(rp19) +\n  geom_bar(aes(x = arrondissements,\n               fill = IMMI,\n               weight = IPONDI))\n\n\n\n\n\n\nLes variables catégorielles à plus de deux modalités\nReprésentez la population de chaque arrondissement et sa composition socio-professionnelle en excluant les agriculteur.ices, les retraité.es et les inacti.f.ves.\n\nDictionnaire des codes de la variable CS1\n\n\nCode\nModalité\n\n\n\n\n1\nAgriculteurs exploitants\n\n\n2\nArtisans, commerçants et chefs d’entreprise\n\n\n3\nCadres et professions intellectuelles supérieures\n\n\n4\nProfessions Intermédiaires\n\n\n5\nEmployés\n\n\n6\nOuvriers\n\n\n7\nRetraités\n\n\n8\nInactifs\n\n\n\n\nrp19 &lt;-\n  rp19 %&gt;%\n  mutate(\n    csp =\n      fct(\n        case_when(\n          CS1 == 1 ~ \"Agriculteurs exploitants\",\n          CS1 == 2 ~ \"Artisans, commerçants et chefs d'entreprise\",\n          CS1 == 3 ~ \"Cadres et professions intellectuelles supérieures\",\n          CS1 == 4 ~ \"Professions intermédiaires\",\n          CS1 == 5 ~ \"Employés\",\n          CS1 == 6 ~ \"Ouvriers\",\n          CS1 == 7 ~ \"Retraités\",\n          CS1 == 8 ~ \"Inactifs\"),\n        levels = c(\"Agriculteurs exploitants\",\n                   \"Artisans, commerçants et chefs d'entreprise\",\n                   \"Cadres et professions intellectuelles supérieures\",\n                   \"Professions intermédiaires\",\n                   \"Employés\",\n                   \"Ouvriers\",\n                   \"Retraités\",\n                   \"Inactifs\")\n      )\n  )\n\nrp19 %&gt;%\n  filter(!(csp %in% c(\"Agriculteurs exploitants\", \n                      \"Retraités\",\n                      \"Inactifs\"))) %&gt;%\n  ggplot() +\n  geom_bar(aes(x = arrondissements,\n               fill = csp,\n               weight = IPONDI))\n\n\n\n\n\n\nModifier le texte et les légendes\nIl faut ensuite ajouter tous les éléments nécessaires à la bonne lecture d’un graphique. On choisit des couleurs à l’aide du site ColorBrewer.\n\n# Je créer un vecteur nommé, c'est-à-dire que je donne un nom à chacune des valeurs.\ncouleurs_csp &lt;-\n  c(\"Artisans, commerçants et chefs d'entreprise\" = \"#ffffbf\",\n    \"Cadres et professions intellectuelles supérieures\" = \"#d7191c\",\n    \"Professions intermédiaires\" = \"#fdae61\",\n    \"Employés\" = \"#abd9e9\",\n    \"Ouvriers\" = \"#2c7bb6\")\n\n# Je construis mon graphique en filtrant d'abord les données\ngraph &lt;- filter(rp19, !(csp %in% c(\"Agriculteurs exploitants\", \n                      \"Retraités\",\n                      \"Inactifs\"))) %&gt;%\n  ggplot() +\n  geom_bar(aes(x = arrondissements,\n               fill = csp,\n               weight = IPONDI))\n\ngraph +\n  # Je rajoute les légendes\n  labs( # Fonction qui permet de définir les titres et textes\n    title = \"Population et composition socio-professionnelle des arrondissements lyonnais en 2019\",\n    x = \"Arrondissement\",\n    y = \"Effectifs\",\n    fill = \"Catégorie socio-professionnelle\",\n    caption = \n    \"Champ : actif.ves sauf agriculteur.ices\n    Lecture : en 2019, il y avait 18 000 habitant.es dans le premier arrondissement de Lyon.\n    La majorité des habitant.es appartiennent à la catégorie des cadres et des professions intellectuelles supérieures\n    Recensement de la population 2019 | A. POISSONNIER | 2023\") +\n  # Je change les couleurs et le thème graphique\n  scale_fill_manual(values = couleurs_csp,\n                    labels = scales::label_wrap(30)) + \n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  guides(fill = guide_legend(nrow = 3,\n                             byrow = T))"
  },
  {
    "objectID": "Seance3.html#la-visualisation-de-données-avec-ggplot2---choisir-la-représentation-adéquate",
    "href": "Seance3.html#la-visualisation-de-données-avec-ggplot2---choisir-la-représentation-adéquate",
    "title": "Séance 3",
    "section": "La visualisation de données avec ggplot2 - Choisir la représentation adéquate",
    "text": "La visualisation de données avec ggplot2 - Choisir la représentation adéquate\n\nChanger la position des barres superposées\nLa lisibilité d’un graphique et le risque qu’il amène des erreurs d’interprétation est très différent selon la façon dont on représente l’information.\n\n# Je créer un vecteur nommé, c'est-à-dire que je donne un nom à chacune des valeurs.\ncouleurs_csp &lt;-\n  c(\"Artisans, commerçants et chefs d'entreprise\" = \"#ffffbf\",\n    \"Cadres et professions intellectuelles supérieures\" = \"#d7191c\",\n    \"Professions intermédiaires\" = \"#fdae61\",\n    \"Employés\" = \"#abd9e9\",\n    \"Ouvriers\" = \"#2c7bb6\")\n\n# Je construis mon graphique en filtrant d'abord les données\ngraph &lt;- filter(rp19, !(csp %in% c(\"Agriculteurs exploitants\", \n                      \"Retraités\",\n                      \"Inactifs\"))) %&gt;%\n  ggplot() +\n  geom_bar(aes(x = arrondissements,\n               fill = csp,\n               weight = IPONDI),\n           position = \"dodge\")\n\n# Je rajoute les légendes\ngraph +\n  labs( # Fonction qui permet de définir les titres et textes\n    title = \"Population et composition socio-professionnelle des arrondissements lyonnais en 2019\",\n    x = \"Arrondissement\",\n    y = \"Effectifs\",\n    fill = \"Catégorie socio-professionnelle\",\n    caption = \n    \"Champ : actif.ves sauf agriculteur.ices\n    Lecture : en 2019, il y avait 18 000 habitant.es dans le premier arrondissement de Lyon.\n    La majorité des habitant.es appartiennent à la catégorie des cadres et des professions intellectuelles supérieures\n    Recensement de la population 2019 | A. POISSONNIER | 2023\") +\n  # Je change les couleurs et le thème graphique\n  scale_fill_manual(values = couleurs_csp,\n                    labels = scales::label_wrap(30)) + \n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  guides(fill = guide_legend(nrow = 3,\n                             byrow = T))\n\n\n\n\n\n\nReprésenter des distributions en pourcentages\n\n# Je créer un vecteur nommé, c'est-à-dire que je donne un nom à chacune des valeurs.\ncouleurs_csp &lt;-\n  c(\"Artisans, commerçants et chefs d'entreprise\" = \"#ffffbf\",\n    \"Cadres et professions intellectuelles supérieures\" = \"#d7191c\",\n    \"Professions intermédiaires\" = \"#fdae61\",\n    \"Employés\" = \"#abd9e9\",\n    \"Ouvriers\" = \"#2c7bb6\")\n\n# Je construis mon graphique en filtrant d'abord les données\ngraph &lt;- \n  rp19 %&gt;%\n  filter(!(csp %in% c(\"Agriculteurs exploitants\", \n                      \"Retraités\",\n                      \"Inactifs\"))) %&gt;%\n  count(arrondissements, csp, wt = IPONDI) %&gt;%\n  group_by(arrondissements) %&gt;%\n  mutate(p = n/sum(n)) %&gt;%\n  ggplot() +\n  geom_bar(aes(x = arrondissements,\n               y = p,\n               fill = csp),\n           position = \"dodge\",\n           stat = \"identity\")\n\n# Je rajoute les légendes\ngraph +\n  labs( # Fonction qui permet de définir les titres et textes\n    title = \"Population et composition socio-professionnelle des arrondissements lyonnais en 2019\",\n    x = \"Arrondissement\",\n    y = \"Part (en %)\",\n    fill = \"Catégorie socio-professionnelle\",\n    caption = \n    \"Champ : actif.ves sauf agriculteur.ices\n    Lecture : en 2019, 39% des habitant.es du premier arrondissement de Lyon appartenaient à la catégorie cadres et professions intellectuelles supérieures.\n    Recensement de la population 2019 | A. POISSONNIER | 2023\") +\n  # Je change les couleurs et le thème graphique\n  scale_fill_manual(values = couleurs_csp,\n                    labels = scales::label_wrap(30)) + \n  scale_y_continuous(labels = scales::percent) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  guides(fill = guide_legend(nrow = 3,\n                             byrow = T))"
  },
  {
    "objectID": "Seance3.html#la-visualisation-de-données-avec-ggplot2---les-variables-numériques",
    "href": "Seance3.html#la-visualisation-de-données-avec-ggplot2---les-variables-numériques",
    "title": "Séance 3",
    "section": "La visualisation de données avec ggplot2 - les variables numériques",
    "text": "La visualisation de données avec ggplot2 - les variables numériques\n\nLes distributions à l’aide des boîtes à moustache\nCréez des boîtes à moustache à l’aide de la fonction geom_boxplot qui représente la distribution de l’âge en fonction de la variable IMMI. N’utilisez pas les poids cette fois-ci.\n\nrp &lt;-\n  rp %&gt;%\n  mutate(\n    arrondissements =\n      fct(\n        case_when(\n          ARM == 69381 ~ \"1er\",\n          ARM == 69382 ~ \"2nd\",\n          ARM == 69383 ~ \"3e\",\n          ARM == 69384 ~ \"4e\",\n          ARM == 69385 ~ \"5e\",\n          ARM == 69386 ~ \"6e\",\n          ARM == 69387 ~ \"7e\",\n          ARM == 69388 ~ \"8e\",\n          ARM == 69389 ~ \"9e\"\n        ),\n        levels = c(\"1er\",\n                   \"2nd\",\n                   \"3e\",\n                   \"4e\",\n                   \"5e\",\n                   \"6e\",\n                   \"7e\",\n                   \"8e\",\n                   \"9e\")\n        ),\n    csp =\n      fct(\n        case_when(\n          CS1 == 1 ~ \"Agriculteurs exploitants\",\n          CS1 == 2 ~ \"Artisans, commerçants et chefs d'entreprise\",\n          CS1 == 3 ~ \"Cadres et professions intellectuelles supérieures\",\n          CS1 == 4 ~ \"Professions intermédiaires\",\n          CS1 == 5 ~ \"Employés\",\n          CS1 == 6 ~ \"Ouvriers\",\n          CS1 == 7 ~ \"Retraités\",\n          CS1 == 8 ~ \"Inactifs\"),\n        levels = c(\"Agriculteurs exploitants\",\n                   \"Artisans, commerçants et chefs d'entreprise\",\n                   \"Cadres et professions intellectuelles supérieures\",\n                   \"Professions intermédiaires\",\n                   \"Employés\",\n                   \"Ouvriers\",\n                   \"Retraités\",\n                   \"Inactifs\")\n      ),\n    IMMI = fct(ifelse(IMMI == 1, \"Immigré.e\", \"Pas immigré.e\"),\n               levels = c(\"Pas immigré.e\", \"Immigré.e\")),\n    SEXE = fct(ifelse(SEXE == 1, \"Homme\", \"Femme\"),\n               levels = c(\"Femme\", \"Homme\"))\n  )\n\nrp19 &lt;-\n  rp19 %&gt;%\n  mutate(IMMI = fct(ifelse(IMMI == 1, \"Immigré.e\", \"Pas immigré.e\"),\n               levels = c(\"Pas immigré.e\", \"Immigré.e\")),\n    SEXE = fct(ifelse(SEXE == 1, \"Homme\", \"Femme\"),\n               levels = c(\"Femme\", \"Homme\")))\n\n\nrp19 %&gt;%\n  ggplot() +\n  geom_boxplot(aes(x = AGEREV,\n                   y = IMMI))\n\n\n\nrp19 %&gt;%\n  ggplot() +\n  geom_boxplot(aes(y = AGEREV,\n                   x = IMMI))\n\n\n\n\n\n\nCombiner plusieurs graphiques\nOn souhaite parfois réaliser la même opération de visualisation mais le représenter dans des graphiques différents. Cela permet de distinguer les niveaux d’analyse à plus de deux dimensions. Il faut pour cela utiliser les fonctions facet_\n\n# Reproduire la comparaison des âges à 2 recensements mis côte-à-côte\nrp %&gt;%\n  ggplot() +\n  geom_boxplot(aes(y = AGEREV,\n                   x = IMMI)) +\n  facet_wrap(vars(annee))\n\n\n\n# On peut même créer des grilles avec plus d'un croisement\nrp %&gt;%\n  ggplot() +\n  geom_boxplot(aes(y = AGEREV,\n                   x = IMMI)) +\n  facet_grid(vars(SEXE), vars(annee))\n\n\n\n\n\n\nTransformer des données numériques avant de les représenter\nNous avons déjà vu que les verbes de dplyr tel mutate changeaient leur fonctionnement si un groupement avait été annoncé avec group_by. Les variables NBPI et NPERR représentent respectivement le nombre de pièces et le nombre de personnes dans le logement habité par la personne recensée. La variable LPRM prend la valeur 1 quand la personne recensée est la personne de référence du logement. Créez une nouvelle colonne sur le tableau du recensement de 2019 du nombre de pièces et de personnes moyens par arrondissement. La fonction weighted.mean qui prend les arguments x pour le vecteur et w pour les poids vous permettra de tenir compte de la pondération.\n\nrp19 %&gt;%\n  filter(LPRM == 1) %&gt;%\n  group_by(arrondissements) %&gt;%\n  mutate(moy_NBPI = weighted.mean(x= NBPI, w = IPONDI),\n         moy_NPERR = mean(x = NPERR, w = IPONDI))\n\n# A tibble: 104,042 × 14\n# Groups:   arrondissements [9]\n   annee   ARM IPONDI CS1   IMMI  SEXE  AGEREV NPERR  NBPI LPRM  arrondissements\n   &lt;fct&gt; &lt;int&gt;  &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          \n 1 2019  69388  1.18  3     Pas … Femme     43     3     3 1     8e             \n 2 2019  69384  2.97  8     Pas … Femme     85     1     4 1     4e             \n 3 2019  69383  0.956 8     Pas … Femme     23     1     1 1     3e             \n 4 2019  69388  1.07  4     Pas … Femme     28     1     1 1     8e             \n 5 2019  69384  2.62  5     Pas … Femme     50     1     2 1     4e             \n 6 2019  69383  3.02  8     Pas … Femme     23     2     1 1     3e             \n 7 2019  69383  2.95  6     Pas … Femme     21     1     3 1     3e             \n 8 2019  69382  2.88  3     Pas … Femme     29     1     2 1     2nd            \n 9 2019  69389  0.941 5     Pas … Femme     48     1     4 1     9e             \n10 2019  69384  2.79  3     Pas … Femme     38     5     6 1     4e             \n# ℹ 104,032 more rows\n# ℹ 3 more variables: csp &lt;fct&gt;, moy_NBPI &lt;dbl&gt;, moy_NPERR &lt;dbl&gt;\n\n\n\n\nLa fonction summarize\nLa fonction summarize permet de résumer cette information de groupe en un tableau synthétique.\n\nrp19 %&gt;%\n  filter(LPRM == 1) %&gt;%\n  group_by(arrondissements) %&gt;%\n  summarize(moy_NBPI = weighted.mean(x= NBPI, w = IPONDI),\n         moy_NPERR = weighted.mean(x = NPERR, w = IPONDI))\n\n# A tibble: 9 × 3\n  arrondissements moy_NBPI moy_NPERR\n  &lt;fct&gt;              &lt;dbl&gt;     &lt;dbl&gt;\n1 1er                 2.71      1.79\n2 2nd                 2.98      1.86\n3 3e                  2.88      1.89\n4 4e                  3.09      1.93\n5 5e                  3.34      1.96\n6 6e                  3.07      1.90\n7 7e                  2.59      1.75\n8 8e                  2.93      1.91\n9 9e                  3.08      2.02\n\n\nReprésentez graphiquement cette information à l’aide de la fonction geom_point qui crée un nuage de points.\n\nrp19 %&gt;%\n  filter(LPRM == \"1\") %&gt;% # La personne de référence du ménage\n  group_by(arrondissements) %&gt;%\n  summarize(moy_NBPI = weighted.mean(x = NBPI, w = IPONDI),\n            moy_NPERR = weighted.mean(x = NPERR, w = IPONDI)) %&gt;%\n  ggplot() + \n  geom_point(\n    aes(x = moy_NBPI,\n        y = moy_NPERR))\n\n\n\n\nAssociez les points dans le plan en deux dimensions au nom des arrondissements en remplaçant geom_point par geom_text.\n\nrp19 %&gt;%\n  filter(LPRM == \"1\") %&gt;% # La personne de référence du ménage\n  group_by(arrondissements) %&gt;%\n  summarize(moy_NBPI = weighted.mean(x = NBPI, w = IPONDI),\n            moy_NPERR = weighted.mean(x = NPERR, w = IPONDI)) %&gt;%\n  ggplot() +\n  geom_text(\n    aes(x = moy_NBPI,\n        y = moy_NPERR,\n        label = arrondissements))"
  },
  {
    "objectID": "pptS5.html#le-principe-de-la-régression-linéaire",
    "href": "pptS5.html#le-principe-de-la-régression-linéaire",
    "title": "Powerpoint - Séance 5",
    "section": "Le principe de la régression linéaire",
    "text": "Le principe de la régression linéaire\nLa régression linéaire simple est une technique économétrique qui permet de résumer une relation entre deux variables et de s’interroger sur sa significativité statistique. Le nuage de points y est résumé par une droite, appelée droite de régression.\nCe modèle tente de lier les variations d’une variable expliquée (ou dépendante) à celles d’une variable explicative (ou indépendante, covariable, régresseur).\nOn dit qu’un modèle de régression est multiple plutôt que simple lorsqu’on étend l’explication à plusieurs variables explicatives.\nTout comme les indicateurs statistiques et les croisements de variables avec leurs tests statistiques associés, les modèles de régression ont donc pour objectif de mesurer les relations de dépendance entre plusieurs grandeurs ou dimensions du monde social.\nLes modèles de régression linéaires s’inspirent des équations linéaires de la forme \\(y = ax+b\\) où \\(b\\) est l’ordonnée à l’origine, soit la valeur de \\(y\\) quand \\(a=0\\), et \\(a\\) la pente, soit le nombre d’unités d’augmentation de \\(y\\) quand \\(x\\) augmente d’une unité."
  },
  {
    "objectID": "pptS5.html#le-salaire-en-fonction-de-lâge-une-relation-linéaire",
    "href": "pptS5.html#le-salaire-en-fonction-de-lâge-une-relation-linéaire",
    "title": "Powerpoint - Séance 5",
    "section": "Le salaire en fonction de l’âge, une relation linéaire ?",
    "text": "Le salaire en fonction de l’âge, une relation linéaire ?"
  },
  {
    "objectID": "pptS5.html#les-moindres-carrés-ordinaires",
    "href": "pptS5.html#les-moindres-carrés-ordinaires",
    "title": "Powerpoint - Séance 5",
    "section": "Les moindres carrés ordinaires",
    "text": "Les moindres carrés ordinaires\nLe modèle s’écrit sous la forme d’une équation applicable à tout individu statistique \\(i\\) :\n\\[ salaire_i = \\beta_0+\\beta_1 \\times age_i+\\varepsilon_i \\]\nEstimer un modèle consister à déterminer la valeur des paramètres \\(β_0\\) et \\(β_1\\) de manière à maximiser l’ajustement du modèle aux données. Cela revient à chercher \\(β_0\\) et \\(β_1\\) tels que, à partir de l’âge d’un individu, on soit en mesure de déterminer son salaire en se trompant en moyenne le moins possible.\nLa méthode des moindres carrés ordinaires maximise l’ajustement en minimisant la somme des termes résiduels \\(\\varepsilon_i\\). \\(R_2\\) correspond à la part de la variance expliquée par notre modèle, c’est une mesure de sa qualité."
  },
  {
    "objectID": "pptS5.html#lire-les-résultats-dun-modèle-de-régression-linéaire",
    "href": "pptS5.html#lire-les-résultats-dun-modèle-de-régression-linéaire",
    "title": "Powerpoint - Séance 5",
    "section": "Lire les résultats d’un modèle de régression linéaire",
    "text": "Lire les résultats d’un modèle de régression linéaire\n\nsummary(model)\n\n\nCall:\nlm(formula = SALRED ~ AGE, data = sample_eec, subset = AGE %in% \n    18:65 & SALRED %in% 0:5000)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2102.5  -545.0  -149.2   375.6  2956.3 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 1058.985    110.379   9.594   &lt;2e-16 ***\nAGE           25.249      2.614   9.659   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 818.8 on 859 degrees of freedom\nMultiple R-squared:  0.09798,   Adjusted R-squared:  0.09693 \nF-statistic: 93.31 on 1 and 859 DF,  p-value: &lt; 2.2e-16\n\n\n\nLa constante (intercept) vaut 1060. Le modèle permet d’estimer qu’en moyenne, le salaire à 0 an est de 1060 euros.\nLe coefficient pour l’âge est significatif et il vaut 25,3. Le modèle permet d’estimer qu’une année d’âge augmente en moyenne le salaire de 25,3 euros.\nÀ 18 ans, le salaire estimé par le modèle est de \\(1060 + 25,3\\times18 = 1515\\) euros.\nÀ 60 ans, le salaire estimé par le modèle est de \\(1060 + 25,3 \\times 60 = 2578\\) euros."
  },
  {
    "objectID": "pptS5.html#un-modèle-adapté-aux-déterminants-du-salaire",
    "href": "pptS5.html#un-modèle-adapté-aux-déterminants-du-salaire",
    "title": "Powerpoint - Séance 5",
    "section": "Un modèle adapté aux déterminants du salaire ?",
    "text": "Un modèle adapté aux déterminants du salaire ?"
  },
  {
    "objectID": "pptS5.html#les-erreurs-sont-dépendantes-de-la-catégorie-socio-professionnelle",
    "href": "pptS5.html#les-erreurs-sont-dépendantes-de-la-catégorie-socio-professionnelle",
    "title": "Powerpoint - Séance 5",
    "section": "Les erreurs sont dépendantes de la catégorie socio-professionnelle",
    "text": "Les erreurs sont dépendantes de la catégorie socio-professionnelle"
  },
  {
    "objectID": "pptS5.html#complexifier-le-modèle---variable-catégorielle",
    "href": "pptS5.html#complexifier-le-modèle---variable-catégorielle",
    "title": "Powerpoint - Séance 5",
    "section": "Complexifier le modèle - variable catégorielle",
    "text": "Complexifier le modèle - variable catégorielle\nUne première façon de complexifier le modèle consiste à introduire des variables indicatrices : elles permettent une augmentation de niveau (en modifiant la constante) de la variable expliquée.\nAinsi, la catégorie socio-professionnelle peut-être exprimée par un codage disjonctif de 3 variables : la variable \\(cadre_i\\) qui vaut 1 si l’individu est cadre et 0 sinon; la variable \\(prof\\_inter_i\\) qui vaut 1 si l’individu est profession intermédiaire et 0 sinon; la variable \\(emp\\_ouv_i\\) qui vaut 1 si l’individu est employé·e ou ouvrier·e et 0 sinon.\nDans l’idée, on aurait envie de modéliser :\n\\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i+\n\\beta_2 \\times cadre_i +\n\\beta_3 \\times prof\\_inter_i +\n\\beta_4 \\times emp\\_ouv_i +\n\\varepsilon_i \\]\nQu’on écrit en réalité avec une catégorie en moins, puisque le coefficient d’une catégorie parmi les trois devient la référence et correspond à \\(\\beta_0\\).\n\\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i+\n\\beta_2 \\times prof\\_inter_i +\n\\beta_3 \\times emp\\_ouv_i +\n\\varepsilon_i \\] Le salaire d’un·e cadre est estimé par : \\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i+\n\\beta_2 \\times 0 +\n\\beta_3 \\times 0 +\n\\varepsilon_i \\]\nQuand celui d’un·e employé·e ou d’un·e ouvrier·e est estimé par :\n\\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i+\n\\beta_2 \\times 0 +\n\\beta_3 \\times emp\\_ouv_i +\n\\varepsilon_i \\]"
  },
  {
    "objectID": "pptS5.html#représentation-graphique-variables-indicatrices",
    "href": "pptS5.html#représentation-graphique-variables-indicatrices",
    "title": "Powerpoint - Séance 5",
    "section": "Représentation graphique variables indicatrices",
    "text": "Représentation graphique variables indicatrices"
  },
  {
    "objectID": "pptS5.html#lecture-du-modèle-de-régression-linéaire-multiple",
    "href": "pptS5.html#lecture-du-modèle-de-régression-linéaire-multiple",
    "title": "Powerpoint - Séance 5",
    "section": "Lecture du modèle de régression linéaire multiple",
    "text": "Lecture du modèle de régression linéaire multiple\n\n\n\nCall:\nlm(formula = SALRED ~ AGE + CSE, data = sample_eec, subset = AGE %in% \n    18:65 & SALRED %in% 0:5000)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2295.50  -411.00   -56.07   283.85  2592.91 \n\nCoefficients:\n                               Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                    1923.441     93.414   20.59   &lt;2e-16 ***\nAGE                              22.094      2.022   10.93   &lt;2e-16 ***\nCSEProfessions intermédiaires  -851.817     53.409  -15.95   &lt;2e-16 ***\nCSEEmployé·es et ouvrier·es   -1277.585     53.392  -23.93   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 631.4 on 857 degrees of freedom\nMultiple R-squared:  0.4648,    Adjusted R-squared:  0.4629 \nF-statistic: 248.1 on 3 and 857 DF,  p-value: &lt; 2.2e-16\n\n\n\nLa constante vaut 1923. En moyenne, le salaire d’un cadre (catégorie de référence) âgé de 0 ans est de 1923 euros.\nLe coefficient de l’âge est significatif et il vaut 22,1. En moyenne et indépendamment de la catégorie socio-professionnelle, une année en plus augmente le salaire de 22,1 euros.\nLe coefficient des professions intermédiaires est significatif et vaut -852. En moyenne, et indépendamment de l’âge, passer de la catégorie cadre à la catégorie profession intermédiaire fait baisser le salaire de 852 euros."
  },
  {
    "objectID": "pptS5.html#une-croissance-similaire-pour-tout-le-monde",
    "href": "pptS5.html#une-croissance-similaire-pour-tout-le-monde",
    "title": "Powerpoint - Séance 5",
    "section": "Une croissance similaire pour tout le monde ?",
    "text": "Une croissance similaire pour tout le monde ?\nAjuster le modèle seulement en changeant le niveau des droites peut s’avérer insuffisant. Est-ce que les employé·es et les ouvrier·es bénéficient réellement de la même progression salariale au cours de leur carrière que les cadres et les professions intermédiaires ?"
  },
  {
    "objectID": "pptS5.html#complexifier-le-modèle---les-effets-dinteraction",
    "href": "pptS5.html#complexifier-le-modèle---les-effets-dinteraction",
    "title": "Powerpoint - Séance 5",
    "section": "Complexifier le modèle - les effets d’interaction",
    "text": "Complexifier le modèle - les effets d’interaction\nLes effets d’interaction ont pour objectif de modifier – en plus de la constante – la pente des droites, donc l’intensité de la relation entre la variable expliquée et la variable explicative. Chaque catégorie se voit attribué deux coefficients propres :\n\\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i+\n\\beta_2 \\times prof\\_inter_i +\n\\beta_3 \\times emp\\_ouv_i +\n\\beta_4 \\times (age_i \\times prof\\_inter_i) +\n\\beta_5 \\times(age_i \\times emp\\_ouv_i) +\n\\varepsilon_i \\]\nEn le décomposant, on a l’effet de niveau de la catégorie socioprofessionnelle :\n\\[ \\beta_0 +\n\\beta_2 \\times prof\\_inter_i +\n\\beta_3 \\times emp\\_ouv_i \\]\nAuquel on additionne l’effet de l’âge, en fonction de la catégorie socio-professionnelle :\\[\n\\beta_1 \\times age_i+\n\\beta_4 \\times (age_i \\times prof\\_inter_i) +\n\\beta_5 \\times(age_i \\times emp\\_ouv_i)\\]"
  },
  {
    "objectID": "pptS5.html#représentation-graphique-interaction",
    "href": "pptS5.html#représentation-graphique-interaction",
    "title": "Powerpoint - Séance 5",
    "section": "Représentation graphique interaction",
    "text": "Représentation graphique interaction"
  },
  {
    "objectID": "pptS5.html#représentation-graphique-interaction-2",
    "href": "pptS5.html#représentation-graphique-interaction-2",
    "title": "Powerpoint - Séance 5",
    "section": "Représentation graphique interaction 2",
    "text": "Représentation graphique interaction 2"
  },
  {
    "objectID": "pptS5.html#lecture-dun-modèle-de-régression-avec-un-effet-dinteraction",
    "href": "pptS5.html#lecture-dun-modèle-de-régression-avec-un-effet-dinteraction",
    "title": "Powerpoint - Séance 5",
    "section": "Lecture d’un modèle de régression avec un effet d’interaction",
    "text": "Lecture d’un modèle de régression avec un effet d’interaction\n\n\n\nCall:\nlm(formula = SALRED ~ AGE * CSE, data = sample_eec, subset = AGE %in% \n    18:65 & SALRED %in% 0:5000)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2029.58  -386.42   -67.95   262.71  2592.76 \n\nCoefficients:\n                                  Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                       1365.733    157.001   8.699  &lt; 2e-16 ***\nAGE                                 35.357      3.621   9.763  &lt; 2e-16 ***\nCSEProfessions intermédiaires     -292.147    211.937  -1.378  0.16842    \nCSEEmployé·es et ouvrier·es       -266.608    210.249  -1.268  0.20512    \nAGE:CSEProfessions intermédiaires  -13.312      4.991  -2.667  0.00779 ** \nAGE:CSEEmployé·es et ouvrier·es    -24.443      4.921  -4.967 8.21e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 623.3 on 855 degrees of freedom\nMultiple R-squared:  0.4798,    Adjusted R-squared:  0.4768 \nF-statistic: 157.7 on 5 and 855 DF,  p-value: &lt; 2.2e-16\n\n\n\nLe coefficient de l’âge est significatif et vaut 35,4. En moyenne chez les cadres (catégorie de référence), une année de plus augmente de 35,4 euros le salaire.\nLe coefficient d’interaction entre l’âge et la catégorie profession intermédiaire est significatif et vaut 13,3. En moyenne, passer de la catégorie cadre à celle de profession intermédiaire fait baisser de 13,3 euros l’augmentation salariale gagnée chaque année. Ainsi, en moyenne chez les professions intermédiaires, une année de plus augmente de \\(35,4-13,3= 22,1\\) euros le salaire.\nLes coefficients des deux catégories socio-professionnelles ne sont pas significatifs. En moyenne, indépendamment de l’âge et en tenant compte de la progression salariale propre à chaque catégorie socio-professionnelle, passer de la catégorie cadre à la catégorie profession intermédiaire ne fait pas significativement baisser le salaire.\nAutrement dit, il existe bien des inégalités salariales entre catégories professionnelles mais celles-ci se constituent au fil de la carrière, quand les individus deviennent plus âgés."
  },
  {
    "objectID": "pptS5.html#tenir-compte-du-temps-de-travail",
    "href": "pptS5.html#tenir-compte-du-temps-de-travail",
    "title": "Powerpoint - Séance 5",
    "section": "Tenir compte du temps de travail",
    "text": "Tenir compte du temps de travail\nLe premier modèle de régression linéaire multiple présenté permettait d’estimer, indépendamment de l’âge, l’augmentation moyenne du salaire selon qu’on appartienne à telle ou telle catégorie socio-professionnelle. Or, on peut s’interroger sur le rapport de causalité : les cadres sont-ils mieux payés uniquement parce que les professions qu’ils exercent sont mieux reconnues et rétribuées, ou est-ce que d’autres facteurs expliquent ces écarts salariaux ?\nNB : les heures de travail sont simulées pour l’exemple, il ne faut pas les prendre comme des données réelles"
  },
  {
    "objectID": "pptS5.html#le-biais-de-variable-omise",
    "href": "pptS5.html#le-biais-de-variable-omise",
    "title": "Powerpoint - Séance 5",
    "section": "Le biais de variable omise",
    "text": "Le biais de variable omise\nOn parle d’erreur ou de biais de la variable omise lorsqu’on rend compte de la variance d’une variable expliquée par une variable explicative donnée et qu’on ne tient pas compte d’une troisième variable susceptible d’expliquer la variance, elle-même corrélée avec la variable explicative.\nL’erreur de la variable manquante vient biaiser l’estimation de l’effet causal : on attribue à la variable explicative des variations de la variable expliquée qui sont en réalité dues à la variable manquante.\nLa régression simple du salaire par l’âge ne fait que comparer les salaires de personnes plus ou moins âgées. Pour que cette comparaison soit instructive, il faut être sûr qu’on a comparé des personnes comparables. « Comparer du comparable », c’est respecter le critère d’analyse toutes choses égales par ailleurs (ou ceteris paribus) : les personnes comparées ne doivent différer au départ que par leur âge. On a déjà modifié notre modèle pour mesurer l’effet de la catégorie socio-professionnelle. Or, pour interpréter ces effets de manière pertinente, il faut s’assurer qu’on ne confond pas ce qui relève de la position des catégories sur le marché du travail avec ce qui relève du temps travaillé."
  },
  {
    "objectID": "pptS5.html#complexifier-le-modèle---variable-quantitative",
    "href": "pptS5.html#complexifier-le-modèle---variable-quantitative",
    "title": "Powerpoint - Séance 5",
    "section": "Complexifier le modèle - variable quantitative",
    "text": "Complexifier le modèle - variable quantitative\nLe salaire est fonction du temps de travail. Or, les catégories socio-professionnelles les mieux rémunérées sont aussi celles qui travaillent le plus. Il y a donc un biais liée à une troisième variable omise, le temps de travail, qui nous induisait en erreur : on prenait pour l’effet de la catégorie socio-professionnelle ce qui est en réalité l’effet de l’inégalité en moyenne du temps de travail.\nOn met en place un nouveau modèle avec une variable quantitative du temps de travail mensuel : \\[ salaire_i = \\beta_0 +\n\\beta_1 \\times age_i +\n\\beta_2 \\times prof\\_inter_i +\n\\beta_3 \\times emp\\_ouv_i +\n\\beta_4 \\times heures_i +\n\\varepsilon_i \\]\nDans cette situation simulée où les cadres travailleraient en moyenne plus longtemps que les professions intermédiaires et les employé·es et ouvrier·es, on obtient :\n\n\n\n\n\n\n  \n    \n      Résultats de deux modèles de régression du salaire\n    \n    \n    \n      Caractéristique\n      \n        Modèle 1\n      \n      \n        Modèle 2\n      \n    \n    \n      Beta\n      95% IC1\n      p-valeur\n      Beta\n      95% IC1\n      p-valeur\n    \n  \n  \n    AGE\n22\n18 – 26\n&lt;0,001\n15\n12 – 19\n&lt;0,001\n    CSE\n\n\n\n\n\n\n        Cadres\n—\n—\n\n—\n—\n\n        Professions intermédiaires\n-852\n-957 – -747\n&lt;0,001\n-227\n-355 – -99\n&lt;0,001\n        Employé·es et ouvrier·es\n-1 278\n-1 382 – -1 173\n&lt;0,001\n-7,1\n-207 – 193\n&gt;0,9\n    HEURES\n\n\n\n73\n63 – 83\n&lt;0,001\n  \n  \n  \n    \n      1 IC = intervalle de confiance"
  },
  {
    "objectID": "pptS5.html#les-modèles-logistiques-pour-les-variables-catégorielles-dichtomiques",
    "href": "pptS5.html#les-modèles-logistiques-pour-les-variables-catégorielles-dichtomiques",
    "title": "Powerpoint - Séance 5",
    "section": "Les modèles logistiques pour les variables catégorielles dichtomiques",
    "text": "Les modèles logistiques pour les variables catégorielles dichtomiques\nNous avons vu jusqu’à présent la modélisation de variables quantitatives. Cependant, il est plus courant en sciences sociales de vouloir étudier des dimensions qualitatives.\nLes variables peuvent porter sur un phénomène que l’on considère qualitatif « par nature » ; par exemple, il va s’agir d’étudier le passage ou non en classe supérieure, le succès ou l’échec à un concours, le fait d’être propriétaire ou non de son appartement, le fait de voter ou non à une élection, le fait d’avoir un casier judiciaire ou non, etc.\nIl arrive aussi que l’on veuille étudier un phénomène continu en théorie, mais dont la mesure empirique nous est, pour une raison ou une autre, inaccessible. On peut alors choisir de construire une variable qualitative indicatrice d’un phénomène observé qui serait la manifestation visible d’une variable latente.\nLes modèles de régression logistique sont une extension des modèles linéaires. Plutôt d’estimer une valeur, on va tenter d’estimer une probabilité."
  },
  {
    "objectID": "pptS5.html#le-logit-et-les-rapports-de-chances",
    "href": "pptS5.html#le-logit-et-les-rapports-de-chances",
    "title": "Powerpoint - Séance 5",
    "section": "Le logit et les rapports de chances",
    "text": "Le logit et les rapports de chances\nLa logique de lecture des modèles logistiques est similaire à celle des modèles linéaires. Il existe néanmoins une difficulté liée à la nature de ce que modèle estime : on ne modélise pas les probabilités en elles-mêmes, mais une fonction qui les contient. \\[\nlog(\\frac{P_i}{1-P_i})=logit(P_i)=\\beta_0 + \\beta_1X_{1i}+\\beta_2X_{2i}+...+\\beta_kX_{ki}+\\varepsilon_i\n\\]On appelle odd ou chances le rapport entre la probabilité \\(P\\) d’occurrence de l’évènement binaire considéré et la probabilité \\(1-P_i\\) de non-occurrence de l’évènement.\nPar exemple, si la probabilité de tomber malade est de \\(0,8\\), la probabilité de ne pas tomber malade est de \\(1-0,8 = 0,2\\). L’odd ou les chances valent ainsi \\(\\frac{0,8}{0,2} = 4\\) : on attend 4 fois plus de personnes malades que de personnes saines.\nOn appelle logit la fonction qui calcule le logarithme de ces chances.\nOn appelle rapport de chances ou odds ratio le rapport \\(\\frac{OR_1}{OR_2}\\) entre deux chances ou odds. Si les chances de tomber malade chez les nourrissons valent 10 contre seulement 5 chez les adultes, l’odd ratio associé vaut \\(\\frac{10}{5}=2\\). L’interprétation est complexe car ce n’est pas un simple rapport de probabilités : on ne peut pas dire que la probabilité de tomber malade pour un nourrisson est deux fois plus élevée que celle d’un adulte.\nOn gardera seulement en tête qu’un odd ratio supérieur à 1 signifie que la catégorie au numérateur a de plus grandes chances que la catégorie au dénominateur; on attend donc plus de personnes malades que saines chez les nourrissons que chez les adultes."
  },
  {
    "objectID": "pptS5.html#les-expulsions-locative---camille-françois",
    "href": "pptS5.html#les-expulsions-locative---camille-françois",
    "title": "Powerpoint - Séance 5",
    "section": "Les expulsions locative - Camille François",
    "text": "Les expulsions locative - Camille François\nLa question de recherche :\n\n“dans quelle mesure les magistrat·e·s tendent-ils·elles à imposer, parallèlement aux ressources et demandes juridiques des parties et aux règles formelles régissant la procédure judiciaire, des conditions spécifiques et asymétriques aux différentes catégories de justiciables pour exercer leurs droits au tribunal ?” pages 528-529\n\nL’objectif de l’article :\n\n“L’enjeu de notre réflexion est d’articuler […] deux aspects de la fabrique des inégalités d’usages et de traitement de la justice : d’une part, les usages différentiels du droit et du protocole judiciaire auxquels procèdent les propriétaires et les locataires (en termes de présence à l’audience, de recours à un·e avocat·e, etc.) ; et d’autre part, l’asymétrie des conditions – formelles mais également informelles – de recevabilité et d’efficacité qu’imposent les magistrat·e·s aux stratégies de ces deux catégories de justiciables” page 529"
  }
]